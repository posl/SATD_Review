{
  "meta_a": {
    "name": "src/quick/scenegraph/qsgwindowsrenderloop.cpp",
    "content_type": "text/x-c++src",
    "lines": 514,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003dba4419df92bad6953c81be03a4ccf5cc137cb2d3;f\u003dsrc%2Fquick%2Fscenegraph%2Fqsgwindowsrenderloop.cpp"
      }
    ]
  },
  "meta_b": {
    "name": "src/quick/scenegraph/qsgwindowsrenderloop.cpp",
    "content_type": "text/x-c++src",
    "lines": 489,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003drefs%2Fchanges%2F73%2F79973%2F4;f\u003dsrc%2Fquick%2Fscenegraph%2Fqsgwindowsrenderloop.cpp"
      }
    ]
  },
  "change_type": "MODIFIED",
  "diff_header": [
    "diff --git a/src/quick/scenegraph/qsgwindowsrenderloop.cpp b/src/quick/scenegraph/qsgwindowsrenderloop.cpp",
    "index 31012c7..913b737 100644",
    "--- a/src/quick/scenegraph/qsgwindowsrenderloop.cpp",
    "+++ b/src/quick/scenegraph/qsgwindowsrenderloop.cpp"
  ],
  "content": [
    {
      "ab": [
        "/****************************************************************************",
        "**",
        "** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).",
        "** Contact: http://www.qt-project.org/legal",
        "**",
        "** This file is part of the QtQuick module of the Qt Toolkit.",
        "**",
        "** $QT_BEGIN_LICENSE:LGPL$",
        "** Commercial License Usage",
        "** Licensees holding valid commercial Qt licenses may use this file in",
        "** accordance with the commercial license agreement provided with the",
        "** Software or, alternatively, in accordance with the terms contained in",
        "** a written agreement between you and Digia.  For licensing terms and",
        "** conditions see http://qt.digia.com/licensing.  For further information",
        "** use the contact form at http://qt.digia.com/contact-us.",
        "**",
        "** GNU Lesser General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU Lesser",
        "** General Public License version 2.1 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.LGPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU Lesser General Public License version 2.1 requirements",
        "** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.",
        "**",
        "** In addition, as a special exception, Digia gives you certain additional",
        "** rights.  These rights are described in the Digia Qt LGPL Exception",
        "** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.",
        "**",
        "** GNU General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU",
        "** General Public License version 3.0 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.GPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU General Public License version 3.0 requirements will be",
        "** met: http://www.gnu.org/copyleft/gpl.html.",
        "**",
        "**",
        "** $QT_END_LICENSE$",
        "**",
        "****************************************************************************/",
        "",
        "#include \"qsgwindowsrenderloop_p.h\"",
        "",
        "#include \u003cQtCore/QCoreApplication\u003e",
        "#include \u003cQtCore/QLibraryInfo\u003e",
        "",
        "#include \u003cQtGui/QScreen\u003e",
        "#include \u003cQtGui/QGuiApplication\u003e",
        "",
        "#include \u003cQtQuick/private/qsgcontext_p.h\u003e",
        "#include \u003cQtQuick/private/qquickwindow_p.h\u003e",
        "",
        "#include \u003cQtQuick/QQuickWindow\u003e",
        "",
        "#include \u003cprivate/qquickprofiler_p.h\u003e",
        "",
        "QT_BEGIN_NAMESPACE",
        "",
        "extern Q_GUI_EXPORT QImage qt_gl_read_framebuffer(const QSize \u0026size, bool alpha_format, bool include_alpha);",
        "",
        "// #define QSG_RENDER_LOOP_DEBUG",
        "",
        "#ifdef QSG_RENDER_LOOP_DEBUG",
        "static QElapsedTimer qsg_debug_timer;",
        "#  define RLDEBUG(x) qDebug(\"(%6d) %s : %4d - %s\", (int) qsg_debug_timer.elapsed(), __FILE__, __LINE__, x)",
        "#else",
        "#  define RLDEBUG(x)",
        "#endif",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "static bool qsg_render_timing \u003d !qgetenv(\"QSG_RENDER_TIMING\").isEmpty();",
        "static QElapsedTimer qsg_render_timer;",
        "#define QSG_RENDER_TIMING_SAMPLE(sampleName) qint64 sampleName \u003d 0; if (qsg_render_timing || QQuickProfiler::enabled) sampleName \u003d qsg_render_timer.nsecsElapsed()",
        "#else",
        "#define QSG_RENDER_TIMING_SAMPLE(sampleName)",
        "#endif",
        "",
        "",
        "QSGWindowsRenderLoop::QSGWindowsRenderLoop()",
        "    : m_gl(0)",
        "    , m_sg(QSGContext::createDefaultContext())",
        "    , m_updateTimer(0)",
        "    , m_animationTimer(0)",
        "{",
        "#ifdef QSG_RENDER_LOOP_DEBUG",
        "    qsg_debug_timer.start();",
        "#endif",
        "",
        "    m_rc \u003d m_sg-\u003ecreateRenderContext();",
        "",
        "    m_animationDriver \u003d m_sg-\u003ecreateAnimationDriver(m_sg);",
        "    m_animationDriver-\u003einstall();",
        "",
        "    connect(m_animationDriver, SIGNAL(started()), this, SLOT(started()));",
        "    connect(m_animationDriver, SIGNAL(stopped()), this, SLOT(stopped()));",
        "",
        "    m_vsyncDelta \u003d 1000 / QGuiApplication::primaryScreen()-\u003erefreshRate();",
        "    if (m_vsyncDelta \u003c\u003d 0)",
        "        m_vsyncDelta \u003d 16;",
        "",
        "    RLDEBUG(\"Windows Render Loop created\");",
        "",
        "#ifndef QSG_NO_RENDER_TIMIMG",
        "    qsg_render_timer.start();",
        "#endif",
        "}",
        "",
        "QSGWindowsRenderLoop::~QSGWindowsRenderLoop()",
        "{",
        "    delete m_rc;",
        "    delete m_sg;",
        "}",
        "",
        "bool QSGWindowsRenderLoop::interleaveIncubation() const",
        "{",
        "    return m_animationDriver-\u003eisRunning() \u0026\u0026 anyoneShowing();",
        "}",
        "",
        "QSGWindowsRenderLoop::WindowData *QSGWindowsRenderLoop::windowData(QQuickWindow *window)",
        "{",
        "    for (int i\u003d0; i\u003cm_windows.size(); ++i) {",
        "        WindowData \u0026wd \u003d m_windows[i];",
        "        if (wd.window \u003d\u003d window)",
        "            return \u0026wd;",
        "    }",
        "    return 0;",
        "}",
        "",
        "void QSGWindowsRenderLoop::maybePostUpdateTimer()",
        "{",
        "    if (!m_updateTimer) {",
        "        RLDEBUG(\" - posting event\");",
        "        m_updateTimer \u003d startTimer(m_vsyncDelta / 3);",
        "    }",
        "}",
        "",
        "/*",
        " * If no windows are showing, start ticking animations using a timer,",
        " * otherwise, start rendering",
        " */",
        "void QSGWindowsRenderLoop::started()",
        "{",
        "    RLDEBUG(\"Animations started...\");",
        "    if (!anyoneShowing()) {",
        "        if (m_animationTimer \u003d\u003d 0) {",
        "            RLDEBUG(\" - starting non-visual animation timer\");",
        "            m_animationTimer \u003d startTimer(m_vsyncDelta);",
        "        }",
        "    } else {",
        "        maybePostUpdateTimer();",
        "    }",
        "}",
        "",
        "void QSGWindowsRenderLoop::stopped()",
        "{",
        "    RLDEBUG(\"Animations stopped...\");",
        "    if (m_animationTimer) {",
        "        RLDEBUG(\" - stopping non-visual animation timer\");",
        "        killTimer(m_animationTimer);",
        "        m_animationTimer \u003d 0;",
        "    }",
        "}",
        "",
        "void QSGWindowsRenderLoop::show(QQuickWindow *window)",
        "{",
        "    RLDEBUG(\"show\");",
        "    if (windowData(window) !\u003d 0)",
        "        return;",
        "",
        "    // This happens before the platform window is shown, but after",
        "    // it is created. Creating the GL context takes a lot of time",
        "    // (hundreds of milliseconds) and will prevent us from rendering",
        "    // the first frame in time for the initial show on screen.",
        "    // By preparing the GL context here, it is feasible (if the app",
        "    // is quick enough) to have a perfect first frame.",
        "    if (!m_gl) {",
        "        QSG_RENDER_TIMING_SAMPLE(time_start);",
        "",
        "        RLDEBUG(\" - creating GL context\");",
        "        m_gl \u003d new QOpenGLContext();",
        "        m_gl-\u003esetFormat(window-\u003erequestedFormat());",
        "        if (QSGContext::sharedOpenGLContext())",
        "            m_gl-\u003esetShareContext(QSGContext::sharedOpenGLContext());",
        "        bool created \u003d m_gl-\u003ecreate();",
        "        if (!created) {"
      ]
    },
    {
      "a": [
        "            const bool isDebug \u003d QLibraryInfo::isDebugBuild();",
        "            QString eglLibName \u003d QLatin1String(isDebug ? \"libEGLd.dll\" : \"libEGL.dll\");",
        "            QString glesLibName \u003d QLatin1String(isDebug ? \"libGLESv2d.dll\" : \"libGLESv2.dll\");",
        "            QString contextType \u003d QLatin1String(\"OpenGL\");",
        "            const char *msg \u003d QT_TRANSLATE_NOOP(",
        "                \"QSGWindowsRenderLoop\",",
        "                \"Failed to create %1 context. \"",
        "                \"This is most likely caused by not having the necessary graphics drivers installed.\\n\\n\"",
        "                \"Install a driver providing OpenGL 2.0 or higher, or, if this is not possible, \"",
        "                \"make sure the Angle Open GL ES 2.0 emulation libraries (%2, %3 and d3dcompiler_*.dll) \"",
        "                \"are available in the application executable\u0027s directory or in a location listed in PATH.\");",
        "            QString translatedMsg \u003d tr(msg).arg(contextType).arg(eglLibName).arg(glesLibName);",
        "            QString nonTranslatedMsg \u003d QString(QLatin1String(msg)).arg(contextType).arg(eglLibName).arg(glesLibName);",
        "            // If there is a slot connected to the error signal, emit it and leave it to",
        "            // the application to do something with the message. If nothing is connected,",
        "            // show a message on our own and terminate.",
        "            bool signalEmitted \u003d QQuickWindowPrivate::get(window)-\u003eemitError(QQuickWindow::ContextNotAvailable,",
        "                                                                             translatedMsg);",
        "#if defined(Q_OS_WIN) \u0026\u0026 !defined(Q_OS_WINCE) \u0026\u0026 !defined(Q_OS_WINRT)",
        "            if (!signalEmitted \u0026\u0026 !isDebug \u0026\u0026 !GetConsoleWindow()) {",
        "                MessageBox(0, (LPCTSTR) translatedMsg.utf16(),",
        "                           (LPCTSTR)(QCoreApplication::applicationName().utf16()),",
        "                           MB_OK | MB_ICONERROR);",
        "            }",
        "#endif // !Q_OS_WINCE \u0026\u0026 !Q_OS_WINRT"
      ],
      "b": [
        "            const bool isEs \u003d m_gl-\u003eisES();"
      ]
    },
    {
      "ab": [
        "            delete m_gl;",
        "            m_gl \u003d 0;"
      ]
    },
    {
      "a": [
        "            if (!signalEmitted)",
        "                qFatal(\"%s\", qPrintable(nonTranslatedMsg));"
      ],
      "b": [
        "            handleContextCreationFailure(window, isEs);"
      ]
    },
    {
      "ab": [
        "            return;",
        "        }",
        "",
        "        QQuickWindowPrivate::get(window)-\u003efireOpenGLContextCreated(m_gl);",
        "",
        "        QSG_RENDER_TIMING_SAMPLE(time_created);",
        "        RLDEBUG(\" - making current\");",
        "        bool current \u003d m_gl-\u003emakeCurrent(window);",
        "        RLDEBUG(\" - initializing SG\");",
        "        QSG_RENDER_TIMING_SAMPLE(time_current);",
        "        if (current)",
        "            m_rc-\u003einitialize(m_gl);",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "        if (qsg_render_timing) {",
        "            qDebug(\"WindowsRenderLoop: GL\u003d%d ms, makeCurrent\u003d%d ms, SG\u003d%d ms\",",
        "                   int((time_created - time_start)/1000000),",
        "                   int((time_current - time_created)/1000000),",
        "                   int((qsg_render_timer.nsecsElapsed() - time_current)/1000000));",
        "        }",
        "        Q_QUICK_SG_PROFILE1(QQuickProfiler::SceneGraphWindowsRenderShow, (",
        "                time_created - time_start,",
        "                time_current - time_created,",
        "                qsg_render_timer.nsecsElapsed() - time_current));",
        "#endif",
        "",
        "    }",
        "",
        "    WindowData data;",
        "    data.window \u003d window;",
        "    data.pendingUpdate \u003d false;",
        "    m_windows \u003c\u003c data;",
        "",
        "    RLDEBUG(\" - done with show\");",
        "}",
        "",
        "void QSGWindowsRenderLoop::hide(QQuickWindow *window)",
        "{",
        "    RLDEBUG(\"hide\");",
        "",
        "    for (int i\u003d0; i\u003cm_windows.size(); ++i) {",
        "        if (m_windows.at(i).window \u003d\u003d window) {",
        "            m_windows.removeAt(i);",
        "            break;",
        "        }",
        "    }",
        "",
        "    // The expose event is queued while hide is sent synchronously, so",
        "    // the value might not be updated yet. (plus that the windows plugin",
        "    // sends exposed\u003dtrue when it goes to hidden, so it is doubly broken)",
        "    // The check is made here, after the removal from m_windows, so",
        "    // anyoneShowing will report the right value.",
        "    if (window-\u003eisExposed())",
        "        handleObscurity();",
        "",
        "    if (!m_gl)",
        "        return;",
        "",
        "    QQuickWindowPrivate *cd \u003d QQuickWindowPrivate::get(window);",
        "    m_gl-\u003emakeCurrent(window);",
        "    cd-\u003efireAboutToStop();",
        "    cd-\u003ecleanupNodesOnShutdown();",
        "",
        "    // If this is the last tracked window, check for persistent SG and GL and",
        "    // potentially clean up.",
        "    if (m_windows.size() \u003d\u003d 0) {",
        "        if (!cd-\u003epersistentSceneGraph) {",
        "            QQuickWindowPrivate::get(window)-\u003econtext-\u003einvalidate();",
        "            QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);",
        "            if (!cd-\u003epersistentGLContext) {",
        "                delete m_gl;",
        "                m_gl \u003d 0;",
        "            }",
        "        }",
        "    }",
        "}",
        "",
        "void QSGWindowsRenderLoop::windowDestroyed(QQuickWindow *window)",
        "{",
        "    RLDEBUG(\"windowDestroyed\");",
        "    hide(window);",
        "",
        "    // If this is the last tracked window, clean up SG and GL.",
        "    if (m_windows.size() \u003d\u003d 0) {",
        "        QQuickWindowPrivate::get(window)-\u003econtext-\u003einvalidate();",
        "        QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);",
        "        delete m_gl;",
        "        m_gl \u003d 0;",
        "    }",
        "}",
        "",
        "bool QSGWindowsRenderLoop::anyoneShowing() const",
        "{",
        "    foreach (const WindowData \u0026wd, m_windows)",
        "        if (wd.window-\u003eisExposed() \u0026\u0026 wd.window-\u003esize().isValid())",
        "            return true;",
        "    return false;",
        "}",
        "",
        "void QSGWindowsRenderLoop::exposureChanged(QQuickWindow *window)",
        "{",
        "",
        "    if (windowData(window) \u003d\u003d 0)",
        "        return;",
        "",
        "    if (window-\u003eisExposed()) {",
        "",
        "        // Stop non-visual animation timer as we now have a window rendering",
        "        if (m_animationTimer \u0026\u0026 anyoneShowing()) {",
        "            RLDEBUG(\" - stopping non-visual animation timer\");",
        "            killTimer(m_animationTimer);",
        "            m_animationTimer \u003d 0;",
        "        }",
        "",
        "        RLDEBUG(\"exposureChanged - exposed\");",
        "        WindowData *wd \u003d windowData(window);",
        "        wd-\u003ependingUpdate \u003d true;",
        "",
        "        // If we have a pending timer and we get an expose, we need to stop it.",
        "        // Otherwise we get two frames and two animation ticks in the same time-interval.",
        "        if (m_updateTimer) {",
        "            RLDEBUG(\" - killing pending update timer\");",
        "            killTimer(m_updateTimer);",
        "            m_updateTimer \u003d 0;",
        "        }",
        "        render();",
        "    } else {",
        "        handleObscurity();",
        "    }",
        "}",
        "",
        "void QSGWindowsRenderLoop::handleObscurity()",
        "{",
        "    RLDEBUG(\"handleObscurity\");",
        "    // Potentially start the non-visual animation timer if nobody is rendering",
        "    if (m_animationDriver-\u003eisRunning() \u0026\u0026 !anyoneShowing() \u0026\u0026 !m_animationTimer) {",
        "        RLDEBUG(\" - starting non-visual animation timer\");",
        "        m_animationTimer \u003d startTimer(m_vsyncDelta);",
        "    }",
        "}",
        "",
        "QImage QSGWindowsRenderLoop::grab(QQuickWindow *window)",
        "{",
        "    RLDEBUG(\"grab\");",
        "    if (!m_gl)",
        "        return QImage();",
        "",
        "    m_gl-\u003emakeCurrent(window);",
        "",
        "    QQuickWindowPrivate *d \u003d QQuickWindowPrivate::get(window);",
        "    d-\u003epolishItems();",
        "    d-\u003esyncSceneGraph();",
        "    d-\u003erenderSceneGraph(window-\u003esize());",
        "",
        "    QImage image \u003d qt_gl_read_framebuffer(window-\u003esize(), false, false);",
        "    return image;",
        "}",
        "",
        "void QSGWindowsRenderLoop::update(QQuickWindow *window)",
        "{",
        "    RLDEBUG(\"update\");",
        "    maybeUpdate(window);",
        "}",
        "",
        "void QSGWindowsRenderLoop::maybeUpdate(QQuickWindow *window)",
        "{",
        "    RLDEBUG(\"maybeUpdate\");",
        "",
        "    WindowData *wd \u003d windowData(window);",
        "    if (!wd || !anyoneShowing())",
        "        return;",
        "",
        "    wd-\u003ependingUpdate \u003d true;",
        "    maybePostUpdateTimer();",
        "}",
        "",
        "bool QSGWindowsRenderLoop::event(QEvent *event)",
        "{",
        "    switch (event-\u003etype()) {",
        "    case QEvent::Timer: {",
        "        QTimerEvent *te \u003d static_cast\u003cQTimerEvent *\u003e(event);",
        "        if (te-\u003etimerId() \u003d\u003d m_animationTimer) {",
        "            RLDEBUG(\"event : animation tick while nothing is showing\");",
        "            m_animationDriver-\u003eadvance();",
        "        } else if (te-\u003etimerId() \u003d\u003d m_updateTimer) {",
        "            RLDEBUG(\"event : update\");",
        "            killTimer(m_updateTimer);",
        "            m_updateTimer \u003d 0;",
        "            render();",
        "        }",
        "        return true; }",
        "    default:",
        "        break;",
        "    }",
        "",
        "    return QObject::event(event);",
        "}",
        "",
        "/*",
        " * Go through all windows we control and render them in turn.",
        " * Then tick animations if active.",
        " */",
        "void QSGWindowsRenderLoop::render()",
        "{",
        "    RLDEBUG(\"render\");",
        "    foreach (const WindowData \u0026wd, m_windows) {",
        "        if (wd.pendingUpdate) {",
        "            const_cast\u003cWindowData \u0026\u003e(wd).pendingUpdate \u003d false;",
        "            renderWindow(wd.window);",
        "        }",
        "    }",
        "",
        "    if (m_animationDriver-\u003eisRunning()) {",
        "        RLDEBUG(\"advancing animations\");",
        "        QSG_RENDER_TIMING_SAMPLE(time_start);",
        "        m_animationDriver-\u003eadvance();",
        "        RLDEBUG(\"animations advanced\");",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "        if (qsg_render_timing) {",
        "            qDebug(\"WindowsRenderLoop: animations\u003d%d ms\",",
        "                   int((qsg_render_timer.nsecsElapsed() - time_start)/1000000));",
        "        }",
        "        Q_QUICK_SG_PROFILE1(QQuickProfiler::SceneGraphWindowsAnimations, (",
        "                qsg_render_timer.nsecsElapsed() - time_start));",
        "#endif",
        "",
        "        // It is not given that animations triggered another maybeUpdate()",
        "        // and thus another render pass, so to keep things running,",
        "        // make sure there is another frame pending.",
        "        maybePostUpdateTimer();",
        "",
        "        emit timeToIncubate();",
        "    }",
        "}",
        "",
        "/*",
        " * Render the contents of this window. First polish, then sync, render",
        " * then finally swap.",
        " *",
        " * Note: This render function does not implement aborting",
        " * the render call when sync step results in no scene graph changes,",
        " * like the threaded renderer does.",
        " */",
        "void QSGWindowsRenderLoop::renderWindow(QQuickWindow *window)",
        "{",
        "    RLDEBUG(\"renderWindow\");",
        "    QQuickWindowPrivate *d \u003d QQuickWindowPrivate::get(window);",
        "",
        "    if (!d-\u003eisRenderable())",
        "        return;",
        "",
        "    if (!m_gl-\u003emakeCurrent(window))",
        "        return;",
        "",
        "    QSG_RENDER_TIMING_SAMPLE(time_start);",
        "",
        "    RLDEBUG(\" - polishing\");",
        "    d-\u003epolishItems();",
        "    QSG_RENDER_TIMING_SAMPLE(time_polished);",
        "",
        "    emit window-\u003eafterAnimating();",
        "",
        "    RLDEBUG(\" - syncing\");",
        "    d-\u003esyncSceneGraph();",
        "    QSG_RENDER_TIMING_SAMPLE(time_synced);",
        "",
        "    RLDEBUG(\" - rendering\");",
        "    d-\u003erenderSceneGraph(window-\u003esize());",
        "    QSG_RENDER_TIMING_SAMPLE(time_rendered);",
        "",
        "    RLDEBUG(\" - swapping\");",
        "    m_gl-\u003eswapBuffers(window);",
        "    QSG_RENDER_TIMING_SAMPLE(time_swapped);",
        "",
        "    RLDEBUG(\" - frameDone\");",
        "    d-\u003efireFrameSwapped();",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "        if (qsg_render_timing) {",
        "            qDebug(\"WindowsRenderLoop(t\u003d%d): window\u003d%p, polish\u003d%d ms, sync\u003d%d ms, render\u003d%d ms, swap\u003d%d ms\",",
        "                   int(qsg_render_timer.elapsed()),",
        "                   window,",
        "                   int((time_polished - time_start)/1000000),",
        "                   int((time_synced - time_polished)/1000000),",
        "                   int((time_rendered - time_synced)/1000000),",
        "                   int((time_swapped - time_rendered)/1000000));",
        "        }",
        "",
        "        Q_QUICK_SG_PROFILE2(QQuickProfiler::SceneGraphWindowsPolishFrame,",
        "                            QQuickProfiler::SceneGraphRenderLoopFrame, (",
        "                time_synced - time_polished,",
        "                time_rendered - time_synced,",
        "                time_swapped - time_rendered,",
        "                time_polished - time_start));",
        "#endif",
        "}",
        "",
        "QT_END_NAMESPACE",
        ""
      ]
    }
  ]
}
