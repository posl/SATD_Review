{
  "meta_a": {
    "name": "src/quick/scenegraph/qsgthreadedrenderloop.cpp",
    "content_type": "text/x-c++src",
    "lines": 1290,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003d0c5620c43350804a5df03825ae7a849c783fbfeb;f\u003dsrc%2Fquick%2Fscenegraph%2Fqsgthreadedrenderloop.cpp"
      }
    ]
  },
  "meta_b": {
    "name": "src/quick/scenegraph/qsgthreadedrenderloop.cpp",
    "content_type": "text/x-c++src",
    "lines": 1281,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003drefs%2Fchanges%2F73%2F79973%2F8;f\u003dsrc%2Fquick%2Fscenegraph%2Fqsgthreadedrenderloop.cpp"
      }
    ]
  },
  "change_type": "MODIFIED",
  "diff_header": [
    "diff --git a/src/quick/scenegraph/qsgthreadedrenderloop.cpp b/src/quick/scenegraph/qsgthreadedrenderloop.cpp",
    "index a420ce0..dfeb6f0 100644",
    "--- a/src/quick/scenegraph/qsgthreadedrenderloop.cpp",
    "+++ b/src/quick/scenegraph/qsgthreadedrenderloop.cpp"
  ],
  "content": [
    {
      "ab": [
        "/****************************************************************************",
        "**",
        "** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).",
        "** Contact: http://www.qt-project.org/legal",
        "**",
        "** This file is part of the QtQuick module of the Qt Toolkit.",
        "**",
        "** $QT_BEGIN_LICENSE:LGPL$",
        "** Commercial License Usage",
        "** Licensees holding valid commercial Qt licenses may use this file in",
        "** accordance with the commercial license agreement provided with the",
        "** Software or, alternatively, in accordance with the terms contained in",
        "** a written agreement between you and Digia.  For licensing terms and",
        "** conditions see http://qt.digia.com/licensing.  For further information",
        "** use the contact form at http://qt.digia.com/contact-us.",
        "**",
        "** GNU Lesser General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU Lesser",
        "** General Public License version 2.1 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.LGPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU Lesser General Public License version 2.1 requirements",
        "** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.",
        "**",
        "** In addition, as a special exception, Digia gives you certain additional",
        "** rights.  These rights are described in the Digia Qt LGPL Exception",
        "** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.",
        "**",
        "** GNU General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU",
        "** General Public License version 3.0 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.GPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU General Public License version 3.0 requirements will be",
        "** met: http://www.gnu.org/copyleft/gpl.html.",
        "**",
        "**",
        "** $QT_END_LICENSE$",
        "**",
        "****************************************************************************/",
        "",
        "",
        "#include \u003cQtCore/QMutex\u003e",
        "#include \u003cQtCore/QWaitCondition\u003e",
        "#include \u003cQtCore/QAnimationDriver\u003e",
        "#include \u003cQtCore/QQueue\u003e",
        "#include \u003cQtCore/QTime\u003e",
        "",
        "#include \u003cQtGui/QGuiApplication\u003e",
        "#include \u003cQtGui/QScreen\u003e",
        "#include \u003cQtGui/QOffscreenSurface\u003e",
        "",
        "#include \u003cQtQuick/QQuickWindow\u003e",
        "#include \u003cprivate/qquickwindow_p.h\u003e",
        "",
        "#include \u003cQtQuick/private/qsgrenderer_p.h\u003e",
        "",
        "#include \"qsgthreadedrenderloop_p.h\"",
        "#include \u003cprivate/qquickanimatorcontroller_p.h\u003e",
        "",
        "#include \u003cprivate/qquickprofiler_p.h\u003e",
        "",
        "/*",
        "   Overall design:",
        "",
        "   There are two classes here. QSGThreadedRenderLoop and",
        "   QSGRenderThread. All communication between the two is based on",
        "   event passing and we have a number of custom events.",
        "",
        "   In this implementation, the render thread is never blocked and the",
        "   GUI thread will initiate a polishAndSync which will block and wait",
        "   for the render thread to pick it up and release the block only",
        "   after the render thread is done syncing. The reason for this",
        "   is:",
        "",
        "   1. Clear blocking paradigm. We only have one real \"block\" point",
        "   (polishAndSync()) and all blocking is initiated by GUI and picked",
        "   up by Render at specific times based on events. This makes the",
        "   execution deterministic.",
        "",
        "   2. Render does not have to interact with GUI. This is done so that",
        "   the render thread can run its own animation system which stays",
        "   alive even when the GUI thread is blocked doing i/o, object",
        "   instantiation, QPainter-painting or any other non-trivial task.",
        "",
        "   ---",
        "",
        "   There is one thread per window and one opengl context per thread.",
        "",
        "   ---",
        "",
        "   The render thread has affinity to the GUI thread until a window",
        "   is shown. From that moment and until the window is destroyed, it",
        "   will have affinity to the render thread. (moved back at the end",
        "   of run for cleanup).",
        "",
        "   ---",
        "",
        "   The render loop is active while any window is exposed. All visible",
        "   windows are tracked, but only exposed windows are actually added to",
        "   the render thread and rendered. That means that if all windows are",
        "   obscured, we might end up cleaning up the SG and GL context (if all",
        "   windows have disabled persistency). Especially for multiprocess,",
        "   low-end systems, this should be quite important.",
        "",
        " */",
        "",
        "QT_BEGIN_NAMESPACE",
        "",
        "",
        "// #define QSG_RENDER_LOOP_DEBUG",
        "",
        "#if defined (QSG_RENDER_LOOP_DEBUG)",
        "QElapsedTimer qsgrl_timer;",
        "#  define QSG_RT_DEBUG(MSG)       qDebug(\"(%6d) line\u003d%4d - win\u003d%10p):                       Render: %s\", (int) qsgrl_timer.elapsed(), __LINE__, window, MSG);",
        "#  define QSG_GUI_DEBUG(WIN, MSG) qDebug(\"(%6d) line\u003d%4d - win\u003d%10p): Gui: %s\", (int) qsgrl_timer.elapsed(), __LINE__, WIN, MSG);",
        "#else",
        "#  define QSG_RT_DEBUG(MSG)",
        "#  define QSG_GUI_DEBUG(WIN,MSG)",
        "#endif",
        "",
        "",
        "static int get_env_int(const char *name, int defaultValue)",
        "{",
        "    QByteArray content \u003d qgetenv(name);",
        "",
        "    bool ok \u003d false;",
        "    int value \u003d content.toInt(\u0026ok);",
        "    return ok ? value : defaultValue;",
        "}",
        "",
        "",
        "static inline int qsgrl_animation_interval() {",
        "    qreal refreshRate \u003d QGuiApplication::primaryScreen()-\u003erefreshRate();",
        "    // To work around that some platforms wrongfully return 0 or something",
        "    // bogus for refreshrate",
        "    if (refreshRate \u003c 1)",
        "        return 16;",
        "    return int(1000 / refreshRate);",
        "}",
        "",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "static bool qsg_render_timing \u003d !qgetenv(\"QSG_RENDER_TIMING\").isEmpty();",
        "static QElapsedTimer threadTimer;",
        "static qint64 syncTime;",
        "static qint64 renderTime;",
        "static qint64 sinceLastTime;",
        "#endif",
        "",
        "extern Q_GUI_EXPORT QImage qt_gl_read_framebuffer(const QSize \u0026size, bool alpha_format, bool include_alpha);",
        "",
        "// RL: Render Loop",
        "// RT: Render Thread",
        "",
        "// Passed from the RL to the RT when a window is rendeirng on screen",
        "// and should be added to the render loop.",
        "const QEvent::Type WM_Expose            \u003d QEvent::Type(QEvent::User + 1);",
        "",
        "// Passed from the RL to the RT when a window is removed obscured and",
        "// should be removed from the render loop.",
        "const QEvent::Type WM_Obscure           \u003d QEvent::Type(QEvent::User + 2);",
        "",
        "// Passed from the RL to itself to initiate a polishAndSync() call.",
        "//const QEvent::Type WM_LockAndSync       \u003d QEvent::Type(QEvent::User + 3); // not used for now",
        "",
        "// Passed from the RL to RT when GUI has been locked, waiting for sync",
        "// (updatePaintNode())",
        "const QEvent::Type WM_RequestSync       \u003d QEvent::Type(QEvent::User + 4);",
        "",
        "// Passed by the RT to itself to trigger another render pass. This is",
        "// typically a result of QQuickWindow::update().",
        "const QEvent::Type WM_RequestRepaint    \u003d QEvent::Type(QEvent::User + 5);",
        "",
        "// Passed by the RL to the RT to free up maybe release SG and GL contexts",
        "// if no windows are rendering.",
        "const QEvent::Type WM_TryRelease        \u003d QEvent::Type(QEvent::User + 7);",
        "",
        "// Passed by the RL to the RT when a QQuickWindow::grabWindow() is",
        "// called.",
        "const QEvent::Type WM_Grab              \u003d QEvent::Type(QEvent::User + 9);",
        "",
        "// Passed by RL to RT when polish fails and we need to reset the expose sycle.",
        "const QEvent::Type WM_ResetExposeCycle \u003d QEvent::Type(QEvent::User + 10);",
        "",
        "template \u003ctypename T\u003e T *windowFor(const QList\u003cT\u003e list, QQuickWindow *window)",
        "{",
        "    for (int i\u003d0; i\u003clist.size(); ++i) {",
        "        const T \u0026t \u003d list.at(i);",
        "        if (t.window \u003d\u003d window)",
        "            return const_cast\u003cT *\u003e(\u0026t);",
        "    }",
        "    return 0;",
        "}",
        "",
        "",
        "class WMWindowEvent : public QEvent",
        "{",
        "public:",
        "    WMWindowEvent(QQuickWindow *c, QEvent::Type type) : QEvent(type), window(c) { }",
        "    QQuickWindow *window;",
        "};",
        "",
        "class WMTryReleaseEvent : public WMWindowEvent",
        "{",
        "public:",
        "    WMTryReleaseEvent(QQuickWindow *win, bool destroy, QOffscreenSurface *fallback)",
        "        : WMWindowEvent(win, WM_TryRelease)",
        "        , inDestructor(destroy)",
        "        , fallbackSurface(fallback)",
        "    {}",
        "",
        "    bool inDestructor;",
        "    QOffscreenSurface *fallbackSurface;",
        "};",
        "",
        "class WMExposeEvent : public WMWindowEvent",
        "{",
        "public:",
        "    WMExposeEvent(QQuickWindow *c) : WMWindowEvent(c, WM_Expose), size(c-\u003esize()) { }",
        "    QSize size;",
        "};",
        "",
        "",
        "class WMGrabEvent : public WMWindowEvent",
        "{",
        "public:",
        "    WMGrabEvent(QQuickWindow *c, QImage *result) : WMWindowEvent(c, WM_Grab), image(result) {}",
        "    QImage *image;",
        "};",
        "",
        "",
        "class QSGRenderThreadEventQueue : public QQueue\u003cQEvent *\u003e",
        "{",
        "public:",
        "    QSGRenderThreadEventQueue()",
        "        : waiting(false)",
        "    {",
        "    }",
        "",
        "    void addEvent(QEvent *e) {",
        "        mutex.lock();",
        "        enqueue(e);",
        "        if (waiting)",
        "            condition.wakeOne();",
        "        mutex.unlock();",
        "    }",
        "",
        "    QEvent *takeEvent(bool wait) {",
        "        mutex.lock();",
        "        if (size() \u003d\u003d 0 \u0026\u0026 wait) {",
        "            waiting \u003d true;",
        "            condition.wait(\u0026mutex);",
        "            waiting \u003d false;",
        "        }",
        "        QEvent *e \u003d dequeue();",
        "        mutex.unlock();",
        "        return e;",
        "    }",
        "",
        "    bool hasMoreEvents() {",
        "        mutex.lock();",
        "        bool has \u003d !isEmpty();",
        "        mutex.unlock();",
        "        return has;",
        "    }",
        "",
        "private:",
        "    QMutex mutex;",
        "    QWaitCondition condition;",
        "    bool waiting;",
        "};",
        "",
        "",
        "class QSGRenderThread : public QThread",
        "{",
        "    Q_OBJECT",
        "public:",
        "    QSGRenderThread(QSGThreadedRenderLoop *w, QSGRenderContext *renderContext)",
        "        : wm(w)",
        "        , gl(0)",
        "        , sgrc(renderContext)",
        "        , animatorDriver(0)",
        "        , pendingUpdate(0)",
        "        , sleeping(false)",
        "        , syncResultedInChanges(false)",
        "        , exposeCycle(NoExpose)",
        "        , active(false)",
        "        , window(0)",
        "        , stopEventProcessing(false)",
        "    {",
        "        vsyncDelta \u003d qsgrl_animation_interval();",
        "    }",
        "",
        "    ~QSGRenderThread()",
        "    {",
        "        delete sgrc;",
        "    }",
        "",
        "    void invalidateOpenGL(QQuickWindow *window, bool inDestructor, QOffscreenSurface *backupSurface);",
        "    void initializeOpenGL();",
        "",
        "    bool event(QEvent *);",
        "    void run();",
        "",
        "    void syncAndRender();",
        "    void sync();",
        "",
        "    void requestRepaint()",
        "    {",
        "        if (sleeping)",
        "            stopEventProcessing \u003d true;",
        "        if (window)",
        "            pendingUpdate |\u003d RepaintRequest;",
        "    }",
        "",
        "    void processEventsAndWaitForMore();",
        "    void processEvents();",
        "    void postEvent(QEvent *e);",
        "",
        "public slots:",
        "    void sceneGraphChanged() {",
        "        QSG_RT_DEBUG(\"sceneGraphChanged()\");",
        "        syncResultedInChanges \u003d true;",
        "    }",
        "",
        "public:",
        "    enum UpdateRequest {",
        "        SyncRequest         \u003d 0x01,",
        "        RepaintRequest      \u003d 0x02",
        "    };",
        "",
        "    enum ExposeCycle {",
        "        NoExpose,",
        "        ExposePendingSync,",
        "        ExposePendingSwap",
        "    };",
        "",
        "    QSGThreadedRenderLoop *wm;",
        "    QOpenGLContext *gl;",
        "    QSGRenderContext *sgrc;",
        "",
        "    QAnimationDriver *animatorDriver;",
        "",
        "    uint pendingUpdate;",
        "    bool sleeping;",
        "    bool syncResultedInChanges;",
        "    ExposeCycle exposeCycle;",
        "",
        "    volatile bool active;",
        "",
        "    float vsyncDelta;",
        "",
        "    QMutex mutex;",
        "    QWaitCondition waitCondition;",
        "",
        "    QElapsedTimer m_timer;",
        "",
        "    QQuickWindow *window; // Will be 0 when window is not exposed",
        "    QSize windowSize;",
        "",
        "    // Local event queue stuff...",
        "    bool stopEventProcessing;",
        "    QSGRenderThreadEventQueue eventQueue;",
        "};",
        "",
        "bool QSGRenderThread::event(QEvent *e)",
        "{",
        "    switch ((int) e-\u003etype()) {",
        "",
        "    case WM_Expose: {",
        "        QSG_RT_DEBUG(\"WM_Expose\");",
        "        WMExposeEvent *se \u003d static_cast\u003cWMExposeEvent *\u003e(e);",
        "        Q_ASSERT(!window || window \u003d\u003d se-\u003ewindow);",
        "        windowSize \u003d se-\u003esize;",
        "        window \u003d se-\u003ewindow;",
        "        Q_ASSERT(exposeCycle \u003d\u003d NoExpose);",
        "        exposeCycle \u003d ExposePendingSync;",
        "        return true; }",
        "",
        "    case WM_ResetExposeCycle:",
        "        QSG_RT_DEBUG(\"WM_ResetExposeCycle\");",
        "        exposeCycle \u003d NoExpose;",
        "        return true;",
        "",
        "    case WM_Obscure: {",
        "        QSG_RT_DEBUG(\"WM_Obscure\");",
        "",
        "        Q_ASSERT(!window || window \u003d\u003d static_cast\u003cWMWindowEvent *\u003e(e)-\u003ewindow);",
        "",
        "        mutex.lock();",
        "        if (window) {",
        "            QQuickWindowPrivate::get(window)-\u003efireAboutToStop();",
        "            QSG_RT_DEBUG(\" - removed window...\");",
        "            window \u003d 0;",
        "        }",
        "        waitCondition.wakeOne();",
        "        mutex.unlock();",
        "",
        "        return true; }",
        "",
        "    case WM_RequestSync:",
        "        QSG_RT_DEBUG(\"WM_RequestSync\");",
        "        if (sleeping)",
        "            stopEventProcessing \u003d true;",
        "        if (window)",
        "            pendingUpdate |\u003d SyncRequest;",
        "        if (exposeCycle \u003d\u003d ExposePendingSync) {",
        "            pendingUpdate |\u003d RepaintRequest;",
        "            exposeCycle \u003d ExposePendingSwap;",
        "        }",
        "        return true;",
        "",
        "    case WM_TryRelease: {",
        "        QSG_RT_DEBUG(\"WM_TryRelease\");",
        "        mutex.lock();",
        "        wm-\u003em_locked \u003d true;",
        "        WMTryReleaseEvent *wme \u003d static_cast\u003cWMTryReleaseEvent *\u003e(e);",
        "        if (!window || wme-\u003einDestructor) {",
        "            QSG_RT_DEBUG(\" - setting exit flag and invalidating GL\");",
        "            invalidateOpenGL(wme-\u003ewindow, wme-\u003einDestructor, wme-\u003efallbackSurface);",
        "            active \u003d gl;",
        "            if (sleeping)",
        "                stopEventProcessing \u003d true;",
        "        } else {",
        "            QSG_RT_DEBUG(\" - not releasing anything because we have active windows...\");",
        "        }",
        "        waitCondition.wakeOne();",
        "        wm-\u003em_locked \u003d false;",
        "        mutex.unlock();",
        "        return true;",
        "    }",
        "",
        "    case WM_Grab: {",
        "        QSG_RT_DEBUG(\"WM_Grab\");",
        "        WMGrabEvent *ce \u003d static_cast\u003cWMGrabEvent *\u003e(e);",
        "        Q_ASSERT(ce-\u003ewindow \u003d\u003d window);",
        "        mutex.lock();",
        "        if (window) {",
        "            gl-\u003emakeCurrent(window);",
        "",
        "            QSG_RT_DEBUG(\" - syncing scene graph\");",
        "            QQuickWindowPrivate *d \u003d QQuickWindowPrivate::get(window);",
        "            d-\u003esyncSceneGraph();",
        "",
        "            QSG_RT_DEBUG(\" - rendering scene graph\");",
        "            QQuickWindowPrivate::get(window)-\u003erenderSceneGraph(windowSize);",
        "",
        "            QSG_RT_DEBUG(\" - grabbing result...\");",
        "            *ce-\u003eimage \u003d qt_gl_read_framebuffer(windowSize, false, false);",
        "        }",
        "        QSG_RT_DEBUG(\" - waking gui to handle grab result\");",
        "        waitCondition.wakeOne();",
        "        mutex.unlock();",
        "        return true;",
        "    }",
        "",
        "    case WM_RequestRepaint:",
        "        // When GUI posts this event, it is followed by a polishAndSync, so we mustn\u0027t",
        "        // exit the event loop yet.",
        "        pendingUpdate |\u003d RepaintRequest;",
        "        break;",
        "",
        "    default:",
        "        break;",
        "    }",
        "    return QThread::event(e);",
        "}",
        "",
        "void QSGRenderThread::invalidateOpenGL(QQuickWindow *window, bool inDestructor, QOffscreenSurface *fallback)",
        "{",
        "    QSG_RT_DEBUG(\"invalidateOpenGL()\");",
        "",
        "    if (!gl)",
        "        return;",
        "",
        "    if (!window) {",
        "        qWarning(\"QSGThreadedRenderLoop:QSGRenderThread: no window to make current...\");",
        "        return;",
        "    }",
        "",
        "",
        "    bool wipeSG \u003d inDestructor || !window-\u003eisPersistentSceneGraph();",
        "    bool wipeGL \u003d inDestructor || (wipeSG \u0026\u0026 !window-\u003eisPersistentOpenGLContext());",
        "",
        "    bool current \u003d gl-\u003emakeCurrent(fallback ? static_cast\u003cQSurface *\u003e(fallback) : static_cast\u003cQSurface *\u003e(window));",
        "    if (!current) {",
        "#ifndef QT_NO_DEBUG",
        "        qWarning() \u003c\u003c \"Scene Graph failed to acquire GL context during cleanup\";",
        "#endif",
        "        return;",
        "    }",
        "",
        "    // The canvas nodes must be cleaned up regardless if we are in the destructor..",
        "    if (wipeSG) {",
        "        QQuickWindowPrivate *dd \u003d QQuickWindowPrivate::get(window);",
        "        dd-\u003ecleanupNodesOnShutdown();",
        "    } else {",
        "        QSG_RT_DEBUG(\" - persistent SG, avoiding cleanup\");",
        "        gl-\u003edoneCurrent();",
        "        return;",
        "    }",
        "",
        "    sgrc-\u003einvalidate();",
        "    QCoreApplication::processEvents();",
        "    QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);",
        "    gl-\u003edoneCurrent();",
        "    QSG_RT_DEBUG(\" - invalidated scenegraph..\");",
        "",
        "    if (wipeGL) {",
        "        delete gl;",
        "        gl \u003d 0;",
        "        QSG_RT_DEBUG(\" - invalidated OpenGL\");",
        "    } else {",
        "        QSG_RT_DEBUG(\" - persistent GL, avoiding cleanup\");",
        "    }",
        "}",
        "",
        "/*!",
        "    Enters the mutex lock to make sure GUI is blocking and performs",
        "    sync, then wakes GUI.",
        " */",
        "void QSGRenderThread::sync()",
        "{",
        "    QSG_RT_DEBUG(\"sync()\");",
        "    mutex.lock();",
        "",
        "    Q_ASSERT_X(wm-\u003em_locked, \"QSGRenderThread::sync()\", \"sync triggered on bad terms as gui is not already locked...\");",
        "",
        "    bool current \u003d false;",
        "    if (windowSize.width() \u003e 0 \u0026\u0026 windowSize.height() \u003e 0)",
        "        current \u003d gl-\u003emakeCurrent(window);",
        "    if (current) {",
        "        QQuickWindowPrivate *d \u003d QQuickWindowPrivate::get(window);",
        "        bool hadRenderer \u003d d-\u003erenderer !\u003d 0;",
        "        d-\u003esyncSceneGraph();",
        "        if (!hadRenderer \u0026\u0026 d-\u003erenderer) {",
        "            QSG_RT_DEBUG(\" - renderer was created, hooking up changed signal\");",
        "            syncResultedInChanges \u003d true;",
        "            connect(d-\u003erenderer, SIGNAL(sceneGraphChanged()), this, SLOT(sceneGraphChanged()), Qt::DirectConnection);",
        "        }",
        "",
        "        // Process deferred deletes now, directly after the sync as",
        "        // deleteLater on the GUI must now also have resulted in SG changes",
        "        // and the delete is a safe operation.",
        "        QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);",
        "    } else {",
        "        QSG_RT_DEBUG(\" - window has bad size, waiting...\");",
        "    }",
        "",
        "    waitCondition.wakeOne();",
        "    mutex.unlock();",
        "}",
        "",
        "",
        "void QSGRenderThread::syncAndRender()",
        "{",
        "#ifndef QSG_NO_RENDER_TIMING",
        "    bool profileFrames \u003d qsg_render_timing || QQuickProfiler::enabled;",
        "    if (profileFrames) {",
        "        sinceLastTime \u003d threadTimer.nsecsElapsed();",
        "        threadTimer.start();",
        "    }",
        "#endif",
        "    QElapsedTimer waitTimer;",
        "    waitTimer.start();",
        "",
        "    QSG_RT_DEBUG(\"syncAndRender()\");",
        "",
        "    syncResultedInChanges \u003d false;",
        "",
        "    bool repaintRequested \u003d pendingUpdate \u0026 RepaintRequest;",
        "    bool syncRequested \u003d pendingUpdate \u0026 SyncRequest;",
        "    pendingUpdate \u003d 0;",
        "",
        "    if (syncRequested) {",
        "        QSG_RT_DEBUG(\" - update pending, doing sync\");",
        "        sync();",
        "    }",
        "",
        "    if (!syncResultedInChanges \u0026\u0026 !(repaintRequested)) {",
        "        QSG_RT_DEBUG(\" - no changes, rendering aborted\");",
        "        int waitTime \u003d vsyncDelta - (int) waitTimer.elapsed();",
        "        if (waitTime \u003e 0)",
        "            msleep(waitTime);",
        "        return;",
        "    }",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "    if (profileFrames)",
        "        syncTime \u003d threadTimer.nsecsElapsed();",
        "#endif",
        "    QSG_RT_DEBUG(\" - rendering starting\");",
        "",
        "    QQuickWindowPrivate *d \u003d QQuickWindowPrivate::get(window);",
        "",
        "    if (animatorDriver-\u003eisRunning()) {",
        "        d-\u003eanimationController-\u003elock();",
        "        animatorDriver-\u003eadvance();",
        "        d-\u003eanimationController-\u003eunlock();",
        "    }",
        "",
        "    bool current \u003d false;",
        "    if (d-\u003erenderer \u0026\u0026 windowSize.width() \u003e 0 \u0026\u0026 windowSize.height() \u003e 0)",
        "        current \u003d gl-\u003emakeCurrent(window);",
        "    if (current) {",
        "        d-\u003erenderSceneGraph(windowSize);",
        "#ifndef QSG_NO_RENDER_TIMING",
        "        if (profileFrames)",
        "            renderTime \u003d threadTimer.nsecsElapsed();",
        "#endif",
        "        gl-\u003eswapBuffers(window);",
        "        d-\u003efireFrameSwapped();",
        "    } else {",
        "        QSG_RT_DEBUG(\" - Window not yet ready, skipping render...\");",
        "    }",
        "",
        "    QSG_RT_DEBUG(\" - rendering done\");",
        "",
        "    // Though it would be more correct to put this block directly after",
        "    // fireFrameSwapped in the if (current) branch above, we don\u0027t do",
        "    // that to avoid blocking the GUI thread in the case where it",
        "    // has started rendering with a bad window, causing makeCurrent to",
        "    // fail or if the window has a bad size.",
        "    mutex.lock();",
        "    if (exposeCycle \u003d\u003d ExposePendingSwap) {",
        "        QSG_RT_DEBUG(\" - waking GUI after expose\");",
        "        exposeCycle \u003d NoExpose;",
        "        waitCondition.wakeOne();",
        "    }",
        "    mutex.unlock();",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "        if (qsg_render_timing)",
        "            qDebug(\"Render Thread: window\u003d%p, framedelta\u003d%d, sync\u003d%d, first render\u003d%d, after final swap\u003d%d\",",
        "                   window,",
        "                   int(sinceLastTime/1000000),",
        "                   int(syncTime/1000000),",
        "                   int((renderTime - syncTime)/1000000),",
        "                   int(threadTimer.elapsed() - renderTime/1000000));",
        "",
        "        Q_QUICK_SG_PROFILE1(QQuickProfiler::SceneGraphRenderLoopFrame, (",
        "                syncTime,",
        "                renderTime - syncTime,",
        "                threadTimer.nsecsElapsed() - renderTime));",
        "#endif",
        "}",
        "",
        "",
        "",
        "void QSGRenderThread::postEvent(QEvent *e)",
        "{",
        "    eventQueue.addEvent(e);",
        "}",
        "",
        "",
        "",
        "void QSGRenderThread::processEvents()",
        "{",
        "    QSG_RT_DEBUG(\"processEvents()\");",
        "    while (eventQueue.hasMoreEvents()) {",
        "        QEvent *e \u003d eventQueue.takeEvent(false);",
        "        event(e);",
        "        delete e;",
        "    }",
        "    QSG_RT_DEBUG(\" - done with processEvents()\");",
        "}",
        "",
        "void QSGRenderThread::processEventsAndWaitForMore()",
        "{",
        "    QSG_RT_DEBUG(\"processEventsAndWaitForMore()\");",
        "    stopEventProcessing \u003d false;",
        "    while (!stopEventProcessing) {",
        "        QEvent *e \u003d eventQueue.takeEvent(true);",
        "        event(e);",
        "        delete e;",
        "    }",
        "    QSG_RT_DEBUG(\" - done with processEventsAndWaitForMore()\");",
        "}",
        "",
        "void QSGRenderThread::run()",
        "{",
        "    QSG_RT_DEBUG(\"run()\");",
        "    animatorDriver \u003d sgrc-\u003esceneGraphContext()-\u003ecreateAnimationDriver(0);",
        "    animatorDriver-\u003einstall();",
        "    QUnifiedTimer::instance(true)-\u003esetConsistentTiming(QSGRenderLoop::useConsistentTiming());",
        "",
        "    while (active) {",
        "",
        "        if (window) {",
        "            if (!sgrc-\u003eopenglContext() \u0026\u0026 windowSize.width() \u003e 0 \u0026\u0026 windowSize.height() \u003e 0 \u0026\u0026 gl-\u003emakeCurrent(window))",
        "                sgrc-\u003einitialize(gl);",
        "            syncAndRender();",
        "        }",
        "",
        "        processEvents();",
        "        QCoreApplication::processEvents();",
        "",
        "        if (active \u0026\u0026 (pendingUpdate \u003d\u003d 0 || !window)) {",
        "            QSG_RT_DEBUG(\"enter event loop (going to sleep)\");",
        "            sleeping \u003d true;",
        "            processEventsAndWaitForMore();",
        "            sleeping \u003d false;",
        "        }",
        "    }",
        "",
        "    Q_ASSERT_X(!gl, \"QSGRenderThread::run()\", \"The OpenGL context should be cleaned up before exiting the render thread...\");",
        "",
        "    QSG_RT_DEBUG(\"run() completed...\");",
        "",
        "    delete animatorDriver;",
        "    animatorDriver \u003d 0;",
        "",
        "    sgrc-\u003emoveToThread(wm-\u003ethread());",
        "    moveToThread(wm-\u003ethread());",
        "}",
        "",
        "QSGThreadedRenderLoop::QSGThreadedRenderLoop()",
        "    : sg(QSGContext::createDefaultContext())",
        "    , m_animation_timer(0)",
        "{",
        "#if defined(QSG_RENDER_LOOP_DEBUG)",
        "    qsgrl_timer.start();",
        "#endif",
        "",
        "    m_animation_driver \u003d sg-\u003ecreateAnimationDriver(this);",
        "",
        "    m_exhaust_delay \u003d get_env_int(\"QML_EXHAUST_DELAY\", 5);",
        "",
        "    connect(m_animation_driver, SIGNAL(started()), this, SLOT(animationStarted()));",
        "    connect(m_animation_driver, SIGNAL(stopped()), this, SLOT(animationStopped()));",
        "",
        "    m_animation_driver-\u003einstall();",
        "    QSG_GUI_DEBUG((void *) 0, \"QSGThreadedRenderLoop() created\");",
        "}",
        "",
        "QSGRenderContext *QSGThreadedRenderLoop::createRenderContext(QSGContext *sg) const",
        "{",
        "    return sg-\u003ecreateRenderContext();",
        "}",
        "",
        "void QSGThreadedRenderLoop::maybePostPolishRequest(Window *w)",
        "{",
        "    if (w-\u003etimerId \u003d\u003d 0) {",
        "        QSG_GUI_DEBUG(w-\u003ewindow, \" - posting update\");",
        "        w-\u003etimerId \u003d startTimer(m_exhaust_delay, Qt::PreciseTimer);",
        "    }",
        "}",
        "",
        "QAnimationDriver *QSGThreadedRenderLoop::animationDriver() const",
        "{",
        "    return m_animation_driver;",
        "}",
        "",
        "QSGContext *QSGThreadedRenderLoop::sceneGraphContext() const",
        "{",
        "    return sg;",
        "}",
        "",
        "bool QSGThreadedRenderLoop::anyoneShowing() const",
        "{",
        "    for (int i\u003d0; i\u003cm_windows.size(); ++i) {",
        "        QQuickWindow *c \u003d m_windows.at(i).window;",
        "        if (c-\u003eisVisible() \u0026\u0026 c-\u003eisExposed())",
        "            return true;",
        "    }",
        "    return false;",
        "}",
        "",
        "bool QSGThreadedRenderLoop::interleaveIncubation() const",
        "{",
        "    return m_animation_driver-\u003eisRunning() \u0026\u0026 anyoneShowing();",
        "}",
        "",
        "void QSGThreadedRenderLoop::animationStarted()",
        "{",
        "    QSG_GUI_DEBUG((void *) 0, \"animationStarted()\");",
        "    startOrStopAnimationTimer();",
        "",
        "    for (int i\u003d0; i\u003cm_windows.size(); ++i)",
        "        maybePostPolishRequest(const_cast\u003cWindow *\u003e(\u0026m_windows.at(i)));",
        "}",
        "",
        "void QSGThreadedRenderLoop::animationStopped()",
        "{",
        "    QSG_GUI_DEBUG((void *) 0, \"animationStopped()\");",
        "    startOrStopAnimationTimer();",
        "}",
        "",
        "",
        "void QSGThreadedRenderLoop::startOrStopAnimationTimer()",
        "{",
        "    int exposedWindows \u003d 0;",
        "    Window *theOne \u003d 0;",
        "    for (int i\u003d0; i\u003cm_windows.size(); ++i) {",
        "        Window \u0026w \u003d m_windows[i];",
        "        if (w.window-\u003eisVisible() \u0026\u0026 w.window-\u003eisExposed()) {",
        "            ++exposedWindows;",
        "            theOne \u003d \u0026w;",
        "        }",
        "    }",
        "",
        "    if (m_animation_timer !\u003d 0 \u0026\u0026 (exposedWindows \u003d\u003d 1 || !m_animation_driver-\u003eisRunning())) {",
        "        killTimer(m_animation_timer);",
        "        m_animation_timer \u003d 0;",
        "        // If animations are running, make sure we keep on animating",
        "        if (m_animation_driver-\u003eisRunning())",
        "            maybePostPolishRequest(theOne);",
        "",
        "    } else if (m_animation_timer \u003d\u003d 0 \u0026\u0026 exposedWindows !\u003d 1 \u0026\u0026 m_animation_driver-\u003eisRunning()) {",
        "        m_animation_timer \u003d startTimer(qsgrl_animation_interval());",
        "    }",
        "}",
        "",
        "/*",
        "    Adds this window to the list of tracked windows in this window",
        "    manager. show() does not trigger rendering to start, that happens",
        "    in expose.",
        " */",
        "",
        "void QSGThreadedRenderLoop::show(QQuickWindow *window)",
        "{",
        "    QSG_GUI_DEBUG(window, \"show()\");",
        "",
        "    if (Window *w \u003d windowFor(m_windows, window)) {",
        "        /* Safeguard ourselves against misbehaving platform plugins.",
        "         *",
        "         * When being shown, the window should not be exposed as the",
        "         * platform plugin is only told to show after we send the show",
        "         * event. If we are already shown at this time and we don\u0027t have",
        "         * an active rendering thread we don\u0027t trust the plugin to send",
        "         * us another expose event, so make this explicit call to",
        "         * handleExposure.",
        "         *",
        "         * REF: QTCREATORBUG-10699",
        "         */",
        "        if (window-\u003eisExposed() \u0026\u0026 (!w-\u003ethread || !w-\u003ethread-\u003ewindow))",
        "            handleExposure(w);",
        "        return;",
        "    }",
        "",
        "    QSG_GUI_DEBUG(window, \" - now tracking new window\");",
        "",
        "    Window win;",
        "    win.window \u003d window;",
        "    win.thread \u003d new QSGRenderThread(this, QQuickWindowPrivate::get(window)-\u003econtext);",
        "    win.timerId \u003d 0;",
        "    win.updateDuringSync \u003d false;",
        "    m_windows \u003c\u003c win;",
        "}",
        "",
        "",
        "",
        "/*",
        "    Removes this window from the list of tracked windowes in this",
        "    window manager. hide() will trigger obscure, which in turn will",
        "    stop rendering.",
        " */",
        "",
        "void QSGThreadedRenderLoop::hide(QQuickWindow *window)",
        "{",
        "    QSG_GUI_DEBUG(window, \"hide()\");",
        "",
        "    if (window-\u003eisExposed())",
        "        handleObscurity(windowFor(m_windows, window));",
        "",
        "    releaseResources(window);",
        "}",
        "",
        "",
        "/*!",
        "    If the window is first hide it, then perform a complete cleanup",
        "    with releaseResources which will take down the GL context and",
        "    exit the rendering thread.",
        " */",
        "void QSGThreadedRenderLoop::windowDestroyed(QQuickWindow *window)",
        "{",
        "    QSG_GUI_DEBUG(window, \"windowDestroyed()\");",
        "",
        "    if (window-\u003eisVisible())",
        "        hide(window);",
        "    releaseResources(window, true);",
        "",
        "    for (int i\u003d0; i\u003cm_windows.size(); ++i) {",
        "        if (m_windows.at(i).window \u003d\u003d window) {",
        "            QSGRenderThread *thread \u003d m_windows.at(i).thread;",
        "            while (thread-\u003eisRunning())",
        "                QThread::yieldCurrentThread();",
        "            Q_ASSERT(thread-\u003ethread() \u003d\u003d QThread::currentThread());",
        "            delete thread;",
        "            m_windows.removeAt(i);",
        "            break;",
        "        }",
        "    }",
        "",
        "    QSG_GUI_DEBUG(window, \" - done with windowDestroyed()\");",
        "}",
        "",
        "",
        "void QSGThreadedRenderLoop::exposureChanged(QQuickWindow *window)",
        "{",
        "    QSG_GUI_DEBUG(window, \"exposureChanged()\");",
        "    Window *w \u003d windowFor(m_windows, window);",
        "    if (!w)",
        "        return;",
        "",
        "    if (window-\u003eisExposed()) {",
        "        handleExposure(w);",
        "    } else {",
        "        handleObscurity(w);",
        "    }",
        "}",
        "",
        "/*!",
        "    Will post an event to the render thread that this window should",
        "    start to render.",
        " */",
        "void QSGThreadedRenderLoop::handleExposure(Window *w)",
        "{",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \"handleExposure\");",
        "",
        "    if (w-\u003ewindow-\u003ewidth() \u003c\u003d 0 || w-\u003ewindow-\u003eheight() \u003c\u003d 0",
        "            || !w-\u003ewindow-\u003egeometry().intersects(w-\u003ewindow-\u003escreen()-\u003eavailableGeometry())) {",
        "#ifndef QT_NO_DEBUG",
        "        qWarning(\"QSGThreadedRenderLoop: expose event received for window with invalid geometry.\");",
        "#endif",
        "    }",
        "",
        "    // Because we are going to bind a GL context to it, make sure it",
        "    // is created.",
        "    if (!w-\u003ewindow-\u003ehandle())",
        "        w-\u003ewindow-\u003ecreate();",
        "",
        "    // Start render thread if it is not running",
        "    if (!w-\u003ethread-\u003eisRunning()) {",
        "",
        "        QSG_GUI_DEBUG(w-\u003ewindow, \" - starting render thread...\");",
        "",
        "        if (!w-\u003ethread-\u003egl) {",
        "            w-\u003ethread-\u003egl \u003d new QOpenGLContext();",
        "            if (QSGContext::sharedOpenGLContext())",
        "                w-\u003ethread-\u003egl-\u003esetShareContext(QSGContext::sharedOpenGLContext());",
        "            w-\u003ethread-\u003egl-\u003esetFormat(w-\u003ewindow-\u003erequestedFormat());",
        "            if (!w-\u003ethread-\u003egl-\u003ecreate()) {"
      ]
    },
    {
      "b": [
        "                const bool isEs \u003d w-\u003ethread-\u003egl-\u003eisES();"
      ]
    },
    {
      "ab": [
        "                delete w-\u003ethread-\u003egl;",
        "                w-\u003ethread-\u003egl \u003d 0;"
      ]
    },
    {
      "a": [
        "                QString formatStr;",
        "                QDebug(\u0026formatStr) \u003c\u003c w-\u003ewindow-\u003erequestedFormat();",
        "                QString contextType \u003d QLatin1String(\"OpenGL\");",
        "                const char *msg \u003d QT_TRANSLATE_NOOP(\"QSGThreadedRenderLoop\",",
        "                                                    \"Failed to create %1 context for format %2\");",
        "                QString translatedMsg \u003d tr(msg).arg(contextType).arg(formatStr);",
        "                QString nonTranslatedMsg \u003d QString(QLatin1String(msg)).arg(contextType).arg(formatStr);",
        "                bool signalEmitted \u003d QQuickWindowPrivate::get(w-\u003ewindow)-\u003eemitError(QQuickWindow::ContextNotAvailable,",
        "                                                                                    translatedMsg);",
        "                if (!signalEmitted)",
        "                    qFatal(\"%s\", qPrintable(nonTranslatedMsg));"
      ],
      "b": [
        "                handleContextCreationFailure(w-\u003ewindow, isEs);"
      ]
    },
    {
      "ab": [
        "                return;",
        "            }",
        "",
        "            QQuickWindowPrivate::get(w-\u003ewindow)-\u003efireOpenGLContextCreated(w-\u003ethread-\u003egl);",
        "",
        "            w-\u003ethread-\u003egl-\u003emoveToThread(w-\u003ethread);",
        "            QSG_GUI_DEBUG(w-\u003ewindow, \" - OpenGL context created...\");",
        "        }",
        "",
        "        QQuickAnimatorController *controller \u003d QQuickWindowPrivate::get(w-\u003ewindow)-\u003eanimationController;",
        "        if (controller-\u003ethread() !\u003d w-\u003ethread)",
        "            controller-\u003emoveToThread(w-\u003ethread);",
        "",
        "        w-\u003ethread-\u003eactive \u003d true;",
        "        if (w-\u003ethread-\u003ethread() \u003d\u003d QThread::currentThread()) {",
        "            w-\u003ethread-\u003esgrc-\u003emoveToThread(w-\u003ethread);",
        "            w-\u003ethread-\u003emoveToThread(w-\u003ethread);",
        "        }",
        "        w-\u003ethread-\u003estart();",
        "",
        "    } else {",
        "        QSG_GUI_DEBUG(w-\u003ewindow, \" - render thread already running\");",
        "    }",
        "",
        "    w-\u003ethread-\u003epostEvent(new WMExposeEvent(w-\u003ewindow));",
        "    bool synced \u003d polishAndSync(w);",
        "",
        "    if (synced) {",
        "        w-\u003ethread-\u003emutex.lock();",
        "        if (w-\u003ethread-\u003eexposeCycle !\u003d QSGRenderThread::NoExpose) {",
        "            QSG_GUI_DEBUG(w-\u003ewindow, \" - waiting for swap to complete...\");",
        "            w-\u003ethread-\u003ewaitCondition.wait(\u0026w-\u003ethread-\u003emutex);",
        "        }",
        "        Q_ASSERT(w-\u003ethread-\u003eexposeCycle \u003d\u003d QSGRenderThread::NoExpose);",
        "        w-\u003ethread-\u003emutex.unlock();",
        "    } else {",
        "        w-\u003ethread-\u003epostEvent(new QEvent(WM_ResetExposeCycle));",
        "    }",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \" - handleExposure completed...\");",
        "",
        "    startOrStopAnimationTimer();",
        "}",
        "",
        "/*!",
        "    This function posts an event to the render thread to remove the window",
        "    from the list of windowses to render.",
        "",
        "    It also starts up the non-vsync animation tick if no more windows",
        "    are showing.",
        " */",
        "void QSGThreadedRenderLoop::handleObscurity(Window *w)",
        "{",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \"handleObscurity\");",
        "    if (w-\u003ethread-\u003eisRunning()) {",
        "        w-\u003ethread-\u003emutex.lock();",
        "        w-\u003ethread-\u003epostEvent(new WMWindowEvent(w-\u003ewindow, WM_Obscure));",
        "        w-\u003ethread-\u003ewaitCondition.wait(\u0026w-\u003ethread-\u003emutex);",
        "        w-\u003ethread-\u003emutex.unlock();",
        "    }",
        "",
        "    startOrStopAnimationTimer();",
        "}",
        "",
        "",
        "void QSGThreadedRenderLoop::maybeUpdate(QQuickWindow *window)",
        "{",
        "    Window *w \u003d windowFor(m_windows, window);",
        "    if (w)",
        "        maybeUpdate(w);",
        "}",
        "",
        "/*!",
        "    Called whenever the QML scene has changed. Will post an event to",
        "    ourselves that a sync is needed.",
        " */",
        "void QSGThreadedRenderLoop::maybeUpdate(Window *w)",
        "{",
        "    if (!QCoreApplication::instance())",
        "        return;",
        "",
        "    Q_ASSERT_X(QThread::currentThread() \u003d\u003d QCoreApplication::instance()-\u003ethread() || m_locked,",
        "               \"QQuickItem::update()\",",
        "               \"Function can only be called from GUI thread or during QQuickItem::updatePaintNode()\");",
        "",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \"maybeUpdate...\");",
        "    if (!w || !w-\u003ethread-\u003eisRunning()) {",
        "        return;",
        "    }",
        "",
        "    // Call this function from the Gui thread later as startTimer cannot be",
        "    // called from the render thread.",
        "    if (QThread::currentThread() \u003d\u003d w-\u003ethread) {",
        "        QSG_GUI_DEBUG(w-\u003ewindow, \" - on render thread, will update later..\");",
        "        w-\u003eupdateDuringSync \u003d true;",
        "        return;",
        "    }",
        "",
        "    maybePostPolishRequest(w);",
        "}",
        "",
        "/*!",
        "    Called when the QQuickWindow should be explicitly repainted. This function",
        "    can also be called on the render thread when the GUI thread is blocked to",
        "    keep render thread animations alive.",
        " */",
        "void QSGThreadedRenderLoop::update(QQuickWindow *window)",
        "{",
        "    Window *w \u003d windowFor(m_windows, window);",
        "    if (!w)",
        "        return;",
        "",
        "    if (w-\u003ethread \u003d\u003d QThread::currentThread()) {",
        "        QSG_RT_DEBUG(\"QQuickWindow::update called on render thread\");",
        "        w-\u003ethread-\u003erequestRepaint();",
        "        return;",
        "    }",
        "",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \"update called\");",
        "    w-\u003ethread-\u003epostEvent(new QEvent(WM_RequestRepaint));",
        "    maybeUpdate(w);",
        "}",
        "",
        "",
        "",
        "/*!",
        " * Release resources will post an event to the render thread to",
        " * free up the SG and GL resources and exists the render thread.",
        " */",
        "void QSGThreadedRenderLoop::releaseResources(QQuickWindow *window, bool inDestructor)",
        "{",
        "    QSG_GUI_DEBUG(window, \"releaseResources requested...\");",
        "",
        "    Window *w \u003d windowFor(m_windows, window);",
        "    if (!w)",
        "        return;",
        "",
        "    w-\u003ethread-\u003emutex.lock();",
        "    if (w-\u003ethread-\u003eisRunning() \u0026\u0026 w-\u003ethread-\u003eactive) {",
        "",
        "        // The platform window might have been destroyed before",
        "        // hide/release/windowDestroyed is called, so we need to have a",
        "        // fallback surface to perform the cleanup of the scene graph",
        "        // and the OpenGL resources.",
        "        // QOffscreenSurface must be created on the GUI thread, so we",
        "        // create it here and pass it on to QSGRenderThread::invalidateGL()",
        "        QOffscreenSurface *fallback \u003d 0;",
        "        if (!window-\u003ehandle()) {",
        "            QSG_GUI_DEBUG(w-\u003ewindow, \" - using fallback surface\");",
        "            fallback \u003d new QOffscreenSurface();",
        "            fallback-\u003esetFormat(window-\u003erequestedFormat());",
        "            fallback-\u003ecreate();",
        "        }",
        "",
        "        QSG_GUI_DEBUG(w-\u003ewindow, \" - posting release request to render thread\");",
        "        w-\u003ethread-\u003epostEvent(new WMTryReleaseEvent(window, inDestructor, fallback));",
        "        w-\u003ethread-\u003ewaitCondition.wait(\u0026w-\u003ethread-\u003emutex);",
        "",
        "        delete fallback;",
        "    }",
        "    w-\u003ethread-\u003emutex.unlock();",
        "}",
        "",
        "",
        "/* Calls polish on all items, then requests synchronization with the render thread",
        " * and blocks until that is complete. Returns false if it aborted; otherwise true.",
        " */",
        "bool QSGThreadedRenderLoop::polishAndSync(Window *w)",
        "{",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \"polishAndSync()\");",
        "",
        "    if (!w-\u003ewindow-\u003eisExposed() || !w-\u003ewindow-\u003eisVisible() || w-\u003ewindow-\u003esize().isEmpty()) {",
        "        QSG_GUI_DEBUG(w-\u003ewindow, \" - not exposed, aborting...\");",
        "        killTimer(w-\u003etimerId);",
        "        w-\u003etimerId \u003d 0;",
        "        return false;",
        "    }",
        "",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "    QElapsedTimer timer;",
        "    qint64 polishTime \u003d 0;",
        "    qint64 waitTime \u003d 0;",
        "    qint64 syncTime \u003d 0;",
        "    bool profileFrames \u003d qsg_render_timing  || QQuickProfiler::enabled;",
        "    if (profileFrames)",
        "        timer.start();",
        "#endif",
        "",
        "    QQuickWindowPrivate *d \u003d QQuickWindowPrivate::get(w-\u003ewindow);",
        "    d-\u003epolishItems();",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "    if (profileFrames)",
        "        polishTime \u003d timer.nsecsElapsed();",
        "#endif",
        "",
        "    w-\u003eupdateDuringSync \u003d false;",
        "",
        "    emit w-\u003ewindow-\u003eafterAnimating();",
        "",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \" - lock for sync...\");",
        "    w-\u003ethread-\u003emutex.lock();",
        "    m_locked \u003d true;",
        "    w-\u003ethread-\u003epostEvent(new QEvent(WM_RequestSync));",
        "",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \" - wait for sync...\");",
        "#ifndef QSG_NO_RENDER_TIMING",
        "    if (profileFrames)",
        "        waitTime \u003d timer.nsecsElapsed();",
        "#endif",
        "    w-\u003ethread-\u003ewaitCondition.wait(\u0026w-\u003ethread-\u003emutex);",
        "    m_locked \u003d false;",
        "    w-\u003ethread-\u003emutex.unlock();",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \" - unlocked after sync...\");",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "    if (profileFrames)",
        "        syncTime \u003d timer.nsecsElapsed();",
        "#endif",
        "",
        "    killTimer(w-\u003etimerId);",
        "    w-\u003etimerId \u003d 0;",
        "",
        "    if (m_animation_timer \u003d\u003d 0 \u0026\u0026 m_animation_driver-\u003eisRunning()) {",
        "        QSG_GUI_DEBUG(w-\u003ewindow, \" - animations advancing\");",
        "        m_animation_driver-\u003eadvance();",
        "        QSG_GUI_DEBUG(w-\u003ewindow, \" - animations done\");",
        "        // We need to trigger another sync to keep animations running...",
        "        maybePostPolishRequest(w);",
        "        emit timeToIncubate();",
        "    } else if (w-\u003eupdateDuringSync) {",
        "        maybePostPolishRequest(w);",
        "    }",
        "",
        "",
        "#ifndef QSG_NO_RENDER_TIMING",
        "    if (qsg_render_timing)",
        "        qDebug(\" - Gui Thread: window\u003d%p, polish\u003d%d, lock\u003d%d, block/sync\u003d%d -- animations\u003d%d\",",
        "               w-\u003ewindow,",
        "               int(polishTime/1000000),",
        "               int((waitTime - polishTime)/1000000),",
        "               int((syncTime - waitTime)/1000000),",
        "               int((timer.nsecsElapsed() - syncTime)/1000000));",
        "",
        "    Q_QUICK_SG_PROFILE1(QQuickProfiler::SceneGraphPolishAndSync, (",
        "            polishTime,",
        "            waitTime - polishTime,",
        "            syncTime - waitTime,",
        "            timer.nsecsElapsed() - syncTime));",
        "#endif",
        "",
        "    return true;",
        "}",
        "",
        "bool QSGThreadedRenderLoop::event(QEvent *e)",
        "{",
        "    switch ((int) e-\u003etype()) {",
        "",
        "    case QEvent::Timer: {",
        "        QTimerEvent *te \u003d static_cast\u003cQTimerEvent *\u003e(e);",
        "        if (te-\u003etimerId() \u003d\u003d m_animation_timer) {",
        "            QSG_GUI_DEBUG((void *) 0, \"QEvent::Timer -\u003e non-visual animation\");",
        "            m_animation_driver-\u003eadvance();",
        "            emit timeToIncubate();",
        "        } else {",
        "            QSG_GUI_DEBUG((void *) 0, \"QEvent::Timer -\u003e Polish \u0026 Sync\");",
        "            Window *w \u003d 0;",
        "            for (int i\u003d0; i\u003cm_windows.size(); ++i) {",
        "                if (m_windows.at(i).timerId \u003d\u003d te-\u003etimerId()) {",
        "                    w \u003d const_cast\u003cWindow *\u003e(\u0026m_windows.at(i));",
        "                    break;",
        "                }",
        "            }",
        "            if (w)",
        "                polishAndSync(w);",
        "        }",
        "        return true;",
        "    }",
        "",
        "    default:",
        "        break;",
        "    }",
        "",
        "    return QObject::event(e);",
        "}",
        "",
        "",
        "",
        "/*",
        "    Locks down GUI and performs a grab the scene graph, then returns the result.",
        "",
        "    Since the QML scene could have changed since the last time it was rendered,",
        "    we need to polish and sync the scene graph. This might seem superfluous, but",
        "     - QML changes could have triggered deleteLater() which could have removed",
        "       textures or other objects from the scene graph, causing render to crash.",
        "     - Autotests rely on grab(), setProperty(), grab(), compare behavior.",
        " */",
        "",
        "QImage QSGThreadedRenderLoop::grab(QQuickWindow *window)",
        "{",
        "    QSG_GUI_DEBUG(window, \"grab\");",
        "",
        "    Window *w \u003d windowFor(m_windows, window);",
        "    Q_ASSERT(w);",
        "",
        "    if (!w-\u003ethread-\u003eisRunning())",
        "        return QImage();",
        "",
        "    if (!window-\u003ehandle())",
        "        window-\u003ecreate();",
        "",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \" - polishing items...\");",
        "    QQuickWindowPrivate *d \u003d QQuickWindowPrivate::get(window);",
        "    d-\u003epolishItems();",
        "",
        "    QImage result;",
        "    w-\u003ethread-\u003emutex.lock();",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \" - locking, posting grab event\");",
        "    w-\u003ethread-\u003epostEvent(new WMGrabEvent(window, \u0026result));",
        "    w-\u003ethread-\u003ewaitCondition.wait(\u0026w-\u003ethread-\u003emutex);",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \" - locking, grab done, unlocking\");",
        "    w-\u003ethread-\u003emutex.unlock();",
        "",
        "    QSG_GUI_DEBUG(w-\u003ewindow, \" - grab complete\");",
        "",
        "    return result;",
        "}",
        "",
        "",
        "#include \"qsgthreadedrenderloop.moc\"",
        "",
        "QT_END_NAMESPACE",
        ""
      ]
    }
  ]
}
