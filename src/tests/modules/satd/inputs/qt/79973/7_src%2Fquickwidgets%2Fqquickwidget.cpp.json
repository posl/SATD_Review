{
  "meta_a": {
    "name": "src/quickwidgets/qquickwidget.cpp",
    "content_type": "text/x-c++src",
    "lines": 871,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003d5de274605a19fe7d8cf989978d5959826e7970c7;f\u003dsrc%2Fquickwidgets%2Fqquickwidget.cpp"
      }
    ]
  },
  "meta_b": {
    "name": "src/quickwidgets/qquickwidget.cpp",
    "content_type": "text/x-c++src",
    "lines": 914,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003drefs%2Fchanges%2F73%2F79973%2F7;f\u003dsrc%2Fquickwidgets%2Fqquickwidget.cpp"
      }
    ]
  },
  "change_type": "MODIFIED",
  "diff_header": [
    "diff --git a/src/quickwidgets/qquickwidget.cpp b/src/quickwidgets/qquickwidget.cpp",
    "index 147762c..ec19411 100644",
    "--- a/src/quickwidgets/qquickwidget.cpp",
    "+++ b/src/quickwidgets/qquickwidget.cpp"
  ],
  "content": [
    {
      "ab": [
        "/****************************************************************************",
        "**",
        "** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).",
        "** Contact: http://www.qt-project.org/legal",
        "**",
        "** This file is part of the QtQuick module of the Qt Toolkit.",
        "**",
        "** $QT_BEGIN_LICENSE:LGPL$",
        "** Commercial License Usage",
        "** Licensees holding valid commercial Qt licenses may use this file in",
        "** accordance with the commercial license agreement provided with the",
        "** Software or, alternatively, in accordance with the terms contained in",
        "** a written agreement between you and Digia.  For licensing terms and",
        "** conditions see http://qt.digia.com/licensing.  For further information",
        "** use the contact form at http://qt.digia.com/contact-us.",
        "**",
        "** GNU Lesser General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU Lesser",
        "** General Public License version 2.1 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.LGPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU Lesser General Public License version 2.1 requirements",
        "** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.",
        "**",
        "** In addition, as a special exception, Digia gives you certain additional",
        "** rights.  These rights are described in the Digia Qt LGPL Exception",
        "** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.",
        "**",
        "** GNU General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU",
        "** General Public License version 3.0 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.GPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU General Public License version 3.0 requirements will be",
        "** met: http://www.gnu.org/copyleft/gpl.html.",
        "**",
        "**",
        "** $QT_END_LICENSE$",
        "**",
        "****************************************************************************/",
        "",
        "#include \"qquickwidget.h\"",
        "#include \"qquickwidget_p.h\"",
        "",
        "#include \"private/qquickwindow_p.h\"",
        "#include \"private/qquickitem_p.h\"",
        "#include \"private/qquickitemchangelistener_p.h\"",
        "#include \"private/qquickrendercontrol_p.h\"",
        "",
        "#include \u003cprivate/qquickprofiler_p.h\u003e",
        "#include \u003cprivate/qqmlinspectorservice_p.h\u003e",
        "#include \u003cprivate/qqmlmemoryprofiler_p.h\u003e",
        "",
        "#include \u003cQtQml/qqmlengine.h\u003e",
        "#include \u003cprivate/qqmlengine_p.h\u003e",
        "#include \u003cQtCore/qbasictimer.h\u003e"
      ]
    },
    {
      "b": [
        "#ifdef Q_OS_WIN",
        "#  include \u003cQtWidgets/QMessageBox\u003e",
        "#  include \u003cQtCore/QLibraryInfo\u003e",
        "#  include \u003cQtCore/qt_windows.h\u003e",
        "#endif"
      ]
    },
    {
      "ab": [
        "",
        "QT_BEGIN_NAMESPACE",
        "",
        "extern Q_GUI_EXPORT QImage qt_gl_read_framebuffer(const QSize \u0026size, bool alpha_format, bool include_alpha);",
        "",
        "void QQuickWidgetPrivate::init(QQmlEngine* e)",
        "{",
        "    Q_Q(QQuickWidget);",
        "",
        "    setRenderToTexture();",
        "    engine \u003d e;",
        "",
        "    if (engine.isNull())",
        "        engine \u003d new QQmlEngine(q);",
        "",
        "    if (!engine.data()-\u003eincubationController())",
        "        engine.data()-\u003esetIncubationController(offscreenWindow-\u003eincubationController());",
        "",
        "    if (QQmlDebugService::isDebuggingEnabled())",
        "        QQmlInspectorService::instance()-\u003eaddView(q);",
        "",
        "    QWidget::connect(offscreenWindow, SIGNAL(sceneGraphInitialized()), q, SLOT(createFramebufferObject()));",
        "    QWidget::connect(offscreenWindow, SIGNAL(sceneGraphInvalidated()), q, SLOT(destroyFramebufferObject()));",
        "    QObject::connect(renderControl, SIGNAL(renderRequested()), q, SLOT(triggerUpdate()));",
        "    QObject::connect(renderControl, SIGNAL(sceneChanged()), q, SLOT(triggerUpdate()));",
        "}",
        "",
        "QQuickWidgetPrivate::QQuickWidgetPrivate()",
        "    : root(0)",
        "    , component(0)",
        "    , fbo(0)",
        "    , context(0)",
        "    , resizeMode(QQuickWidget::SizeViewToRootObject)",
        "    , initialSize(0,0)",
        "    , updateTimer(0)",
        "    , eventPending(false)",
        "    , updatePending(false)",
        "{",
        "    renderControl \u003d new QQuickRenderControl;",
        "    offscreenWindow \u003d new QQuickWindow(renderControl);",
        "    offscreenWindow-\u003esetTitle(QString::fromLatin1(\"Offscreen\"));",
        "    // Do not call create() on offscreenWindow.",
        "}",
        "",
        "QQuickWidgetPrivate::~QQuickWidgetPrivate()",
        "{",
        "    if (QQmlDebugService::isDebuggingEnabled())",
        "        QQmlInspectorService::instance()-\u003eremoveView(q_func());",
        "    delete offscreenWindow;",
        "    delete renderControl;",
        "    delete fbo;",
        "}",
        "",
        "void QQuickWidgetPrivate::execute()",
        "{",
        "    Q_Q(QQuickWidget);",
        "    if (!engine) {",
        "        qWarning() \u003c\u003c \"QQuickWidget: invalid qml engine.\";",
        "        return;",
        "    }",
        "",
        "    if (root) {",
        "        delete root;",
        "        root \u003d 0;",
        "    }",
        "    if (component) {",
        "        delete component;",
        "        component \u003d 0;",
        "    }",
        "    if (!source.isEmpty()) {",
        "        QML_MEMORY_SCOPE_URL(engine.data()-\u003ebaseUrl().resolved(source));",
        "        component \u003d new QQmlComponent(engine.data(), source, q);",
        "        if (!component-\u003eisLoading()) {",
        "            q-\u003econtinueExecute();",
        "        } else {",
        "            QObject::connect(component, SIGNAL(statusChanged(QQmlComponent::Status)),",
        "                             q, SLOT(continueExecute()));",
        "        }",
        "    }",
        "}",
        "",
        "void QQuickWidgetPrivate::itemGeometryChanged(QQuickItem *resizeItem, const QRectF \u0026newGeometry, const QRectF \u0026oldGeometry)",
        "{",
        "    Q_Q(QQuickWidget);",
        "    if (resizeItem \u003d\u003d root \u0026\u0026 resizeMode \u003d\u003d QQuickWidget::SizeViewToRootObject) {",
        "        // wait for both width and height to be changed",
        "        resizetimer.start(0,q);",
        "    }",
        "    QQuickItemChangeListener::itemGeometryChanged(resizeItem, newGeometry, oldGeometry);",
        "}",
        "",
        "void QQuickWidgetPrivate::renderSceneGraph()",
        "{",
        "    Q_Q(QQuickWidget);",
        "    updatePending \u003d false;",
        "",
        "    QOpenGLContext *context \u003d offscreenWindow-\u003eopenglContext();",
        "    if (!context) {",
        "        qWarning(\"QQuickWidget: render scenegraph with no context\");",
        "        return;",
        "    }",
        "",
        "    Q_ASSERT(q-\u003ewindow()-\u003ewindowHandle()-\u003ehandle());",
        "    context-\u003emakeCurrent(q-\u003ewindow()-\u003ewindowHandle());",
        "    renderControl-\u003epolishItems();",
        "    renderControl-\u003esync();",
        "    renderControl-\u003erender();",
        "    glFlush();",
        "    context-\u003edoneCurrent();",
        "    q-\u003eupdate();",
        "}",
        "",
        "/*!",
        "    \\class QQuickWidget",
        "    \\since 5.3",
        "    \\brief The QQuickWidget class provides a widget for displaying a Qt Quick user interface.",
        "",
        "    \\inmodule QtQuick",
        "",
        "    This is a convenience wrapper for QQuickWindow which will automatically load and display a QML",
        "    scene when given the URL of the main source file. Alternatively, you can instantiate your own",
        "    objects using QQmlComponent and place them in a manually setup QQuickWidget.",
        "",
        "    Typical usage:",
        "",
        "    \\code",
        "    QQuickWidget *view \u003d new QQuickWidget;",
        "    view-\u003esetSource(QUrl::fromLocalFile(\"myqmlfile.qml\"));",
        "    view-\u003eshow();",
        "    \\endcode",
        "",
        "    To receive errors related to loading and executing QML with QQuickWidget,",
        "    you can connect to the statusChanged() signal and monitor for QQuickWidget::Error.",
        "    The errors are available via QQuickWidget::errors().",
        "",
        "    QQuickWidget also manages sizing of the view and root object.  By default, the \\l resizeMode",
        "    is SizeViewToRootObject, which will load the component and resize it to the",
        "    size of the view.  Alternatively the resizeMode may be set to SizeRootObjectToView which",
        "    will resize the view to the size of the root object.",
        "",
        "    \\note QQuickWidget is an alternative to using QQuickView and QWidget::createWindowContainer().",
        "    The restrictions on stacking order do not apply, making QQuickWidget the more flexible",
        "    alternative behaving more like an ordinary widget. This comes at the expense of",
        "    performance. Unlike QQuickWindow and QQuickView, QQuickWidget involves rendering into OpenGL",
        "    framebuffer objects. This will naturally carry a minor performance hit.",
        "",
        "    \\note Using QQuickWidget disables the threaded render loop on all platforms. This means that",
        "    some of the benefits of threaded rendering, for example Animator classes and vsync driven",
        "    animations, will not be available.",
        "",
        "    \\sa {qtqml-cppintegration-exposecppattributes.html}{Exposing Attributes of C++ Types to QML}",
        "*/",
        "",
        "",
        "/*! \\fn void QQuickWidget::statusChanged(QQuickWidget::Status status)",
        "    This signal is emitted when the component\u0027s current \\a status changes.",
        "*/",
        "",
        "/*!",
        "  Constructs a QQuickWidget with the given \\a parent.",
        "  The default value of \\a parent is 0.",
        "",
        "*/",
        "QQuickWidget::QQuickWidget(QWidget *parent)",
        ": QWidget(*(new QQuickWidgetPrivate), parent, 0)",
        "{",
        "    setMouseTracking(true);",
        "    d_func()-\u003einit();",
        "}",
        "",
        "/*!",
        "  Constructs a QQuickWidget with the given QML \\a source and \\a parent.",
        "  The default value of \\a parent is 0.",
        "",
        "*/",
        "QQuickWidget::QQuickWidget(const QUrl \u0026source, QWidget *parent)",
        ": QWidget(*(new QQuickWidgetPrivate), parent, 0)",
        "{",
        "    setMouseTracking(true);",
        "    d_func()-\u003einit();",
        "    setSource(source);",
        "}",
        "",
        "/*!",
        "  Constructs a QQuickWidget with the given QML \\a engine and \\a parent.",
        "",
        "  Note: In this case, the QQuickWidget does not own the given \\a engine object;",
        "  it is the caller\u0027s responsibility to destroy the engine. If the \\a engine is deleted",
        "  before the view, status() will return QQuickWidget::Error.",
        "",
        "  \\sa Status, status(), errors()",
        "*/",
        "QQuickWidget::QQuickWidget(QQmlEngine* engine, QWidget *parent)",
        "    : QWidget(*(new QQuickWidgetPrivate), parent, 0)",
        "{",
        "    setMouseTracking(true);",
        "    Q_ASSERT(engine);",
        "    d_func()-\u003einit(engine);",
        "}",
        "",
        "/*!",
        "  Destroys the QQuickWidget.",
        "*/",
        "QQuickWidget::~QQuickWidget()",
        "{",
        "    // Ensure that the component is destroyed before the engine; the engine may",
        "    // be a child of the QQuickWidgetPrivate, and will be destroyed by its dtor",
        "    Q_D(QQuickWidget);",
        "    delete d-\u003eroot;",
        "    d-\u003eroot \u003d 0;",
        "}",
        "",
        "/*!",
        "  \\property QQuickWidget::source",
        "  \\brief The URL of the source of the QML component.",
        "",
        "  Ensure that the URL provided is full and correct, in particular, use",
        "  \\l QUrl::fromLocalFile() when loading a file from the local filesystem.",
        "",
        "  Note that setting a source URL will result in the QML component being",
        "  instantiated, even if the URL is unchanged from the current value.",
        "*/",
        "",
        "/*!",
        "    Sets the source to the \\a url, loads the QML component and instantiates it.",
        "",
        "    Ensure that the URL provided is full and correct, in particular, use",
        "    \\l QUrl::fromLocalFile() when loading a file from the local filesystem.",
        "",
        "    Calling this method multiple times with the same url will result",
        "    in the QML component being reinstantiated.",
        " */",
        "void QQuickWidget::setSource(const QUrl\u0026 url)",
        "{",
        "    Q_D(QQuickWidget);",
        "    d-\u003esource \u003d url;",
        "    d-\u003eexecute();",
        "}",
        "",
        "/*!",
        "    \\internal",
        "",
        "    Set the source \\a url, \\a component and content \\a item (root of the QML object hierarchy) directly.",
        " */",
        "void QQuickWidget::setContent(const QUrl\u0026 url, QQmlComponent *component, QObject* item)",
        "{",
        "    Q_D(QQuickWidget);",
        "    d-\u003esource \u003d url;",
        "    d-\u003ecomponent \u003d component;",
        "",
        "    if (d-\u003ecomponent \u0026\u0026 d-\u003ecomponent-\u003eisError()) {",
        "        QList\u003cQQmlError\u003e errorList \u003d d-\u003ecomponent-\u003eerrors();",
        "        foreach (const QQmlError \u0026error, errorList) {",
        "            QMessageLogger(error.url().toString().toLatin1().constData(), error.line(), 0).warning()",
        "                    \u003c\u003c error;",
        "        }",
        "        emit statusChanged(status());",
        "        return;",
        "    }",
        "",
        "    d-\u003esetRootObject(item);",
        "    emit statusChanged(status());",
        "}",
        "",
        "/*!",
        "  Returns the source URL, if set.",
        "",
        "  \\sa setSource()",
        " */",
        "QUrl QQuickWidget::source() const",
        "{",
        "    Q_D(const QQuickWidget);",
        "    return d-\u003esource;",
        "}",
        "",
        "/*!",
        "  Returns a pointer to the QQmlEngine used for instantiating",
        "  QML Components.",
        " */",
        "QQmlEngine* QQuickWidget::engine() const",
        "{",
        "    Q_D(const QQuickWidget);",
        "    return d-\u003eengine ? const_cast\u003cQQmlEngine *\u003e(d-\u003eengine.data()) : 0;",
        "}",
        "",
        "/*!",
        "  This function returns the root of the context hierarchy.  Each QML",
        "  component is instantiated in a QQmlContext.  QQmlContext\u0027s are",
        "  essential for passing data to QML components.  In QML, contexts are",
        "  arranged hierarchically and this hierarchy is managed by the",
        "  QQmlEngine.",
        " */",
        "QQmlContext* QQuickWidget::rootContext() const",
        "{",
        "    Q_D(const QQuickWidget);",
        "    return d-\u003eengine ? d-\u003eengine.data()-\u003erootContext() : 0;",
        "}",
        "",
        "/*!",
        "    \\enum QQuickWidget::Status",
        "    Specifies the loading status of the QQuickWidget.",
        "",
        "    \\value Null This QQuickWidget has no source set.",
        "    \\value Ready This QQuickWidget has loaded and created the QML component.",
        "    \\value Loading This QQuickWidget is loading network data.",
        "    \\value Error One or more errors has occurred. Call errors() to retrieve a list",
        "           of errors.",
        "*/",
        "",
        "/*! \\enum QQuickWidget::ResizeMode",
        "",
        "  This enum specifies how to resize the view.",
        "",
        "  \\value SizeViewToRootObject The view resizes with the root item in the QML.",
        "  \\value SizeRootObjectToView The view will automatically resize the root item to the size of the view.",
        "*/",
        "",
        "/*!"
      ]
    },
    {
      "b": [
        "    \\fn void QQuickWidget::sceneGraphError(QQuickWindow::SceneGraphError error, const QString \u0026message)",
        "",
        "    This signal is emitted when an error occurred during scene graph initialization.",
        "",
        "    Applications should connect to this signal if they wish to handle errors,",
        "    like OpenGL context creation failures, in a custom way. When no slot is",
        "    connected to the signal, the behavior will be different: Quick will print",
        "    the message, or show a message box, and terminate the application.",
        "",
        "    This signal will be emitted from the gui thread.",
        "",
        "    \\sa QQuickWindow::sceneGraphError()",
        " */",
        "",
        "/*!"
      ]
    },
    {
      "ab": [
        "    \\property QQuickWidget::status",
        "    The component\u0027s current \\l{QQuickWidget::Status} {status}.",
        "*/",
        "",
        "QQuickWidget::Status QQuickWidget::status() const",
        "{",
        "    Q_D(const QQuickWidget);",
        "    if (!d-\u003eengine)",
        "        return QQuickWidget::Error;",
        "",
        "    if (!d-\u003ecomponent)",
        "        return QQuickWidget::Null;",
        "",
        "    return QQuickWidget::Status(d-\u003ecomponent-\u003estatus());",
        "}",
        "",
        "/*!",
        "    Return the list of errors that occurred during the last compile or create",
        "    operation.  When the status is not Error, an empty list is returned.",
        "*/",
        "QList\u003cQQmlError\u003e QQuickWidget::errors() const",
        "{",
        "    Q_D(const QQuickWidget);",
        "    QList\u003cQQmlError\u003e errs;",
        "",
        "    if (d-\u003ecomponent)",
        "        errs \u003d d-\u003ecomponent-\u003eerrors();",
        "",
        "    if (!d-\u003eengine) {",
        "        QQmlError error;",
        "        error.setDescription(QLatin1String(\"QQuickWidget: invalid qml engine.\"));",
        "        errs \u003c\u003c error;",
        "    }",
        "",
        "    return errs;",
        "}",
        "",
        "/*!",
        "    \\property QQuickWidget::resizeMode",
        "    \\brief whether the view should resize the window contents",
        "",
        "    If this property is set to SizeViewToRootObject (the default), the view",
        "    resizes to the size of the root item in the QML.",
        "",
        "    If this property is set to SizeRootObjectToView, the view will",
        "    automatically resize the root item to the size of the view.",
        "",
        "    Regardless of this property, the sizeHint of the view",
        "    is the initial size of the root item. Note though that",
        "    since QML may load dynamically, that size may change.",
        "",
        "    \\sa initialSize()",
        "*/",
        "",
        "void QQuickWidget::setResizeMode(ResizeMode mode)",
        "{",
        "    Q_D(QQuickWidget);",
        "    if (d-\u003eresizeMode \u003d\u003d mode)",
        "        return;",
        "",
        "    if (d-\u003eroot) {",
        "        if (d-\u003eresizeMode \u003d\u003d SizeViewToRootObject) {",
        "            QQuickItemPrivate *p \u003d QQuickItemPrivate::get(d-\u003eroot);",
        "            p-\u003eremoveItemChangeListener(d, QQuickItemPrivate::Geometry);",
        "        }",
        "    }",
        "",
        "    d-\u003eresizeMode \u003d mode;",
        "    if (d-\u003eroot) {",
        "        d-\u003einitResize();",
        "    }",
        "}",
        "",
        "void QQuickWidgetPrivate::initResize()",
        "{",
        "    if (root) {",
        "        if (resizeMode \u003d\u003d QQuickWidget::SizeViewToRootObject) {",
        "            QQuickItemPrivate *p \u003d QQuickItemPrivate::get(root);",
        "            p-\u003eaddItemChangeListener(this, QQuickItemPrivate::Geometry);",
        "        }",
        "    }",
        "    updateSize();",
        "}",
        "",
        "void QQuickWidgetPrivate::updateSize()",
        "{",
        "    Q_Q(QQuickWidget);",
        "    if (!root)",
        "        return;",
        "",
        "    if (resizeMode \u003d\u003d QQuickWidget::SizeViewToRootObject) {",
        "        QSize newSize \u003d QSize(root-\u003ewidth(), root-\u003eheight());",
        "        if (newSize.isValid() \u0026\u0026 newSize !\u003d q-\u003esize()) {",
        "            q-\u003eresize(newSize);",
        "        }",
        "    } else if (resizeMode \u003d\u003d QQuickWidget::SizeRootObjectToView) {",
        "        if (!qFuzzyCompare(q-\u003ewidth(), root-\u003ewidth()))",
        "            root-\u003esetWidth(q-\u003ewidth());",
        "        if (!qFuzzyCompare(q-\u003eheight(), root-\u003eheight()))",
        "            root-\u003esetHeight(q-\u003eheight());",
        "    }",
        "}",
        "",
        "QSize QQuickWidgetPrivate::rootObjectSize() const",
        "{",
        "    QSize rootObjectSize(0,0);",
        "    int widthCandidate \u003d -1;",
        "    int heightCandidate \u003d -1;",
        "    if (root) {",
        "        widthCandidate \u003d root-\u003ewidth();",
        "        heightCandidate \u003d root-\u003eheight();",
        "    }",
        "    if (widthCandidate \u003e 0) {",
        "        rootObjectSize.setWidth(widthCandidate);",
        "    }",
        "    if (heightCandidate \u003e 0) {",
        "        rootObjectSize.setHeight(heightCandidate);",
        "    }",
        "    return rootObjectSize;",
        "}",
        ""
      ]
    },
    {
      "b": [
        "void QQuickWidgetPrivate::handleContextCreationFailure(const QSurfaceFormat \u0026format, bool isEs)",
        "{",
        "    Q_Q(QQuickWidget);",
        "",
        "    QString translatedMessage;",
        "    QString untranslatedMessage;",
        "    QQuickWindowPrivate::contextCreationFailureMessage(format, \u0026translatedMessage, \u0026untranslatedMessage, isEs);",
        "",
        "    static const QMetaMethod errorSignal \u003d QMetaMethod::fromSignal(\u0026QQuickWidget::sceneGraphError);",
        "    const bool signalConnected \u003d q-\u003eisSignalConnected(errorSignal);",
        "    if (signalConnected)",
        "        emit q-\u003esceneGraphError(QQuickWindow::ContextNotAvailable, translatedMessage);",
        "",
        "#if defined(Q_OS_WIN) \u0026\u0026 !defined(Q_OS_WINCE) \u0026\u0026 !defined(Q_OS_WINRT)",
        "    if (!signalConnected \u0026\u0026 !QLibraryInfo::isDebugBuild() \u0026\u0026 !GetConsoleWindow())",
        "        QMessageBox::critical(q, QCoreApplication::applicationName(), translatedMessage);",
        "#endif // Q_OS_WIN \u0026\u0026 !Q_OS_WINCE \u0026\u0026 !Q_OS_WINRT",
        "    if (!signalConnected)",
        "        qFatal(\"%s\", qPrintable(untranslatedMessage));",
        "}",
        ""
      ]
    },
    {
      "ab": [
        "void QQuickWidgetPrivate::createContext()",
        "{",
        "    Q_Q(QQuickWidget);",
        "    if (context)",
        "        return;",
        "",
        "    context \u003d new QOpenGLContext;",
        "",
        "    QSurfaceFormat format \u003d q-\u003ewindow()-\u003ewindowHandle()-\u003erequestedFormat();",
        "    QSGRenderContext *renderContext \u003d QQuickWindowPrivate::get(offscreenWindow)-\u003econtext;",
        "    // Depth, stencil, etc. must be set like a QQuickWindow would do.",
        "    QSurfaceFormat sgFormat \u003d renderContext-\u003esceneGraphContext()-\u003edefaultSurfaceFormat();",
        "    format.setDepthBufferSize(qMax(format.depthBufferSize(), sgFormat.depthBufferSize()));",
        "    format.setStencilBufferSize(qMax(format.stencilBufferSize(), sgFormat.stencilBufferSize()));",
        "    format.setAlphaBufferSize(qMax(format.alphaBufferSize(), sgFormat.alphaBufferSize()));",
        "    format.setSwapBehavior(QSurfaceFormat::DoubleBuffer);",
        "    context-\u003esetFormat(format);",
        "",
        "    if (QSGContext::sharedOpenGLContext())",
        "        context-\u003esetShareContext(QSGContext::sharedOpenGLContext()); // ??? is this correct",
        "    if (!context-\u003ecreate()) {"
      ]
    },
    {
      "a": [
        "        qWarning(\"QQuickWidget: failed to create OpenGL context\");"
      ],
      "b": [
        "        const bool isEs \u003d context-\u003eisES();"
      ]
    },
    {
      "ab": [
        "        delete context;",
        "        context \u003d 0;"
      ]
    },
    {
      "b": [
        "        handleContextCreationFailure(format, isEs);",
        "        return;"
      ]
    },
    {
      "ab": [
        "    }",
        "",
        "    Q_ASSERT(q-\u003ewindow()-\u003ewindowHandle()-\u003ehandle());",
        "    if (context-\u003emakeCurrent(q-\u003ewindow()-\u003ewindowHandle()))",
        "        renderControl-\u003einitialize(context);",
        "    else",
        "        qWarning(\"QQuickWidget: failed to make window surface current\");",
        "}",
        "",
        "void QQuickWidget::createFramebufferObject()",
        "{",
        "    Q_D(QQuickWidget);",
        "",
        "    if (d-\u003efbo)",
        "        delete d-\u003efbo;",
        "    QOpenGLContext *context \u003d d-\u003eoffscreenWindow-\u003eopenglContext();",
        "",
        "    if (!context) {",
        "        qWarning(\"QQuickWidget: Attempted to create FBO with no context\");",
        "        return;",
        "    }",
        "",
        "    if (context-\u003eshareContext() !\u003d QWidgetPrivate::get(window())-\u003eshareContext()) {",
        "        context-\u003esetShareContext(QWidgetPrivate::get(window())-\u003eshareContext());",
        "        context-\u003ecreate();",
        "    }",
        "",
        "    Q_ASSERT(window()-\u003ewindowHandle()-\u003ehandle());",
        "    context-\u003emakeCurrent(window()-\u003ewindowHandle());",
        "    d-\u003efbo \u003d new QOpenGLFramebufferObject(size());",
        "    d-\u003efbo-\u003esetAttachment(QOpenGLFramebufferObject::CombinedDepthStencil);",
        "    d-\u003eoffscreenWindow-\u003esetRenderTarget(d-\u003efbo);",
        "",
        "    // Sanity check: The window must not have an underlying platform window.",
        "    // Having one would mean create() was called and platforms that only support",
        "    // a single native window were in trouble.",
        "    Q_ASSERT(!d-\u003eoffscreenWindow-\u003ehandle());",
        "}",
        "",
        "void QQuickWidget::destroyFramebufferObject()",
        "{",
        "    Q_D(QQuickWidget);",
        "    if (d-\u003efbo)",
        "        delete d-\u003efbo;",
        "    d-\u003efbo \u003d 0;",
        "}",
        "",
        "QQuickWidget::ResizeMode QQuickWidget::resizeMode() const",
        "{",
        "    Q_D(const QQuickWidget);",
        "    return d-\u003eresizeMode;",
        "}",
        "",
        "/*!",
        "  \\internal",
        " */",
        "void QQuickWidget::continueExecute()",
        "{",
        "    Q_D(QQuickWidget);",
        "    disconnect(d-\u003ecomponent, SIGNAL(statusChanged(QQmlComponent::Status)), this, SLOT(continueExecute()));",
        "",
        "    if (d-\u003ecomponent-\u003eisError()) {",
        "        QList\u003cQQmlError\u003e errorList \u003d d-\u003ecomponent-\u003eerrors();",
        "        foreach (const QQmlError \u0026error, errorList) {",
        "            QMessageLogger(error.url().toString().toLatin1().constData(), error.line(), 0).warning()",
        "                    \u003c\u003c error;",
        "        }",
        "        emit statusChanged(status());",
        "        return;",
        "    }",
        "",
        "    QObject *obj \u003d d-\u003ecomponent-\u003ecreate();",
        "",
        "    if (d-\u003ecomponent-\u003eisError()) {",
        "        QList\u003cQQmlError\u003e errorList \u003d d-\u003ecomponent-\u003eerrors();",
        "        foreach (const QQmlError \u0026error, errorList) {",
        "            QMessageLogger(error.url().toString().toLatin1().constData(), error.line(), 0).warning()",
        "                    \u003c\u003c error;",
        "        }",
        "        emit statusChanged(status());",
        "        return;",
        "    }",
        "",
        "    d-\u003esetRootObject(obj);",
        "    emit statusChanged(status());",
        "}",
        "",
        "",
        "/*!",
        "  \\internal",
        "*/",
        "void QQuickWidgetPrivate::setRootObject(QObject *obj)",
        "{",
        "    Q_Q(QQuickWidget);",
        "    if (root \u003d\u003d obj)",
        "        return;",
        "    if (QQuickItem *sgItem \u003d qobject_cast\u003cQQuickItem *\u003e(obj)) {",
        "        root \u003d sgItem;",
        "        sgItem-\u003esetParentItem(offscreenWindow-\u003econtentItem());",
        "    } else {",
        "        qWarning() \u003c\u003c \"QQuickWidget only supports loading of root objects that derive from QQuickItem.\" \u003c\u003c endl",
        "                   \u003c\u003c endl",
        "                   \u003c\u003c \"If your example is using QML 2, (such as qmlscene) and the .qml file you\" \u003c\u003c endl",
        "                   \u003c\u003c \"loaded has \u0027import QtQuick 1.0\u0027 or \u0027import Qt 4.7\u0027, this error will occur.\" \u003c\u003c endl",
        "                   \u003c\u003c endl",
        "                   \u003c\u003c \"To load files with \u0027import QtQuick 1.0\u0027 or \u0027import Qt 4.7\u0027, use the\" \u003c\u003c endl",
        "                   \u003c\u003c \"QDeclarativeView class in the Qt Quick 1 module.\" \u003c\u003c endl;",
        "        delete obj;",
        "        root \u003d 0;",
        "    }",
        "    if (root) {",
        "        initialSize \u003d rootObjectSize();",
        "        if ((resizeMode \u003d\u003d QQuickWidget::SizeViewToRootObject || q-\u003ewidth() \u003c\u003d 1 || q-\u003eheight() \u003c\u003d 1) \u0026\u0026",
        "            initialSize !\u003d q-\u003esize()) {",
        "            q-\u003eresize(initialSize);",
        "        }",
        "        initResize();",
        "    }",
        "}",
        "",
        "GLuint QQuickWidgetPrivate::textureId() const",
        "{",
        "    return fbo ? fbo-\u003etexture() : 0;",
        "}",
        "",
        "/*!",
        "  \\internal",
        "  If the \\l {QTimerEvent} {timer event} \\a e is this",
        "  view\u0027s resize timer, sceneResized() is emitted.",
        " */",
        "void QQuickWidget::timerEvent(QTimerEvent* e)",
        "{",
        "    Q_D(QQuickWidget);",
        "    if (!e || e-\u003etimerId() \u003d\u003d d-\u003eresizetimer.timerId()) {",
        "        d-\u003eupdateSize();",
        "        d-\u003eresizetimer.stop();",
        "    }",
        "}",
        "",
        "/*!",
        "    \\internal",
        "    Preferred size follows the root object geometry.",
        "*/",
        "QSize QQuickWidget::sizeHint() const",
        "{",
        "    Q_D(const QQuickWidget);",
        "    QSize rootObjectSize \u003d d-\u003erootObjectSize();",
        "    if (rootObjectSize.isEmpty()) {",
        "        return size();",
        "    } else {",
        "        return rootObjectSize;",
        "    }",
        "}",
        "",
        "/*!",
        "  Returns the initial size of the root object.",
        "",
        "  If \\l resizeMode is QQuickItem::SizeRootObjectToView the root object will be",
        "  resized to the size of the view.  initialSize contains the size of the",
        "  root object before it was resized.",
        "*/",
        "QSize QQuickWidget::initialSize() const",
        "{",
        "    Q_D(const QQuickWidget);",
        "    return d-\u003einitialSize;",
        "}",
        "",
        "/*!",
        "  Returns the view\u0027s root \\l {QQuickItem} {item}.",
        " */",
        "QQuickItem *QQuickWidget::rootObject() const",
        "{",
        "    Q_D(const QQuickWidget);",
        "    return d-\u003eroot;",
        "}",
        "",
        "/*!",
        "  \\internal",
        "  This function handles the \\l {QResizeEvent} {resize event}",
        "  \\a e.",
        " */",
        "void QQuickWidget::resizeEvent(QResizeEvent *e)",
        "{",
        "    Q_D(QQuickWidget);",
        "    if (d-\u003eresizeMode \u003d\u003d SizeRootObjectToView)",
        "        d-\u003eupdateSize();",
        "",
        "    d-\u003ecreateContext();",
        "    createFramebufferObject();",
        "    d-\u003eoffscreenWindow-\u003eresizeEvent(e);",
        "    d-\u003eoffscreenWindow-\u003esetGeometry(0, 0, e-\u003esize().width(), e-\u003esize().height());",
        "",
        "    QOpenGLContext *context \u003d d-\u003eoffscreenWindow-\u003eopenglContext();",
        "    if (!context) {",
        "        qWarning(\"QQuickWidget::resizeEvent() no OpenGL context\");",
        "        return;",
        "    }",
        "",
        "    Q_ASSERT(window()-\u003ewindowHandle()-\u003ehandle());",
        "    context-\u003emakeCurrent(window()-\u003ewindowHandle());",
        "    d-\u003erenderControl-\u003erender();",
        "    glFlush();",
        "    context-\u003edoneCurrent();",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWidget::keyPressEvent(QKeyEvent *e)",
        "{",
        "    Q_D(QQuickWidget);",
        "    Q_QUICK_PROFILE(addEvent\u003cQQuickProfiler::Key\u003e());",
        "",
        "    d-\u003eoffscreenWindow-\u003ekeyPressEvent(e);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWidget::keyReleaseEvent(QKeyEvent *e)",
        "{",
        "    Q_D(QQuickWidget);",
        "    Q_QUICK_PROFILE(addEvent\u003cQQuickProfiler::Key\u003e());",
        "",
        "    d-\u003eoffscreenWindow-\u003ekeyReleaseEvent(e);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWidget::mouseMoveEvent(QMouseEvent *e)",
        "{",
        "    Q_D(QQuickWidget);",
        "    Q_QUICK_PROFILE(addEvent\u003cQQuickProfiler::Mouse\u003e());",
        "",
        "    // Use the constructor taking localPos and screenPos. That puts localPos into the",
        "    // event\u0027s localPos and windowPos, and screenPos into the event\u0027s screenPos. This way",
        "    // the windowPos in e is ignored and is replaced by localPos. This is necessary",
        "    // because QQuickWindow thinks of itself as a top-level window always.",
        "    QMouseEvent mappedEvent(e-\u003etype(), e-\u003elocalPos(), e-\u003escreenPos(), e-\u003ebutton(), e-\u003ebuttons(), e-\u003emodifiers());",
        "    d-\u003eoffscreenWindow-\u003emouseMoveEvent(\u0026mappedEvent);",
        "}",
        "",
        "void QQuickWidget::mouseDoubleClickEvent(QMouseEvent *e)",
        "{",
        "    Q_D(QQuickWidget);",
        "    Q_QUICK_PROFILE(addEvent\u003cQQuickProfiler::Mouse\u003e());",
        "",
        "    // As the second mouse press is suppressed in widget windows we emulate it here for QML.",
        "    // See QTBUG-25831",
        "    QMouseEvent pressEvent(QEvent::MouseButtonPress, e-\u003elocalPos(), e-\u003escreenPos(), e-\u003ebutton(),",
        "                           e-\u003ebuttons(), e-\u003emodifiers());",
        "    d-\u003eoffscreenWindow-\u003emousePressEvent(\u0026pressEvent);",
        "    QMouseEvent mappedEvent(e-\u003etype(), e-\u003elocalPos(), e-\u003escreenPos(), e-\u003ebutton(), e-\u003ebuttons(),",
        "                            e-\u003emodifiers());",
        "    d-\u003eoffscreenWindow-\u003emouseDoubleClickEvent(\u0026mappedEvent);",
        "}",
        "",
        "void QQuickWidget::showEvent(QShowEvent *)",
        "{",
        "    Q_D(QQuickWidget);",
        "    QQuickWindowPrivate::get(d-\u003eoffscreenWindow)-\u003eforceRendering \u003d true;",
        "",
        "    d-\u003eupdatePending \u003d false;",
        "    triggerUpdate();",
        "}",
        "",
        "void QQuickWidget::hideEvent(QHideEvent *)",
        "{",
        "    Q_D(QQuickWidget);",
        "    QQuickWindowPrivate::get(d-\u003eoffscreenWindow)-\u003eforceRendering \u003d false;",
        "",
        "    QOpenGLContext *context \u003d d-\u003eoffscreenWindow-\u003eopenglContext();",
        "    if (!context) {",
        "        qWarning(\"QQuickWidget::hideEvent with no context\");",
        "        return;",
        "    }",
        "    context-\u003emakeCurrent(d-\u003eoffscreenWindow);",
        "    d-\u003erenderControl-\u003estop();",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWidget::mousePressEvent(QMouseEvent *e)",
        "{",
        "    Q_D(QQuickWidget);",
        "    Q_QUICK_PROFILE(addEvent\u003cQQuickProfiler::Mouse\u003e());",
        "",
        "    QMouseEvent mappedEvent(e-\u003etype(), e-\u003elocalPos(), e-\u003escreenPos(), e-\u003ebutton(), e-\u003ebuttons(), e-\u003emodifiers());",
        "    d-\u003eoffscreenWindow-\u003emousePressEvent(\u0026mappedEvent);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWidget::mouseReleaseEvent(QMouseEvent *e)",
        "{",
        "    Q_D(QQuickWidget);",
        "    Q_QUICK_PROFILE(addEvent\u003cQQuickProfiler::Mouse\u003e());",
        "",
        "    QMouseEvent mappedEvent(e-\u003etype(), e-\u003elocalPos(), e-\u003escreenPos(), e-\u003ebutton(), e-\u003ebuttons(), e-\u003emodifiers());",
        "    d-\u003eoffscreenWindow-\u003emouseReleaseEvent(\u0026mappedEvent);",
        "}",
        "",
        "#ifndef QT_NO_WHEELEVENT",
        "/*! \\reimp */",
        "void QQuickWidget::wheelEvent(QWheelEvent *e)",
        "{",
        "    Q_D(QQuickWidget);",
        "    Q_QUICK_PROFILE(addEvent\u003cQQuickProfiler::Mouse\u003e());",
        "",
        "    // Wheel events only have local and global positions, no need to map.",
        "    d-\u003eoffscreenWindow-\u003ewheelEvent(e);",
        "}",
        "#endif",
        "",
        "/*! \\reimp */",
        "bool QQuickWidget::event(QEvent *e)",
        "{",
        "    Q_D(QQuickWidget);",
        "",
        "    switch (e-\u003etype()) {",
        "    case QEvent::Timer:",
        "        d-\u003eeventPending \u003d false;",
        "        killTimer(d-\u003eupdateTimer);",
        "        d-\u003eupdateTimer \u003d 0;",
        "        if (d-\u003eupdatePending)",
        "            d-\u003erenderSceneGraph();",
        "        return true;",
        "",
        "    case QEvent::TouchBegin:",
        "    case QEvent::TouchEnd:",
        "    case QEvent::TouchUpdate:",
        "    case QEvent::TouchCancel:",
        "        // Touch events only have local and global positions, no need to map.",
        "        return d-\u003eoffscreenWindow-\u003eevent(e);",
        "",
        "    default:",
        "        break;",
        "    }",
        "",
        "    return QWidget::event(e);",
        "}",
        "",
        "",
        "// TODO: try to separate the two cases of",
        "// 1. render() unconditionally without sync",
        "// 2. sync() and then render if necessary",
        "void QQuickWidget::triggerUpdate()",
        "{",
        "    Q_D(QQuickWidget);",
        "    d-\u003eupdatePending \u003d true;",
        "     if (!d-\u003eeventPending) {",
        "        const int exhaustDelay \u003d 5;",
        "        d-\u003eupdateTimer \u003d startTimer(exhaustDelay, Qt::PreciseTimer);",
        "        d-\u003eeventPending \u003d true;",
        "    }",
        "}",
        "",
        "QT_END_NAMESPACE",
        ""
      ]
    }
  ]
}
