{
  "meta_a": {
    "name": "src/quick/items/qquickwindow.cpp",
    "content_type": "text/x-c++src",
    "lines": 3572,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003d1a38f519cbc0890d8f0163ab35c140592ab204ac;f\u003dsrc%2Fquick%2Fitems%2Fqquickwindow.cpp"
      }
    ]
  },
  "meta_b": {
    "name": "src/quick/items/qquickwindow.cpp",
    "content_type": "text/x-c++src",
    "lines": 3603,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003drefs%2Fchanges%2F73%2F79973%2F5;f\u003dsrc%2Fquick%2Fitems%2Fqquickwindow.cpp"
      }
    ]
  },
  "change_type": "MODIFIED",
  "diff_header": [
    "diff --git a/src/quick/items/qquickwindow.cpp b/src/quick/items/qquickwindow.cpp",
    "index bbc4e8b..28b2bbc 100644",
    "--- a/src/quick/items/qquickwindow.cpp",
    "+++ b/src/quick/items/qquickwindow.cpp"
  ],
  "content": [
    {
      "ab": [
        "/****************************************************************************",
        "**",
        "** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).",
        "** Contact: http://www.qt-project.org/legal",
        "**",
        "** This file is part of the QtQuick module of the Qt Toolkit.",
        "**",
        "** $QT_BEGIN_LICENSE:LGPL$",
        "** Commercial License Usage",
        "** Licensees holding valid commercial Qt licenses may use this file in",
        "** accordance with the commercial license agreement provided with the",
        "** Software or, alternatively, in accordance with the terms contained in",
        "** a written agreement between you and Digia.  For licensing terms and",
        "** conditions see http://qt.digia.com/licensing.  For further information",
        "** use the contact form at http://qt.digia.com/contact-us.",
        "**",
        "** GNU Lesser General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU Lesser",
        "** General Public License version 2.1 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.LGPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU Lesser General Public License version 2.1 requirements",
        "** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.",
        "**",
        "** In addition, as a special exception, Digia gives you certain additional",
        "** rights.  These rights are described in the Digia Qt LGPL Exception",
        "** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.",
        "**",
        "** GNU General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU",
        "** General Public License version 3.0 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.GPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU General Public License version 3.0 requirements will be",
        "** met: http://www.gnu.org/copyleft/gpl.html.",
        "**",
        "**",
        "** $QT_END_LICENSE$",
        "**",
        "****************************************************************************/",
        "",
        "#include \"qquickwindow.h\"",
        "#include \"qquickwindow_p.h\"",
        "",
        "#include \"qquickitem.h\"",
        "#include \"qquickitem_p.h\"",
        "#include \"qquickevents_p_p.h\"",
        "",
        "#include \u003cprivate/qquickdrag_p.h\u003e",
        "",
        "#include \u003cQtQuick/private/qsgrenderer_p.h\u003e",
        "#include \u003cQtQuick/private/qsgtexture_p.h\u003e",
        "#include \u003cprivate/qsgrenderloop_p.h\u003e",
        "#include \u003cprivate/qquickrendercontrol_p.h\u003e",
        "#include \u003cprivate/qquickanimatorcontroller_p.h\u003e",
        "",
        "#include \u003cprivate/qguiapplication_p.h\u003e",
        "#include \u003cQtGui/QInputMethod\u003e",
        "",
        "#include \u003cprivate/qabstractanimation_p.h\u003e",
        "",
        "#include \u003cQtGui/qpainter.h\u003e",
        "#include \u003cQtGui/qevent.h\u003e",
        "#include \u003cQtGui/qmatrix4x4.h\u003e",
        "#include \u003cQtGui/qstylehints.h\u003e",
        "#include \u003cQtCore/qvarlengtharray.h\u003e",
        "#include \u003cQtCore/qabstractanimation.h\u003e"
      ]
    },
    {
      "b": [
        "#include \u003cQtCore/QLibraryInfo\u003e"
      ]
    },
    {
      "ab": [
        "#include \u003cQtQml/qqmlincubator.h\u003e",
        "",
        "#include \u003cQtQuick/private/qquickpixmapcache_p.h\u003e",
        "",
        "#include \u003cprivate/qqmlprofilerservice_p.h\u003e",
        "#include \u003cprivate/qqmlmemoryprofiler_p.h\u003e",
        "",
        "QT_BEGIN_NAMESPACE",
        "",
        "extern Q_GUI_EXPORT QImage qt_gl_read_framebuffer(const QSize \u0026size, bool alpha_format, bool include_alpha);",
        "",
        "bool QQuickWindowPrivate::defaultAlphaBuffer(0);",
        "",
        "void QQuickWindowPrivate::updateFocusItemTransform()",
        "{",
        "    Q_Q(QQuickWindow);",
        "#ifndef QT_NO_IM",
        "    QQuickItem *focus \u003d q-\u003eactiveFocusItem();",
        "    if (focus \u0026\u0026 qApp-\u003efocusObject() \u003d\u003d focus) {",
        "        QQuickItemPrivate *focusPrivate \u003d QQuickItemPrivate::get(focus);",
        "        qApp-\u003einputMethod()-\u003esetInputItemTransform(focusPrivate-\u003eitemToWindowTransform());",
        "        qApp-\u003einputMethod()-\u003esetInputItemRectangle(QRectF(0, 0, focusPrivate-\u003ewidth, focusPrivate-\u003eheight));",
        "    }",
        "#endif",
        "}",
        "",
        "class QQuickWindowIncubationController : public QObject, public QQmlIncubationController",
        "{",
        "    Q_OBJECT",
        "",
        "public:",
        "    QQuickWindowIncubationController(QSGRenderLoop *loop)",
        "        : m_renderLoop(loop), m_timer(0)",
        "    {",
        "        // Allow incubation for 1/3 of a frame.",
        "        m_incubation_time \u003d qMax(1, int(1000 / QGuiApplication::primaryScreen()-\u003erefreshRate()) / 3);",
        "",
        "        m_animation_driver \u003d m_renderLoop-\u003eanimationDriver();",
        "        if (m_animation_driver) {",
        "            connect(m_animation_driver, SIGNAL(stopped()), this, SLOT(animationStopped()));",
        "            connect(m_renderLoop, SIGNAL(timeToIncubate()), this, SLOT(incubate()));",
        "        }",
        "    }",
        "",
        "protected:",
        "    void timerEvent(QTimerEvent *)",
        "    {",
        "        killTimer(m_timer);",
        "        m_timer \u003d 0;",
        "        incubate();",
        "    }",
        "",
        "    void incubateAgain() {",
        "        if (m_timer \u003d\u003d 0) {",
        "            // Wait for a while before processing the next batch. Using a",
        "            // timer to avoid starvation of system events.",
        "            m_timer \u003d startTimer(m_incubation_time);",
        "        }",
        "    }",
        "",
        "public slots:",
        "    void incubate() {",
        "        if (incubatingObjectCount()) {",
        "            if (m_renderLoop-\u003einterleaveIncubation()) {",
        "                incubateFor(m_incubation_time);",
        "            } else {",
        "                incubateFor(m_incubation_time * 2);",
        "                if (incubatingObjectCount())",
        "                    incubateAgain();",
        "            }",
        "        }",
        "    }",
        "",
        "    void animationStopped() { incubate(); }",
        "",
        "protected:",
        "    virtual void incubatingObjectCountChanged(int count)",
        "    {",
        "        if (count \u0026\u0026 !m_renderLoop-\u003einterleaveIncubation())",
        "            incubateAgain();",
        "    }",
        "",
        "private:",
        "    QSGRenderLoop *m_renderLoop;",
        "    int m_incubation_time;",
        "    QAnimationDriver *m_animation_driver;",
        "    int m_timer;",
        "};",
        "",
        "#include \"qquickwindow.moc\"",
        "",
        "",
        "#ifndef QT_NO_ACCESSIBILITY",
        "/*!",
        "    Returns an accessibility interface for this window, or 0 if such an",
        "    interface cannot be created.",
        "*/",
        "QAccessibleInterface *QQuickWindow::accessibleRoot() const",
        "{",
        "    return QAccessible::queryAccessibleInterface(const_cast\u003cQQuickWindow*\u003e(this));",
        "}",
        "#endif",
        "",
        "",
        "/*",
        "Focus behavior",
        "\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d",
        "",
        "Prior to being added to a valid window items can set and clear focus with no",
        "effect.  Only once items are added to a window (by way of having a parent set that",
        "already belongs to a window) do the focus rules apply.  Focus goes back to",
        "having no effect if an item is removed from a window.",
        "",
        "When an item is moved into a new focus scope (either being added to a window",
        "for the first time, or having its parent changed), if the focus scope already has",
        "a scope focused item that takes precedence over the item being added.  Otherwise,",
        "the focus of the added tree is used.  In the case of of a tree of items being",
        "added to a window for the first time, which may have a conflicted focus state (two",
        "or more items in one scope having focus set), the same rule is applied item by item -",
        "thus the first item that has focus will get it (assuming the scope doesn\u0027t already",
        "have a scope focused item), and the other items will have their focus cleared.",
        "*/",
        "",
        "",
        "// #define FOCUS_DEBUG",
        "// #define MOUSE_DEBUG",
        "// #define TOUCH_DEBUG",
        "// #define DIRTY_DEBUG",
        "",
        "#ifdef FOCUS_DEBUG",
        "void printFocusTree(QQuickItem *item, QQuickItem *scope \u003d 0, int depth \u003d 1);",
        "#endif",
        "",
        "QQuickItem::UpdatePaintNodeData::UpdatePaintNodeData()",
        ": transformNode(0)",
        "{",
        "}",
        "",
        "QQuickRootItem::QQuickRootItem()",
        "{",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::exposeEvent(QExposeEvent *)",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (d-\u003ewindowManager)",
        "        d-\u003ewindowManager-\u003eexposureChanged(this);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::resizeEvent(QResizeEvent *ev)",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (d-\u003econtentItem)",
        "        d-\u003econtentItem-\u003esetSize(ev-\u003esize());",
        "    if (d-\u003ewindowManager)",
        "        d-\u003ewindowManager-\u003eresize(this);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::showEvent(QShowEvent *)",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (d-\u003ewindowManager)",
        "        d-\u003ewindowManager-\u003eshow(this);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::hideEvent(QHideEvent *)",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (d-\u003ewindowManager)",
        "        d-\u003ewindowManager-\u003ehide(this);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::focusOutEvent(QFocusEvent *ev)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003econtentItem-\u003esetFocus(false, ev-\u003ereason());",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::focusInEvent(QFocusEvent *ev)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003econtentItem-\u003esetFocus(true, ev-\u003ereason());",
        "    d-\u003eupdateFocusItemTransform();",
        "}",
        "",
        "void QQuickWindowPrivate::polishItems()",
        "{",
        "    int maxPolishCycles \u003d 100000;",
        "",
        "    while (!itemsToPolish.isEmpty() \u0026\u0026 --maxPolishCycles \u003e 0) {",
        "        QSet\u003cQQuickItem *\u003e itms \u003d itemsToPolish;",
        "        itemsToPolish.clear();",
        "",
        "        for (QSet\u003cQQuickItem *\u003e::iterator it \u003d itms.begin(); it !\u003d itms.end(); ++it) {",
        "            QQuickItem *item \u003d *it;",
        "            QQuickItemPrivate::get(item)-\u003epolishScheduled \u003d false;",
        "            item-\u003eupdatePolish();",
        "        }",
        "    }",
        "",
        "    if (maxPolishCycles \u003d\u003d 0)",
        "        qWarning(\"QQuickWindow: possible QQuickItem::polish() loop\");",
        "",
        "    updateFocusItemTransform();",
        "}",
        "",
        "/*!",
        " * Schedules the window to render another frame.",
        " *",
        " * Calling QQuickWindow::update() differs from QQuickItem::update() in that",
        " * it always triggers a repaint, regardless of changes in the underlying",
        " * scene graph or not.",
        " */",
        "void QQuickWindow::update()",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (d-\u003ewindowManager)",
        "        d-\u003ewindowManager-\u003eupdate(this);",
        "    else",
        "        d-\u003erenderControl-\u003eupdate();",
        "}",
        "",
        "void forcePolishHelper(QQuickItem *item)",
        "{",
        "    if (item-\u003eflags() \u0026 QQuickItem::ItemHasContents) {",
        "        item-\u003epolish();",
        "    }",
        "",
        "    QList \u003cQQuickItem *\u003e items \u003d item-\u003echildItems();",
        "    for (int i\u003d0; i\u003citems.size(); ++i)",
        "        forcePolishHelper(items.at(i));",
        "}",
        "",
        "/*!",
        "    Schedules polish events on all items in the scene.",
        "*/",
        "void QQuickWindow::forcePolish()",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (!screen())",
        "        return;",
        "    forcePolishHelper(d-\u003econtentItem);",
        "}",
        "",
        "void forceUpdate(QQuickItem *item)",
        "{",
        "    if (item-\u003eflags() \u0026 QQuickItem::ItemHasContents)",
        "        item-\u003eupdate();",
        "    QQuickItemPrivate::get(item)-\u003edirty(QQuickItemPrivate::ChildrenUpdateMask);",
        "",
        "    QList \u003cQQuickItem *\u003e items \u003d item-\u003echildItems();",
        "    for (int i\u003d0; i\u003citems.size(); ++i)",
        "        forceUpdate(items.at(i));",
        "}",
        "",
        "void QQuickWindowPrivate::syncSceneGraph()",
        "{",
        "    QML_MEMORY_SCOPE_STRING(\"SceneGraph\");",
        "    Q_Q(QQuickWindow);",
        "",
        "    animationController-\u003ebeforeNodeSync();",
        "",
        "    emit q-\u003ebeforeSynchronizing();",
        "    if (!renderer) {",
        "        forceUpdate(contentItem);",
        "",
        "        QSGRootNode *rootNode \u003d new QSGRootNode;",
        "        rootNode-\u003eappendChildNode(QQuickItemPrivate::get(contentItem)-\u003eitemNode());",
        "        renderer \u003d context-\u003ecreateRenderer();",
        "        renderer-\u003esetRootNode(rootNode);",
        "    }",
        "",
        "    updateDirtyNodes();",
        "",
        "    animationController-\u003eafterNodeSync();",
        "",
        "    // Copy the current state of clearing from window into renderer.",
        "    renderer-\u003esetClearColor(clearColor);",
        "    QSGRenderer::ClearMode mode \u003d QSGRenderer::ClearStencilBuffer | QSGRenderer::ClearDepthBuffer;",
        "    if (clearBeforeRendering)",
        "        mode |\u003d QSGRenderer::ClearColorBuffer;",
        "    renderer-\u003esetClearMode(mode);",
        "",
        "    renderer-\u003esetCustomRenderMode(customRenderMode);",
        "",
        "    emit q-\u003eafterSynchronizing();",
        "    context-\u003eendSync();",
        "}",
        "",
        "",
        "void QQuickWindowPrivate::renderSceneGraph(const QSize \u0026size)",
        "{",
        "    QML_MEMORY_SCOPE_STRING(\"SceneGraph\");",
        "    Q_Q(QQuickWindow);",
        "    if (!renderer)",
        "        return;",
        "",
        "    animationController-\u003eadvance();",
        "    emit q-\u003ebeforeRendering();",
        "    int fboId \u003d 0;",
        "    const qreal devicePixelRatio \u003d q-\u003edevicePixelRatio();",
        "    renderer-\u003esetDeviceRect(QRect(QPoint(0, 0), size * devicePixelRatio));",
        "    if (renderTargetId) {",
        "        fboId \u003d renderTargetId;",
        "        renderer-\u003esetViewportRect(QRect(QPoint(0, 0), renderTargetSize));",
        "    } else {",
        "        renderer-\u003esetViewportRect(QRect(QPoint(0, 0), size * devicePixelRatio));",
        "    }",
        "    renderer-\u003esetProjectionMatrixToRect(QRect(QPoint(0, 0), size));",
        "    renderer-\u003esetDevicePixelRatio(q-\u003edevicePixelRatio());",
        "",
        "    context-\u003erenderNextFrame(renderer, fboId);",
        "    emit q-\u003eafterRendering();",
        "}",
        "",
        "QQuickWindowPrivate::QQuickWindowPrivate()",
        "    : contentItem(0)",
        "    , activeFocusItem(0)",
        "    , mouseGrabberItem(0)",
        "#ifndef QT_NO_CURSOR",
        "    , cursorItem(0)",
        "#endif",
        "#ifndef QT_NO_DRAGANDDROP",
        "    , dragGrabber(0)",
        "#endif",
        "    , touchMouseId(-1)",
        "    , touchMousePressTimestamp(0)",
        "    , dirtyItemList(0)",
        "    , context(0)",
        "    , renderer(0)",
        "    , windowManager(0)",
        "    , renderControl(0)",
        "    , clearColor(Qt::white)",
        "    , clearBeforeRendering(true)",
        "    , persistentGLContext(true)",
        "    , persistentSceneGraph(true)",
        "    , lastWheelEventAccepted(false)",
        "    , componentCompleted(true)",
        "    , forceRendering(false)",
        "    , renderTarget(0)",
        "    , renderTargetId(0)",
        "    , incubationController(0)",
        "{",
        "#ifndef QT_NO_DRAGANDDROP",
        "    dragGrabber \u003d new QQuickDragGrabber;",
        "#endif",
        "}",
        "",
        "QQuickWindowPrivate::~QQuickWindowPrivate()",
        "{",
        "}",
        "",
        "void QQuickWindowPrivate::init(QQuickWindow *c, QQuickRenderControl *control)",
        "{",
        "    q_ptr \u003d c;",
        "",
        "    Q_Q(QQuickWindow);",
        "",
        "    contentItem \u003d new QQuickRootItem;",
        "    QQmlEngine::setObjectOwnership(contentItem, QQmlEngine::CppOwnership);",
        "    QQuickItemPrivate *contentItemPrivate \u003d QQuickItemPrivate::get(contentItem);",
        "    contentItemPrivate-\u003ewindow \u003d q;",
        "    contentItemPrivate-\u003ewindowRefCount \u003d 1;",
        "    contentItemPrivate-\u003eflags |\u003d QQuickItem::ItemIsFocusScope;",
        "    contentItem-\u003esetSize(q-\u003esize());",
        "",
        "    customRenderMode \u003d qgetenv(\"QSG_VISUALIZE\");",
        "    renderControl \u003d control;",
        "    if (renderControl)",
        "        renderControl-\u003esetWindow(q);",
        "",
        "    if (!renderControl)",
        "        windowManager \u003d QSGRenderLoop::instance();",
        "",
        "    Q_ASSERT(windowManager || renderControl);",
        "",
        "    QSGContext *sg;",
        "    if (renderControl) {",
        "        sg \u003d renderControl-\u003esceneGraphContext();",
        "        context \u003d renderControl-\u003erenderContext(sg);",
        "    } else {",
        "        sg \u003d windowManager-\u003esceneGraphContext();",
        "        context \u003d windowManager-\u003ecreateRenderContext(sg);",
        "    }",
        "",
        "    q-\u003esetSurfaceType(QWindow::OpenGLSurface);",
        "    q-\u003esetFormat(sg-\u003edefaultSurfaceFormat());",
        "",
        "    animationController \u003d new QQuickAnimatorController();",
        "    animationController-\u003em_window \u003d q;",
        "",
        "    QObject::connect(context, SIGNAL(initialized()), q, SIGNAL(sceneGraphInitialized()), Qt::DirectConnection);",
        "    QObject::connect(context, SIGNAL(invalidated()), q, SIGNAL(sceneGraphInvalidated()), Qt::DirectConnection);",
        "    QObject::connect(context, SIGNAL(invalidated()), q, SLOT(cleanupSceneGraph()), Qt::DirectConnection);",
        "",
        "    QObject::connect(q, SIGNAL(focusObjectChanged(QObject*)), q, SIGNAL(activeFocusItemChanged()));",
        "    QObject::connect(q, SIGNAL(screenChanged(QScreen*)), q, SLOT(forcePolish()));",
        "}",
        "",
        "/*!",
        "    \\property QQuickWindow::data",
        "    \\internal",
        "*/",
        "",
        "QQmlListProperty\u003cQObject\u003e QQuickWindowPrivate::data()",
        "{",
        "    return QQmlListProperty\u003cQObject\u003e(q_func(), 0, QQuickWindowPrivate::data_append,",
        "                                             QQuickWindowPrivate::data_count,",
        "                                             QQuickWindowPrivate::data_at,",
        "                                             QQuickWindowPrivate::data_clear);",
        "}",
        "",
        "static QMouseEvent *touchToMouseEvent(QEvent::Type type, const QTouchEvent::TouchPoint \u0026p, QTouchEvent *event, QQuickItem *item, bool transformNeeded \u003d true)",
        "{",
        "    // The touch point local position and velocity are not yet transformed.",
        "    QMouseEvent *me \u003d new QMouseEvent(type, transformNeeded ? item-\u003emapFromScene(p.scenePos()) : p.pos(), p.scenePos(), p.screenPos(),",
        "                                      Qt::LeftButton, (type \u003d\u003d QEvent::MouseButtonRelease ? Qt::NoButton : Qt::LeftButton), event-\u003emodifiers());",
        "    me-\u003esetAccepted(true);",
        "    me-\u003esetTimestamp(event-\u003etimestamp());",
        "    QVector2D transformedVelocity \u003d p.velocity();",
        "    if (transformNeeded) {",
        "        QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "        QMatrix4x4 transformMatrix(itemPrivate-\u003ewindowToItemTransform());",
        "        transformedVelocity \u003d transformMatrix.mapVector(p.velocity()).toVector2D();",
        "    }",
        "    QGuiApplicationPrivate::setMouseEventCapsAndVelocity(me, event-\u003edevice()-\u003ecapabilities(), transformedVelocity);",
        "    QGuiApplicationPrivate::setMouseEventSource(me, Qt::MouseEventSynthesizedByQt);",
        "    return me;",
        "}",
        "",
        "bool QQuickWindowPrivate::checkIfDoubleClicked(ulong newPressEventTimestamp)",
        "{",
        "    bool doubleClicked;",
        "",
        "    if (touchMousePressTimestamp \u003d\u003d 0) {",
        "        // just initialize the variable",
        "        touchMousePressTimestamp \u003d newPressEventTimestamp;",
        "        doubleClicked \u003d false;",
        "    } else {",
        "        ulong timeBetweenPresses \u003d newPressEventTimestamp - touchMousePressTimestamp;",
        "        ulong doubleClickInterval \u003d static_cast\u003culong\u003e(qApp-\u003estyleHints()-\u003e",
        "                mouseDoubleClickInterval());",
        "        doubleClicked \u003d timeBetweenPresses \u003c doubleClickInterval;",
        "        if (doubleClicked) {",
        "            touchMousePressTimestamp \u003d 0;",
        "        } else {",
        "            touchMousePressTimestamp \u003d newPressEventTimestamp;",
        "        }",
        "    }",
        "",
        "    return doubleClicked;",
        "}",
        "",
        "bool QQuickWindowPrivate::translateTouchToMouse(QQuickItem *item, QTouchEvent *event)",
        "{",
        "    // For each point, check if it is accepted, if not, try the next point.",
        "    // Any of the fingers can become the mouse one.",
        "    // This can happen because a mouse area might not accept an event at some point but another.",
        "    for (int i \u003d 0; i \u003c event-\u003etouchPoints().count(); ++i) {",
        "        const QTouchEvent::TouchPoint \u0026p \u003d event-\u003etouchPoints().at(i);",
        "        // A new touch point",
        "        if (touchMouseId \u003d\u003d -1 \u0026\u0026 p.state() \u0026 Qt::TouchPointPressed) {",
        "            QPointF pos \u003d item-\u003emapFromScene(p.scenePos());",
        "",
        "            // probably redundant, we check bounds in the calling function (matchingNewPoints)",
        "            if (!item-\u003econtains(pos))",
        "                break;",
        "",
        "            // Store the id already here and restore it to -1 if the event does not get",
        "            // accepted. Cannot defer setting the new value because otherwise if the event",
        "            // handler spins the event loop all subsequent moves and releases get lost.",
        "            touchMouseId \u003d p.id();",
        "            itemForTouchPointId[touchMouseId] \u003d item;",
        "            QScopedPointer\u003cQMouseEvent\u003e mousePress(touchToMouseEvent(QEvent::MouseButtonPress, p, event, item));",
        "",
        "            // Send a single press and see if that\u0027s accepted",
        "            if (!mouseGrabberItem)",
        "                item-\u003egrabMouse();",
        "            item-\u003egrabTouchPoints(QVector\u003cint\u003e() \u003c\u003c touchMouseId);",
        "",
        "            QCoreApplication::sendEvent(item, mousePress.data());",
        "            event-\u003esetAccepted(mousePress-\u003eisAccepted());",
        "            if (!mousePress-\u003eisAccepted()) {",
        "                touchMouseId \u003d -1;",
        "                if (itemForTouchPointId.value(p.id()) \u003d\u003d item)",
        "                    itemForTouchPointId.remove(p.id());",
        "",
        "                if (mouseGrabberItem \u003d\u003d item)",
        "                    item-\u003eungrabMouse();",
        "            }",
        "",
        "            if (mousePress-\u003eisAccepted() \u0026\u0026 checkIfDoubleClicked(event-\u003etimestamp())) {",
        "                QScopedPointer\u003cQMouseEvent\u003e mouseDoubleClick(touchToMouseEvent(QEvent::MouseButtonDblClick, p, event, item));",
        "                QCoreApplication::sendEvent(item, mouseDoubleClick.data());",
        "                event-\u003esetAccepted(mouseDoubleClick-\u003eisAccepted());",
        "                if (mouseDoubleClick-\u003eisAccepted()) {",
        "                    return true;",
        "                } else {",
        "                    touchMouseId \u003d -1;",
        "                }",
        "            }",
        "            // The event was accepted, we are done.",
        "            if (mousePress-\u003eisAccepted())",
        "                return true;",
        "            // The event was not accepted but touchMouseId was set.",
        "            if (touchMouseId !\u003d -1)",
        "                return false;",
        "            // try the next point",
        "",
        "        // Touch point was there before and moved",
        "        } else if (p.id() \u003d\u003d touchMouseId) {",
        "            if (p.state() \u0026 Qt::TouchPointMoved) {",
        "                if (mouseGrabberItem) {",
        "                    QScopedPointer\u003cQMouseEvent\u003e me(touchToMouseEvent(QEvent::MouseMove, p, event, mouseGrabberItem));",
        "                    QCoreApplication::sendEvent(item, me.data());",
        "                    event-\u003esetAccepted(me-\u003eisAccepted());",
        "                    if (me-\u003eisAccepted()) {",
        "                        itemForTouchPointId[p.id()] \u003d mouseGrabberItem; // N.B. the mouseGrabberItem may be different after returning from sendEvent()",
        "                        return true;",
        "                    }",
        "                } else {",
        "                    // no grabber, check if we care about mouse hover",
        "                    // FIXME: this should only happen once, not recursively... I\u0027ll ignore it just ignore hover now.",
        "                    // hover for touch???",
        "                    QScopedPointer\u003cQMouseEvent\u003e me(touchToMouseEvent(QEvent::MouseMove, p, event, item));",
        "                    if (lastMousePosition.isNull())",
        "                        lastMousePosition \u003d me-\u003ewindowPos();",
        "                    QPointF last \u003d lastMousePosition;",
        "                    lastMousePosition \u003d me-\u003ewindowPos();",
        "",
        "                    bool accepted \u003d me-\u003eisAccepted();",
        "                    bool delivered \u003d deliverHoverEvent(contentItem, me-\u003ewindowPos(), last, me-\u003emodifiers(), accepted);",
        "                    if (!delivered) {",
        "                        //take care of any exits",
        "                        accepted \u003d clearHover();",
        "                    }",
        "                    me-\u003esetAccepted(accepted);",
        "                    break;",
        "                }",
        "            } else if (p.state() \u0026 Qt::TouchPointReleased) {",
        "                // currently handled point was released",
        "                touchMouseId \u003d -1;",
        "                if (mouseGrabberItem) {",
        "                    QScopedPointer\u003cQMouseEvent\u003e me(touchToMouseEvent(QEvent::MouseButtonRelease, p, event, mouseGrabberItem));",
        "                    QCoreApplication::sendEvent(item, me.data());",
        "                    if (mouseGrabberItem) // might have ungrabbed due to event",
        "                        mouseGrabberItem-\u003eungrabMouse();",
        "                    return me-\u003eisAccepted();",
        "                }",
        "            }",
        "            break;",
        "        }",
        "    }",
        "    return false;",
        "}",
        "",
        "void QQuickWindowPrivate::setMouseGrabber(QQuickItem *grabber)",
        "{",
        "    Q_Q(QQuickWindow);",
        "    if (mouseGrabberItem \u003d\u003d grabber)",
        "        return;",
        "",
        "    QQuickItem *oldGrabber \u003d mouseGrabberItem;",
        "    mouseGrabberItem \u003d grabber;",
        "",
        "    if (touchMouseId !\u003d -1) {",
        "        // update the touch item for mouse touch id to the new grabber",
        "        itemForTouchPointId.remove(touchMouseId);",
        "        if (grabber)",
        "            itemForTouchPointId[touchMouseId] \u003d grabber;",
        "    }",
        "",
        "    if (oldGrabber) {",
        "        QEvent ev(QEvent::UngrabMouse);",
        "        q-\u003esendEvent(oldGrabber, \u0026ev);",
        "    }",
        "}",
        "",
        "void QQuickWindowPrivate::transformTouchPoints(QList\u003cQTouchEvent::TouchPoint\u003e \u0026touchPoints, const QTransform \u0026transform)",
        "{",
        "    QMatrix4x4 transformMatrix(transform);",
        "    for (int i\u003d0; i\u003ctouchPoints.count(); i++) {",
        "        QTouchEvent::TouchPoint \u0026touchPoint \u003d touchPoints[i];",
        "        touchPoint.setRect(transform.mapRect(touchPoint.sceneRect()));",
        "        touchPoint.setStartPos(transform.map(touchPoint.startScenePos()));",
        "        touchPoint.setLastPos(transform.map(touchPoint.lastScenePos()));",
        "        touchPoint.setVelocity(transformMatrix.mapVector(touchPoint.velocity()).toVector2D());",
        "    }",
        "}",
        "",
        "",
        "/*!",
        "Translates the data in \\a touchEvent to this window.  This method leaves the item local positions in",
        "\\a touchEvent untouched (these are filled in later).",
        "*/",
        "void QQuickWindowPrivate::translateTouchEvent(QTouchEvent *touchEvent)",
        "{",
        "    QList\u003cQTouchEvent::TouchPoint\u003e touchPoints \u003d touchEvent-\u003etouchPoints();",
        "    for (int i \u003d 0; i \u003c touchPoints.count(); ++i) {",
        "        QTouchEvent::TouchPoint \u0026touchPoint \u003d touchPoints[i];",
        "",
        "        touchPoint.setScreenRect(touchPoint.sceneRect());",
        "        touchPoint.setStartScreenPos(touchPoint.startScenePos());",
        "        touchPoint.setLastScreenPos(touchPoint.lastScenePos());",
        "",
        "        touchPoint.setSceneRect(touchPoint.rect());",
        "        touchPoint.setStartScenePos(touchPoint.startPos());",
        "        touchPoint.setLastScenePos(touchPoint.lastPos());",
        "",
        "        if (i \u003d\u003d 0)",
        "            lastMousePosition \u003d touchPoint.pos().toPoint();",
        "    }",
        "    touchEvent-\u003esetTouchPoints(touchPoints);",
        "}",
        "",
        "/*!",
        "Set the focus inside \\a scope to be \\a item.",
        "If the scope contains the active focus item, it will be changed to \\a item.",
        "Calls notifyFocusChangesRecur for all changed items.",
        "*/",
        "void QQuickWindowPrivate::setFocusInScope(QQuickItem *scope, QQuickItem *item, Qt::FocusReason reason, FocusOptions options)",
        "{",
        "    Q_Q(QQuickWindow);",
        "",
        "    Q_ASSERT(item);",
        "    Q_ASSERT(scope || item \u003d\u003d contentItem);",
        "",
        "#ifdef FOCUS_DEBUG",
        "    qWarning() \u003c\u003c \"QQuickWindowPrivate::setFocusInScope():\";",
        "    qWarning() \u003c\u003c \"    scope:\" \u003c\u003c (QObject *)scope;",
        "    if (scope)",
        "        qWarning() \u003c\u003c \"    scopeSubFocusItem:\" \u003c\u003c (QObject *)QQuickItemPrivate::get(scope)-\u003esubFocusItem;",
        "    qWarning() \u003c\u003c \"    item:\" \u003c\u003c (QObject *)item;",
        "    qWarning() \u003c\u003c \"    activeFocusItem:\" \u003c\u003c (QObject *)activeFocusItem;",
        "#endif",
        "",
        "    QQuickItemPrivate *scopePrivate \u003d scope ? QQuickItemPrivate::get(scope) : 0;",
        "    QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "",
        "    QQuickItem *currentActiveFocusItem \u003d activeFocusItem;",
        "    QQuickItem *newActiveFocusItem \u003d 0;",
        "",
        "    QVarLengthArray\u003cQQuickItem *, 20\u003e changed;",
        "",
        "    // Does this change the active focus?",
        "    if (item \u003d\u003d contentItem || scopePrivate-\u003eactiveFocus) {",
        "        QQuickItem *oldActiveFocusItem \u003d 0;",
        "        oldActiveFocusItem \u003d activeFocusItem;",
        "        if (item-\u003eisEnabled()) {",
        "            newActiveFocusItem \u003d item;",
        "            while (newActiveFocusItem-\u003eisFocusScope()",
        "                   \u0026\u0026 newActiveFocusItem-\u003escopedFocusItem()",
        "                   \u0026\u0026 newActiveFocusItem-\u003escopedFocusItem()-\u003eisEnabled()) {",
        "                newActiveFocusItem \u003d newActiveFocusItem-\u003escopedFocusItem();",
        "            }",
        "        } else {",
        "            newActiveFocusItem \u003d scope;",
        "        }",
        "",
        "        if (oldActiveFocusItem) {",
        "#ifndef QT_NO_IM",
        "            qApp-\u003einputMethod()-\u003ecommit();",
        "#endif",
        "",
        "            activeFocusItem \u003d 0;",
        "            QFocusEvent event(QEvent::FocusOut, reason);",
        "            q-\u003esendEvent(oldActiveFocusItem, \u0026event);",
        "",
        "            QQuickItem *afi \u003d oldActiveFocusItem;",
        "            while (afi \u0026\u0026 afi !\u003d scope) {",
        "                if (QQuickItemPrivate::get(afi)-\u003eactiveFocus) {",
        "                    QQuickItemPrivate::get(afi)-\u003eactiveFocus \u003d false;",
        "                    changed \u003c\u003c afi;",
        "                }",
        "                afi \u003d afi-\u003eparentItem();",
        "            }",
        "        }",
        "    }",
        "",
        "    if (item !\u003d contentItem \u0026\u0026 !(options \u0026 DontChangeSubFocusItem)) {",
        "        QQuickItem *oldSubFocusItem \u003d scopePrivate-\u003esubFocusItem;",
        "        if (oldSubFocusItem) {",
        "            QQuickItemPrivate::get(oldSubFocusItem)-\u003efocus \u003d false;",
        "            changed \u003c\u003c oldSubFocusItem;",
        "        }",
        "",
        "        QQuickItemPrivate::get(item)-\u003eupdateSubFocusItem(scope, true);",
        "    }",
        "",
        "    if (!(options \u0026 DontChangeFocusProperty)) {",
        "        if (item !\u003d contentItem || QGuiApplication::focusWindow() \u003d\u003d q) {",
        "            itemPrivate-\u003efocus \u003d true;",
        "            changed \u003c\u003c item;",
        "        }",
        "    }",
        "",
        "    if (newActiveFocusItem \u0026\u0026 contentItem-\u003ehasFocus()) {",
        "        activeFocusItem \u003d newActiveFocusItem;",
        "",
        "        QQuickItemPrivate::get(newActiveFocusItem)-\u003eactiveFocus \u003d true;",
        "        changed \u003c\u003c newActiveFocusItem;",
        "",
        "        QQuickItem *afi \u003d newActiveFocusItem-\u003eparentItem();",
        "        while (afi \u0026\u0026 afi !\u003d scope) {",
        "            if (afi-\u003eisFocusScope()) {",
        "                QQuickItemPrivate::get(afi)-\u003eactiveFocus \u003d true;",
        "                changed \u003c\u003c afi;",
        "            }",
        "            afi \u003d afi-\u003eparentItem();",
        "        }",
        "        updateFocusItemTransform();",
        "",
        "        QFocusEvent event(QEvent::FocusIn, reason);",
        "        q-\u003esendEvent(newActiveFocusItem, \u0026event);",
        "    }",
        "",
        "    if (activeFocusItem !\u003d currentActiveFocusItem)",
        "        emit q-\u003efocusObjectChanged(activeFocusItem);",
        "",
        "    if (!changed.isEmpty())",
        "        notifyFocusChangesRecur(changed.data(), changed.count() - 1);",
        "}",
        "",
        "void QQuickWindowPrivate::clearFocusInScope(QQuickItem *scope, QQuickItem *item, Qt::FocusReason reason, FocusOptions options)",
        "{",
        "    Q_Q(QQuickWindow);",
        "",
        "    Q_ASSERT(item);",
        "    Q_ASSERT(scope || item \u003d\u003d contentItem);",
        "",
        "#ifdef FOCUS_DEBUG",
        "    qWarning() \u003c\u003c \"QQuickWindowPrivate::clearFocusInScope():\";",
        "    qWarning() \u003c\u003c \"    scope:\" \u003c\u003c (QObject *)scope;",
        "    qWarning() \u003c\u003c \"    item:\" \u003c\u003c (QObject *)item;",
        "    qWarning() \u003c\u003c \"    activeFocusItem:\" \u003c\u003c (QObject *)activeFocusItem;",
        "#endif",
        "",
        "    QQuickItemPrivate *scopePrivate \u003d 0;",
        "    if (scope) {",
        "        scopePrivate \u003d QQuickItemPrivate::get(scope);",
        "        if ( !scopePrivate-\u003esubFocusItem )",
        "            return;//No focus, nothing to do.",
        "    }",
        "",
        "    QQuickItem *currentActiveFocusItem \u003d activeFocusItem;",
        "    QQuickItem *oldActiveFocusItem \u003d 0;",
        "    QQuickItem *newActiveFocusItem \u003d 0;",
        "",
        "    QVarLengthArray\u003cQQuickItem *, 20\u003e changed;",
        "",
        "    Q_ASSERT(item \u003d\u003d contentItem || item \u003d\u003d scopePrivate-\u003esubFocusItem);",
        "",
        "    // Does this change the active focus?",
        "    if (item \u003d\u003d contentItem || scopePrivate-\u003eactiveFocus) {",
        "        oldActiveFocusItem \u003d activeFocusItem;",
        "        newActiveFocusItem \u003d scope;",
        "",
        "#ifndef QT_NO_IM",
        "        qApp-\u003einputMethod()-\u003ecommit();",
        "#endif",
        "",
        "        activeFocusItem \u003d 0;",
        "",
        "        if (oldActiveFocusItem) {",
        "            QFocusEvent event(QEvent::FocusOut, reason);",
        "            q-\u003esendEvent(oldActiveFocusItem, \u0026event);",
        "",
        "            QQuickItem *afi \u003d oldActiveFocusItem;",
        "            while (afi \u0026\u0026 afi !\u003d scope) {",
        "                if (QQuickItemPrivate::get(afi)-\u003eactiveFocus) {",
        "                    QQuickItemPrivate::get(afi)-\u003eactiveFocus \u003d false;",
        "                    changed \u003c\u003c afi;",
        "                }",
        "                afi \u003d afi-\u003eparentItem();",
        "            }",
        "        }",
        "    }",
        "",
        "    if (item !\u003d contentItem \u0026\u0026 !(options \u0026 DontChangeSubFocusItem)) {",
        "        QQuickItem *oldSubFocusItem \u003d scopePrivate-\u003esubFocusItem;",
        "        if (oldSubFocusItem \u0026\u0026 !(options \u0026 DontChangeFocusProperty)) {",
        "            QQuickItemPrivate::get(oldSubFocusItem)-\u003efocus \u003d false;",
        "            changed \u003c\u003c oldSubFocusItem;",
        "        }",
        "",
        "        QQuickItemPrivate::get(item)-\u003eupdateSubFocusItem(scope, false);",
        "",
        "    } else if (!(options \u0026 DontChangeFocusProperty)) {",
        "        QQuickItemPrivate::get(item)-\u003efocus \u003d false;",
        "        changed \u003c\u003c item;",
        "    }",
        "",
        "    if (newActiveFocusItem) {",
        "        Q_ASSERT(newActiveFocusItem \u003d\u003d scope);",
        "        activeFocusItem \u003d scope;",
        "        updateFocusItemTransform();",
        "",
        "        QFocusEvent event(QEvent::FocusIn, reason);",
        "        q-\u003esendEvent(newActiveFocusItem, \u0026event);",
        "    }",
        "",
        "    if (activeFocusItem !\u003d currentActiveFocusItem)",
        "        emit q-\u003efocusObjectChanged(activeFocusItem);",
        "",
        "    if (!changed.isEmpty())",
        "        notifyFocusChangesRecur(changed.data(), changed.count() - 1);",
        "}",
        "",
        "void QQuickWindowPrivate::clearFocusObject()",
        "{",
        "    contentItem-\u003esetFocus(false, Qt::OtherFocusReason);",
        "}",
        "",
        "void QQuickWindowPrivate::notifyFocusChangesRecur(QQuickItem **items, int remaining)",
        "{",
        "    QPointer\u003cQQuickItem\u003e item(*items);",
        "",
        "    if (remaining)",
        "        notifyFocusChangesRecur(items + 1, remaining - 1);",
        "",
        "    if (item) {",
        "        QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "",
        "        if (itemPrivate-\u003enotifiedFocus !\u003d itemPrivate-\u003efocus) {",
        "            itemPrivate-\u003enotifiedFocus \u003d itemPrivate-\u003efocus;",
        "            emit item-\u003efocusChanged(itemPrivate-\u003efocus);",
        "        }",
        "",
        "        if (item \u0026\u0026 itemPrivate-\u003enotifiedActiveFocus !\u003d itemPrivate-\u003eactiveFocus) {",
        "            itemPrivate-\u003enotifiedActiveFocus \u003d itemPrivate-\u003eactiveFocus;",
        "            itemPrivate-\u003eitemChange(QQuickItem::ItemActiveFocusHasChanged, itemPrivate-\u003eactiveFocus);",
        "            emit item-\u003eactiveFocusChanged(itemPrivate-\u003eactiveFocus);",
        "        }",
        "    }",
        "}",
        "",
        "void QQuickWindowPrivate::dirtyItem(QQuickItem *)",
        "{",
        "    Q_Q(QQuickWindow);",
        "    q-\u003emaybeUpdate();",
        "}",
        "",
        "void QQuickWindowPrivate::cleanup(QSGNode *n)",
        "{",
        "    Q_Q(QQuickWindow);",
        "",
        "    Q_ASSERT(!cleanupNodeList.contains(n));",
        "    cleanupNodeList.append(n);",
        "    q-\u003emaybeUpdate();",
        "}",
        "",
        "/*!",
        "    \\qmltype Window",
        "    \\instantiates QQuickWindow",
        "    \\inqmlmodule QtQuick.Window",
        "    \\ingroup qtquick-visual",
        "    \\brief Creates a new top-level window",
        "",
        "    The Window object creates a new top-level window for a Qt Quick scene. It automatically sets up the",
        "    window for use with \\c {QtQuick 2.x} graphical types.",
        "",
        "    To use this type, you will need to import the module with the following line:",
        "    \\code",
        "    import QtQuick.Window 2.1",
        "    \\endcode",
        "",
        "    Omitting this import will allow you to have a QML environment without",
        "    access to window system features.",
        "",
        "    A Window can be declared inside an Item or inside another Window; in that",
        "    case the inner Window will automatically become \"transient for\" the outer",
        "    Window: that is, most platforms will show it centered upon the outer window",
        "    by default, and there may be other platform-dependent behaviors, depending",
        "    also on the \\l flags. If the nested window is intended to be a dialog in",
        "    your application, you should also set \\l flags to Qt.Dialog, because some",
        "    window managers will not provide the centering behavior without that flag.",
        "    You can also declare multiple windows inside a top-level \\l QtObject, in which",
        "    case the windows will have no transient relationship.",
        "",
        "    Alternatively you can set or bind \\l x and \\l y to position the Window",
        "    explicitly on the screen.",
        "",
        "    When the user attempts to close a window, the \\a closing signal will be",
        "    emitted. You can force the window to stay open (for example to prompt the",
        "    user to save changes) by writing an onClosing handler and setting",
        "    close.accepted \u003d false.",
        "*/",
        "/*!",
        "    \\class QQuickWindow",
        "    \\since 5.0",
        "",
        "    \\inmodule QtQuick",
        "",
        "    \\brief The QQuickWindow class provides the window for displaying a graphical QML scene",
        "",
        "    QQuickWindow provides the graphical scene management needed to interact with and display",
        "    a scene of QQuickItems.",
        "",
        "    A QQuickWindow always has a single invisible root item. To add items to this window,",
        "    reparent the items to the root item or to an existing item in the scene.",
        "",
        "    For easily displaying a scene from a QML file, see \\l{QQuickView}.",
        "",
        "",
        "",
        "    \\section1 Rendering",
        "",
        "    QQuickWindow uses a scene graph on top of OpenGL to",
        "    render. This scene graph is disconnected from the QML scene and",
        "    potentially lives in another thread, depending on the platform",
        "    implementation. Since the rendering scene graph lives",
        "    independently from the QML scene, it can also be completely",
        "    released without affecting the state of the QML scene.",
        "",
        "    The sceneGraphInitialized() signal is emitted on the rendering",
        "    thread before the QML scene is rendered to the screen for the",
        "    first time. If the rendering scene graph has been released, the",
        "    signal will be emitted again before the next frame is rendered.",
        "",
        "",
        "    \\section2 Integration with OpenGL",
        "",
        "    It is possible to integrate OpenGL calls directly into the",
        "    QQuickWindow using the same OpenGL context as the Qt Quick Scene",
        "    Graph. This is done by connecting to the",
        "    QQuickWindow::beforeRendering() or QQuickWindow::afterRendering()",
        "    signal.",
        "",
        "    \\note When using QQuickWindow::beforeRendering(), make sure to",
        "    disable clearing before rendering with",
        "    QQuickWindow::setClearBeforeRendering().",
        "",
        "",
        "    \\section2 Exposure and Visibility",
        "",
        "    When a QQuickWindow instance is deliberately hidden with hide() or",
        "    setVisible(false), it will stop rendering and its scene graph and",
        "    OpenGL context might be released. The sceneGraphInvalidated()",
        "    signal will be emitted when this happens.",
        "",
        "    \\warning It is crucial that OpenGL operations and interaction with",
        "    the scene graph happens exclusively on the rendering thread,",
        "    primarily during the updatePaintNode() phase.",
        "",
        "    \\warning As signals related to rendering might be emitted from the",
        "    rendering thread, connections should be made using",
        "    Qt::DirectConnection.",
        "",
        "",
        "    \\section2 Resource Management",
        "",
        "    QML will try to cache images and scene graph nodes to",
        "    improve performance, but in some low-memory scenarios it might be",
        "    required to aggressively release these resources. The",
        "    releaseResources() can be used to force the clean up of certain",
        "    resources. Calling releaseResources() may result in the entire",
        "    scene graph and its OpenGL context being deleted. The",
        "    sceneGraphInvalidated() signal will be emitted when this happens.",
        "",
        "    \\sa {Scene Graph - OpenGL Under QML}",
        "",
        "*/",
        "",
        "/*!",
        "    Constructs a window for displaying a QML scene with parent window \\a parent.",
        "*/",
        "QQuickWindow::QQuickWindow(QWindow *parent)",
        "    : QWindow(*(new QQuickWindowPrivate), parent)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003einit(this);",
        "}",
        "",
        "",
        "",
        "/*!",
        "    \\internal",
        "*/",
        "QQuickWindow::QQuickWindow(QQuickWindowPrivate \u0026dd, QWindow *parent)",
        "    : QWindow(dd, parent)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003einit(this);",
        "}",
        "",
        "/*!",
        "    \\internal",
        "*/",
        "QQuickWindow::QQuickWindow(QQuickRenderControl *control)",
        "    : QWindow(*(new QQuickWindowPrivate), 0)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003einit(this, control);",
        "}",
        "",
        "",
        "",
        "/*!",
        "    Destroys the window.",
        "*/",
        "QQuickWindow::~QQuickWindow()",
        "{",
        "    Q_D(QQuickWindow);",
        "",
        "    d-\u003eanimationController-\u003edeleteLater();",
        "    if (d-\u003erenderControl)",
        "        d-\u003erenderControl-\u003ewindowDestroyed();",
        "    else",
        "        d-\u003ewindowManager-\u003ewindowDestroyed(this);",
        "",
        "    QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);",
        "    delete d-\u003eincubationController; d-\u003eincubationController \u003d 0;",
        "#ifndef QT_NO_DRAGANDDROP",
        "    delete d-\u003edragGrabber; d-\u003edragGrabber \u003d 0;",
        "#endif",
        "    delete d-\u003econtentItem; d-\u003econtentItem \u003d 0;",
        "}",
        "",
        "",
        "",
        "/*!",
        "    This function tries to release redundant resources currently held by the QML scene.",
        "",
        "    Calling this function might result in the scene graph and the OpenGL context used",
        "    for rendering being released to release graphics memory. If this happens, the",
        "    sceneGraphInvalidated() signal will be called, allowing users to clean up their",
        "    own graphics resources. The setPersistentOpenGLContext() and setPersistentSceneGraph()",
        "    functions can be used to prevent this from happening, if handling the cleanup is",
        "    not feasible in the application, at the cost of higher memory usage.",
        "",
        "    \\sa sceneGraphInvalidated(), setPersistentOpenGLContext(), setPersistentSceneGraph()",
        " */",
        "",
        "void QQuickWindow::releaseResources()",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (d-\u003ewindowManager)",
        "        d-\u003ewindowManager-\u003ereleaseResources(this);",
        "    QQuickPixmap::purgeCache();",
        "}",
        "",
        "",
        "",
        "/*!",
        "    Sets whether the OpenGL context can be released to \\a",
        "    persistent. The default value is true.",
        "",
        "    The OpenGL context can be released to free up graphics resources",
        "    when the window is obscured, hidden or not rendering. When this",
        "    happens is implementation specific.",
        "",
        "    The QOpenGLContext::aboutToBeDestroyed() signal is emitted from",
        "    the QQuickWindow::openglContext() when the OpenGL context is about",
        "    to be released.  The QQuickWindow::sceneGraphInitialized() signal",
        "    is emitted when a new OpenGL context is created for this",
        "    window. Make a Qt::DirectConnection to these signals to be",
        "    notified.",
        "",
        "    The OpenGL context is still released when the last QQuickWindow is",
        "    deleted.",
        "",
        "    \\sa setPersistentSceneGraph(),",
        "    QOpenGLContext::aboutToBeDestroyed(), sceneGraphInitialized()",
        " */",
        "",
        "void QQuickWindow::setPersistentOpenGLContext(bool persistent)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003epersistentGLContext \u003d persistent;",
        "}",
        "",
        "",
        "",
        "/*!",
        "    Returns whether the OpenGL context can be released during the",
        "    lifetime of the QQuickWindow.",
        "",
        "    \\note This is a hint. When and how this happens is implementation",
        "    specific.",
        " */",
        "",
        "bool QQuickWindow::isPersistentOpenGLContext() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "    return d-\u003epersistentGLContext;",
        "}",
        "",
        "",
        "",
        "/*!",
        "    Sets whether the scene graph nodes and resources can be released",
        "    to \\a persistent.  The default value is true.",
        "",
        "    The scene graph nodes and resources can be released to free up",
        "    graphics resources when the window is obscured, hidden or not",
        "    rendering. When this happens is implementation specific.",
        "",
        "    The QQuickWindow::sceneGraphInvalidated() signal is emitted when",
        "    cleanup occurs. The QQuickWindow::sceneGraphInitialized() signal",
        "    is emitted when a new scene graph is recreated for this",
        "    window. Make a Qt::DirectConnection to these signals to be",
        "    notified.",
        "",
        "    The scene graph nodes and resources are still released when the",
        "    last QQuickWindow is deleted.",
        "",
        "    \\sa setPersistentOpenGLContext(),",
        "    sceneGraphInvalidated(), sceneGraphInitialized()",
        " */",
        "",
        "void QQuickWindow::setPersistentSceneGraph(bool persistent)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003epersistentSceneGraph \u003d persistent;",
        "}",
        "",
        "",
        "",
        "/*!",
        "    Returns whether the scene graph nodes and resources can be",
        "    released during the lifetime of this QQuickWindow.",
        "",
        "    \\note This is a hint. When and how this happens is implementation",
        "    specific.",
        " */",
        "",
        "bool QQuickWindow::isPersistentSceneGraph() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "    return d-\u003epersistentSceneGraph;",
        "}",
        "",
        "",
        "",
        "",
        "",
        "/*!",
        "    \\property QQuickWindow::contentItem",
        "    \\brief The invisible root item of the scene.",
        "",
        "  A QQuickWindow always has a single invisible root item containing all of its content.",
        "  To add items to this window, reparent the items to the contentItem or to an existing",
        "  item in the scene.",
        "*/",
        "QQuickItem *QQuickWindow::contentItem() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "",
        "    return d-\u003econtentItem;",
        "}",
        "",
        "/*!",
        "    \\property QQuickWindow::activeFocusItem",
        "",
        "    \\brief The item which currently has active focus or \\c null if there is",
        "    no item with active focus.",
        "*/",
        "QQuickItem *QQuickWindow::activeFocusItem() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "",
        "    return d-\u003eactiveFocusItem;",
        "}",
        "",
        "/*!",
        "  \\internal",
        "  \\reimp",
        "*/",
        "QObject *QQuickWindow::focusObject() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "",
        "    if (d-\u003eactiveFocusItem)",
        "        return d-\u003eactiveFocusItem;",
        "    return const_cast\u003cQQuickWindow*\u003e(this);",
        "}",
        "",
        "",
        "/*!",
        "  Returns the item which currently has the mouse grab.",
        "*/",
        "QQuickItem *QQuickWindow::mouseGrabberItem() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "",
        "    return d-\u003emouseGrabberItem;",
        "}",
        "",
        "",
        "bool QQuickWindowPrivate::clearHover()",
        "{",
        "    Q_Q(QQuickWindow);",
        "    if (hoverItems.isEmpty())",
        "        return false;",
        "",
        "    QPointF pos \u003d q-\u003emapFromGlobal(QGuiApplicationPrivate::lastCursorPosition.toPoint());",
        "",
        "    bool accepted \u003d false;",
        "    foreach (QQuickItem* item, hoverItems)",
        "        accepted \u003d sendHoverEvent(QEvent::HoverLeave, item, pos, pos, QGuiApplication::keyboardModifiers(), true) || accepted;",
        "    hoverItems.clear();",
        "    return accepted;",
        "}",
        "",
        "/*! \\reimp */",
        "bool QQuickWindow::event(QEvent *e)",
        "{",
        "    Q_D(QQuickWindow);",
        "",
        "    switch (e-\u003etype()) {",
        "",
        "    case QEvent::TouchBegin:",
        "    case QEvent::TouchUpdate:",
        "    case QEvent::TouchEnd: {",
        "        QTouchEvent *touch \u003d static_cast\u003cQTouchEvent*\u003e(e);",
        "        d-\u003etranslateTouchEvent(touch);",
        "        d-\u003edeliverTouchEvent(touch);",
        "        // we consume all touch events ourselves to avoid duplicate",
        "        // mouse delivery by QtGui mouse synthesis",
        "        e-\u003eaccept();",
        "        return true;",
        "    }",
        "        break;",
        "    case QEvent::TouchCancel:",
        "        // return in order to avoid the QWindow::event below",
        "        return d-\u003edeliverTouchCancelEvent(static_cast\u003cQTouchEvent*\u003e(e));",
        "        break;",
        "    case QEvent::Leave:",
        "        d-\u003eclearHover();",
        "        d-\u003elastMousePosition \u003d QPoint();",
        "        break;",
        "#ifndef QT_NO_DRAGANDDROP",
        "    case QEvent::DragEnter:",
        "    case QEvent::DragLeave:",
        "    case QEvent::DragMove:",
        "    case QEvent::Drop:",
        "        d-\u003edeliverDragEvent(d-\u003edragGrabber, e);",
        "        break;",
        "#endif",
        "    case QEvent::WindowDeactivate:",
        "        contentItem()-\u003ewindowDeactivateEvent();",
        "        break;",
        "    case QEvent::Close: {",
        "        // TOOD Qt 6 (binary incompatible)",
        "        // closeEvent(static_cast\u003cQCloseEvent *\u003e(e));",
        "        QQuickCloseEvent qev;",
        "        qev.setAccepted(e-\u003eisAccepted());",
        "        emit closing(\u0026qev);",
        "        e-\u003esetAccepted(qev.isAccepted());",
        "        } break;",
        "    case QEvent::FocusAboutToChange:",
        "#ifndef QT_NO_IM",
        "        if (d-\u003eactiveFocusItem)",
        "            qGuiApp-\u003einputMethod()-\u003ecommit();",
        "#endif",
        "        if (d-\u003emouseGrabberItem)",
        "            d-\u003emouseGrabberItem-\u003eungrabMouse();",
        "        break;",
        "    default:",
        "        break;",
        "    }",
        "",
        "    return QWindow::event(e);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::keyPressEvent(QKeyEvent *e)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003edeliverKeyEvent(e);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::keyReleaseEvent(QKeyEvent *e)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003edeliverKeyEvent(e);",
        "}",
        "",
        "void QQuickWindowPrivate::deliverKeyEvent(QKeyEvent *e)",
        "{",
        "    Q_Q(QQuickWindow);",
        "",
        "#ifndef QT_NO_SHORTCUT",
        "    // Try looking for a Shortcut before sending key events",
        "    if (e-\u003etype() \u003d\u003d QEvent::KeyPress",
        "        \u0026\u0026 QGuiApplicationPrivate::instance()-\u003eshortcutMap.tryShortcutEvent(q-\u003efocusObject(), e))",
        "        return;",
        "#endif",
        "",
        "    if (activeFocusItem)",
        "        q-\u003esendEvent(activeFocusItem, e);",
        "#ifdef Q_OS_MAC",
        "    else {",
        "        // This is the case for popup windows on Mac, where popup windows get focus",
        "        // in Qt (after exposure) but they are not \"key windows\" in the Cocoa sense.",
        "        // Therefore, the will never receive key events from Cocoa. Instead, the",
        "        // toplevel non-popup window (the application current \"key window\") will",
        "        // receive them. (QWidgetWindow does something similar for widgets, by keeping",
        "        // a list of popup windows, and forwarding the key event to the top-most popup.)",
        "        QWindow *focusWindow \u003d qApp-\u003efocusWindow();",
        "        if (focusWindow \u0026\u0026 focusWindow !\u003d q",
        "            \u0026\u0026 (focusWindow-\u003eflags() \u0026 Qt::Popup) \u003d\u003d Qt::Popup)",
        "            QGuiApplication::sendEvent(focusWindow, e);",
        "    }",
        "#endif",
        "}",
        "",
        "QMouseEvent *QQuickWindowPrivate::cloneMouseEvent(QMouseEvent *event, QPointF *transformedLocalPos)",
        "{",
        "    int caps \u003d QGuiApplicationPrivate::mouseEventCaps(event);",
        "    QVector2D velocity \u003d QGuiApplicationPrivate::mouseEventVelocity(event);",
        "    QMouseEvent *me \u003d new QMouseEvent(event-\u003etype(),",
        "                                      transformedLocalPos ? *transformedLocalPos : event-\u003elocalPos(),",
        "                                      event-\u003ewindowPos(), event-\u003escreenPos(),",
        "                                      event-\u003ebutton(), event-\u003ebuttons(), event-\u003emodifiers());",
        "    QGuiApplicationPrivate::setMouseEventCapsAndVelocity(me, caps, velocity);",
        "    QGuiApplicationPrivate::setMouseEventSource(me, QGuiApplicationPrivate::mouseEventSource(event));",
        "    me-\u003esetTimestamp(event-\u003etimestamp());",
        "    return me;",
        "}",
        "",
        "bool QQuickWindowPrivate::deliverInitialMousePressEvent(QQuickItem *item, QMouseEvent *event)",
        "{",
        "    Q_Q(QQuickWindow);",
        "",
        "    QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "",
        "    if (itemPrivate-\u003eflags \u0026 QQuickItem::ItemClipsChildrenToShape) {",
        "        QPointF p \u003d item-\u003emapFromScene(event-\u003ewindowPos());",
        "        if (!item-\u003econtains(p))",
        "            return false;",
        "    }",
        "",
        "    QList\u003cQQuickItem *\u003e children \u003d itemPrivate-\u003epaintOrderChildItems();",
        "    for (int ii \u003d children.count() - 1; ii \u003e\u003d 0; --ii) {",
        "        QQuickItem *child \u003d children.at(ii);",
        "        if (!child-\u003eisVisible() || !child-\u003eisEnabled() || QQuickItemPrivate::get(child)-\u003eculled)",
        "            continue;",
        "        if (deliverInitialMousePressEvent(child, event))",
        "            return true;",
        "    }",
        "",
        "    if (itemPrivate-\u003eacceptedMouseButtons() \u0026 event-\u003ebutton()) {",
        "        QPointF localPos \u003d item-\u003emapFromScene(event-\u003ewindowPos());",
        "        if (item-\u003econtains(localPos)) {",
        "            QScopedPointer\u003cQMouseEvent\u003e me(cloneMouseEvent(event, \u0026localPos));",
        "            me-\u003eaccept();",
        "            item-\u003egrabMouse();",
        "            q-\u003esendEvent(item, me.data());",
        "            event-\u003esetAccepted(me-\u003eisAccepted());",
        "            if (me-\u003eisAccepted())",
        "                return true;",
        "            if (mouseGrabberItem)",
        "                mouseGrabberItem-\u003eungrabMouse();",
        "        }",
        "    }",
        "",
        "    return false;",
        "}",
        "",
        "bool QQuickWindowPrivate::deliverMouseEvent(QMouseEvent *event)",
        "{",
        "    Q_Q(QQuickWindow);",
        "",
        "    lastMousePosition \u003d event-\u003ewindowPos();",
        "",
        "    if (!mouseGrabberItem \u0026\u0026",
        "         event-\u003etype() \u003d\u003d QEvent::MouseButtonPress \u0026\u0026",
        "         (event-\u003ebuttons() \u0026 event-\u003ebutton()) \u003d\u003d event-\u003ebuttons()) {",
        "        if (deliverInitialMousePressEvent(contentItem, event))",
        "            event-\u003eaccept();",
        "        else",
        "            event-\u003eignore();",
        "        return event-\u003eisAccepted();",
        "    }",
        "",
        "    if (mouseGrabberItem) {",
        "        QPointF localPos \u003d mouseGrabberItem-\u003emapFromScene(event-\u003ewindowPos());",
        "        QScopedPointer\u003cQMouseEvent\u003e me(cloneMouseEvent(event, \u0026localPos));",
        "        me-\u003eaccept();",
        "        q-\u003esendEvent(mouseGrabberItem, me.data());",
        "        event-\u003esetAccepted(me-\u003eisAccepted());",
        "        if (me-\u003eisAccepted())",
        "            return true;",
        "    }",
        "",
        "    return false;",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::mousePressEvent(QMouseEvent *event)",
        "{",
        "    Q_D(QQuickWindow);",
        "",
        "    if (event-\u003esource() \u003d\u003d Qt::MouseEventSynthesizedBySystem) {",
        "        event-\u003eaccept();",
        "        return;",
        "    }",
        "",
        "#ifdef MOUSE_DEBUG",
        "    qWarning() \u003c\u003c \"QQuickWindow::mousePressEvent()\" \u003c\u003c event-\u003elocalPos() \u003c\u003c event-\u003ebutton() \u003c\u003c event-\u003ebuttons();",
        "#endif",
        "",
        "    d-\u003edeliverMouseEvent(event);",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::mouseReleaseEvent(QMouseEvent *event)",
        "{",
        "    Q_D(QQuickWindow);",
        "",
        "    if (event-\u003esource() \u003d\u003d Qt::MouseEventSynthesizedBySystem) {",
        "        event-\u003eaccept();",
        "        return;",
        "    }",
        "",
        "#ifdef MOUSE_DEBUG",
        "    qWarning() \u003c\u003c \"QQuickWindow::mouseReleaseEvent()\" \u003c\u003c event-\u003elocalPos() \u003c\u003c event-\u003ebutton() \u003c\u003c event-\u003ebuttons();",
        "#endif",
        "",
        "    if (!d-\u003emouseGrabberItem) {",
        "        QWindow::mouseReleaseEvent(event);",
        "        return;",
        "    }",
        "",
        "    d-\u003edeliverMouseEvent(event);",
        "    if (d-\u003emouseGrabberItem \u0026\u0026 !event-\u003ebuttons())",
        "        d-\u003emouseGrabberItem-\u003eungrabMouse();",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::mouseDoubleClickEvent(QMouseEvent *event)",
        "{",
        "    Q_D(QQuickWindow);",
        "",
        "    if (event-\u003esource() \u003d\u003d Qt::MouseEventSynthesizedBySystem) {",
        "        event-\u003eaccept();",
        "        return;",
        "    }",
        "",
        "#ifdef MOUSE_DEBUG",
        "    qWarning() \u003c\u003c \"QQuickWindow::mouseDoubleClickEvent()\" \u003c\u003c event-\u003elocalPos() \u003c\u003c event-\u003ebutton() \u003c\u003c event-\u003ebuttons();",
        "#endif",
        "",
        "    if (!d-\u003emouseGrabberItem \u0026\u0026 (event-\u003ebuttons() \u0026 event-\u003ebutton()) \u003d\u003d event-\u003ebuttons()) {",
        "        if (d-\u003edeliverInitialMousePressEvent(d-\u003econtentItem, event))",
        "            event-\u003eaccept();",
        "        else",
        "            event-\u003eignore();",
        "        return;",
        "    }",
        "",
        "    d-\u003edeliverMouseEvent(event);",
        "}",
        "",
        "bool QQuickWindowPrivate::sendHoverEvent(QEvent::Type type, QQuickItem *item,",
        "                                      const QPointF \u0026scenePos, const QPointF \u0026lastScenePos,",
        "                                      Qt::KeyboardModifiers modifiers, bool accepted)",
        "{",
        "    Q_Q(QQuickWindow);",
        "    const QTransform transform \u003d QQuickItemPrivate::get(item)-\u003ewindowToItemTransform();",
        "",
        "    //create copy of event",
        "    QHoverEvent hoverEvent(type, transform.map(scenePos), transform.map(lastScenePos), modifiers);",
        "    hoverEvent.setAccepted(accepted);",
        "",
        "    q-\u003esendEvent(item, \u0026hoverEvent);",
        "",
        "    return hoverEvent.isAccepted();",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::mouseMoveEvent(QMouseEvent *event)",
        "{",
        "    Q_D(QQuickWindow);",
        "",
        "    if (event-\u003esource() \u003d\u003d Qt::MouseEventSynthesizedBySystem) {",
        "        event-\u003eaccept();",
        "        return;",
        "    }",
        "",
        "#ifdef MOUSE_DEBUG",
        "    qWarning() \u003c\u003c \"QQuickWindow::mouseMoveEvent()\" \u003c\u003c event-\u003elocalPos() \u003c\u003c event-\u003ebutton() \u003c\u003c event-\u003ebuttons();",
        "#endif",
        "",
        "#ifndef QT_NO_CURSOR",
        "    d-\u003eupdateCursor(event-\u003ewindowPos());",
        "#endif",
        "",
        "    if (!d-\u003emouseGrabberItem) {",
        "        if (d-\u003elastMousePosition.isNull())",
        "            d-\u003elastMousePosition \u003d event-\u003ewindowPos();",
        "        QPointF last \u003d d-\u003elastMousePosition;",
        "        d-\u003elastMousePosition \u003d event-\u003ewindowPos();",
        "",
        "        bool accepted \u003d event-\u003eisAccepted();",
        "        bool delivered \u003d d-\u003edeliverHoverEvent(d-\u003econtentItem, event-\u003ewindowPos(), last, event-\u003emodifiers(), accepted);",
        "        if (!delivered) {",
        "            //take care of any exits",
        "            accepted \u003d d-\u003eclearHover();",
        "        }",
        "        event-\u003esetAccepted(accepted);",
        "        return;",
        "    }",
        "",
        "    d-\u003edeliverMouseEvent(event);",
        "}",
        "",
        "bool QQuickWindowPrivate::deliverHoverEvent(QQuickItem *item, const QPointF \u0026scenePos, const QPointF \u0026lastScenePos,",
        "                                         Qt::KeyboardModifiers modifiers, bool \u0026accepted)",
        "{",
        "    Q_Q(QQuickWindow);",
        "    QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "",
        "    if (itemPrivate-\u003eflags \u0026 QQuickItem::ItemClipsChildrenToShape) {",
        "        QPointF p \u003d item-\u003emapFromScene(scenePos);",
        "        if (!item-\u003econtains(p))",
        "            return false;",
        "    }",
        "",
        "    QList\u003cQQuickItem *\u003e children \u003d itemPrivate-\u003epaintOrderChildItems();",
        "    for (int ii \u003d children.count() - 1; ii \u003e\u003d 0; --ii) {",
        "        QQuickItem *child \u003d children.at(ii);",
        "        if (!child-\u003eisVisible() || !child-\u003eisEnabled() || QQuickItemPrivate::get(child)-\u003eculled)",
        "            continue;",
        "        if (deliverHoverEvent(child, scenePos, lastScenePos, modifiers, accepted))",
        "            return true;",
        "    }",
        "",
        "    if (itemPrivate-\u003ehoverEnabled) {",
        "        QPointF p \u003d item-\u003emapFromScene(scenePos);",
        "        if (item-\u003econtains(p)) {",
        "            if (!hoverItems.isEmpty() \u0026\u0026 hoverItems[0] \u003d\u003d item) {",
        "                //move",
        "                accepted \u003d sendHoverEvent(QEvent::HoverMove, item, scenePos, lastScenePos, modifiers, accepted);",
        "            } else {",
        "                QList\u003cQQuickItem *\u003e itemsToHover;",
        "                QQuickItem* parent \u003d item;",
        "                itemsToHover \u003c\u003c item;",
        "                while ((parent \u003d parent-\u003eparentItem()))",
        "                    itemsToHover \u003c\u003c parent;",
        "",
        "                // Leaving from previous hovered items until we reach the item or one of its ancestors.",
        "                while (!hoverItems.isEmpty() \u0026\u0026 !itemsToHover.contains(hoverItems[0])) {",
        "                    sendHoverEvent(QEvent::HoverLeave, hoverItems[0], scenePos, lastScenePos, modifiers, accepted);",
        "                    hoverItems.removeFirst();",
        "                }",
        "",
        "                if (!hoverItems.isEmpty() \u0026\u0026 hoverItems[0] \u003d\u003d item){//Not entering a new Item",
        "                    // ### Shouldn\u0027t we send moves for the parent items as well?",
        "                    accepted \u003d sendHoverEvent(QEvent::HoverMove, item, scenePos, lastScenePos, modifiers, accepted);",
        "                } else {",
        "                    // Enter items that are not entered yet.",
        "                    int startIdx \u003d -1;",
        "                    if (!hoverItems.isEmpty())",
        "                        startIdx \u003d itemsToHover.indexOf(hoverItems[0]) - 1;",
        "                    if (startIdx \u003d\u003d -1)",
        "                        startIdx \u003d itemsToHover.count() - 1;",
        "",
        "                    for (int i \u003d startIdx; i \u003e\u003d 0; i--) {",
        "                        QQuickItem *itemToHover \u003d itemsToHover[i];",
        "                        QQuickItemPrivate *itemToHoverPrivate \u003d QQuickItemPrivate::get(itemToHover);",
        "                        // The item may be about to be deleted or reparented to another window",
        "                        // due to another hover event delivered in this function. If that is the",
        "                        // case, sending a hover event here will cause a crash or other bad",
        "                        // behavior when the leave event is generated. Checking",
        "                        // itemToHoverPrivate-\u003ewindow here prevents that case.",
        "                        if (itemToHoverPrivate-\u003ewindow \u003d\u003d q \u0026\u0026 itemToHoverPrivate-\u003ehoverEnabled) {",
        "                            hoverItems.prepend(itemToHover);",
        "                            sendHoverEvent(QEvent::HoverEnter, itemToHover, scenePos, lastScenePos, modifiers, accepted);",
        "                        }",
        "                    }",
        "                }",
        "            }",
        "            return true;",
        "        }",
        "    }",
        "",
        "    return false;",
        "}",
        "",
        "#ifndef QT_NO_WHEELEVENT",
        "bool QQuickWindowPrivate::deliverWheelEvent(QQuickItem *item, QWheelEvent *event)",
        "{",
        "    Q_Q(QQuickWindow);",
        "    QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "",
        "    if (itemPrivate-\u003eflags \u0026 QQuickItem::ItemClipsChildrenToShape) {",
        "        QPointF p \u003d item-\u003emapFromScene(event-\u003eposF());",
        "        if (!item-\u003econtains(p))",
        "            return false;",
        "    }",
        "",
        "    QList\u003cQQuickItem *\u003e children \u003d itemPrivate-\u003epaintOrderChildItems();",
        "    for (int ii \u003d children.count() - 1; ii \u003e\u003d 0; --ii) {",
        "        QQuickItem *child \u003d children.at(ii);",
        "        if (!child-\u003eisVisible() || !child-\u003eisEnabled() || QQuickItemPrivate::get(child)-\u003eculled)",
        "            continue;",
        "        if (deliverWheelEvent(child, event))",
        "            return true;",
        "    }",
        "",
        "    QPointF p \u003d item-\u003emapFromScene(event-\u003eposF());",
        "",
        "    if (item-\u003econtains(p)) {",
        "        QWheelEvent wheel(p, p, event-\u003epixelDelta(), event-\u003eangleDelta(), event-\u003edelta(),",
        "                          event-\u003eorientation(), event-\u003ebuttons(), event-\u003emodifiers(), event-\u003ephase());",
        "        wheel.accept();",
        "        q-\u003esendEvent(item, \u0026wheel);",
        "        if (wheel.isAccepted()) {",
        "            event-\u003eaccept();",
        "            return true;",
        "        }",
        "    }",
        "",
        "    return false;",
        "}",
        "",
        "/*! \\reimp */",
        "void QQuickWindow::wheelEvent(QWheelEvent *event)",
        "{",
        "    Q_D(QQuickWindow);",
        "#ifdef MOUSE_DEBUG",
        "    qWarning() \u003c\u003c \"QQuickWindow::wheelEvent()\" \u003c\u003c event-\u003epixelDelta() \u003c\u003c event-\u003eangleDelta();",
        "#endif",
        "",
        "    //if the actual wheel event was accepted, accept the compatibility wheel event and return early",
        "    if (d-\u003elastWheelEventAccepted \u0026\u0026 event-\u003eangleDelta().isNull() \u0026\u0026 event-\u003ephase() \u003d\u003d Qt::ScrollUpdate)",
        "        return;",
        "",
        "    event-\u003eignore();",
        "    d-\u003edeliverWheelEvent(d-\u003econtentItem, event);",
        "    d-\u003elastWheelEventAccepted \u003d event-\u003eisAccepted();",
        "}",
        "#endif // QT_NO_WHEELEVENT",
        "",
        "",
        "bool QQuickWindowPrivate::deliverTouchCancelEvent(QTouchEvent *event)",
        "{",
        "#ifdef TOUCH_DEBUG",
        "    qWarning(\"touchCancelEvent\");",
        "#endif",
        "    Q_Q(QQuickWindow);",
        "    // A TouchCancel event will typically not contain any points.",
        "    // Deliver it to all items that have active touches.",
        "    QSet\u003cQQuickItem *\u003e cancelDelivered;",
        "    foreach (QQuickItem *item, itemForTouchPointId) {",
        "        if (cancelDelivered.contains(item))",
        "            continue;",
        "        cancelDelivered.insert(item);",
        "        q-\u003esendEvent(item, event);",
        "    }",
        "    touchMouseId \u003d -1;",
        "    if (mouseGrabberItem)",
        "        mouseGrabberItem-\u003eungrabMouse();",
        "    // The next touch event can only be a TouchBegin so clean up.",
        "    itemForTouchPointId.clear();",
        "    return true;",
        "}",
        "",
        "// check what kind of touch we have (begin/update) and",
        "// call deliverTouchPoints to actually dispatch the points",
        "bool QQuickWindowPrivate::deliverTouchEvent(QTouchEvent *event)",
        "{",
        "#ifdef TOUCH_DEBUG",
        "    if (event-\u003etype() \u003d\u003d QEvent::TouchBegin)",
        "        qWarning() \u003c\u003c \"touchBeginEvent\";",
        "    else if (event-\u003etype() \u003d\u003d QEvent::TouchUpdate)",
        "        qWarning() \u003c\u003c \"touchUpdateEvent points\";",
        "    else if (event-\u003etype() \u003d\u003d QEvent::TouchEnd)",
        "        qWarning(\"touchEndEvent\");",
        "#endif",
        "",
        "    // List of all items that received an event before",
        "    // When we have TouchBegin this is and will stay empty",
        "    QHash\u003cQQuickItem *, QList\u003cQTouchEvent::TouchPoint\u003e \u003e updatedPoints;",
        "",
        "    // Figure out who accepted a touch point last and put it in updatedPoints",
        "    // Add additional item to newPoints",
        "    const QList\u003cQTouchEvent::TouchPoint\u003e \u0026touchPoints \u003d event-\u003etouchPoints();",
        "    QList\u003cQTouchEvent::TouchPoint\u003e newPoints;",
        "    for (int i\u003d0; i\u003ctouchPoints.count(); i++) {",
        "        const QTouchEvent::TouchPoint \u0026touchPoint \u003d touchPoints.at(i);",
        "        if (touchPoint.state() \u003d\u003d Qt::TouchPointPressed) {",
        "            newPoints \u003c\u003c touchPoint;",
        "        } else {",
        "            // TouchPointStationary is relevant only to items which",
        "            // are also receiving touch points with some other state.",
        "            // But we have not yet decided which points go to which item,",
        "            // so for now we must include all non-new points in updatedPoints.",
        "            if (itemForTouchPointId.contains(touchPoint.id())) {",
        "                QQuickItem *item \u003d itemForTouchPointId.value(touchPoint.id());",
        "                if (item)",
        "                    updatedPoints[item].append(touchPoint);",
        "            }",
        "        }",
        "    }",
        "",
        "    // Deliver the event, but only if there is at least one new point",
        "    // or some item accepted a point and should receive an update",
        "    if (newPoints.count() \u003e 0 || updatedPoints.count() \u003e 0) {",
        "        QSet\u003cint\u003e acceptedNewPoints;",
        "        event-\u003esetAccepted(deliverTouchPoints(contentItem, event, newPoints, \u0026acceptedNewPoints, \u0026updatedPoints));",
        "    } else",
        "        event-\u003eignore();",
        "",
        "    // Remove released points from itemForTouchPointId",
        "    if (event-\u003etouchPointStates() \u0026 Qt::TouchPointReleased) {",
        "        for (int i\u003d0; i\u003ctouchPoints.count(); i++) {",
        "            if (touchPoints[i].state() \u003d\u003d Qt::TouchPointReleased) {",
        "                itemForTouchPointId.remove(touchPoints[i].id());",
        "                if (touchPoints[i].id() \u003d\u003d touchMouseId)",
        "                    touchMouseId \u003d -1;",
        "            }",
        "        }",
        "    }",
        "",
        "    if (event-\u003etype() \u003d\u003d QEvent::TouchEnd) {",
        "        Q_ASSERT(itemForTouchPointId.isEmpty());",
        "    }",
        "",
        "    return event-\u003eisAccepted();",
        "}",
        "",
        "// This function recurses and sends the events to the individual items",
        "bool QQuickWindowPrivate::deliverTouchPoints(QQuickItem *item, QTouchEvent *event, const QList\u003cQTouchEvent::TouchPoint\u003e \u0026newPoints, QSet\u003cint\u003e *acceptedNewPoints, QHash\u003cQQuickItem *, QList\u003cQTouchEvent::TouchPoint\u003e \u003e *updatedPoints)",
        "{",
        "    QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "",
        "    if (itemPrivate-\u003eflags \u0026 QQuickItem::ItemClipsChildrenToShape) {",
        "        for (int i\u003d0; i\u003cnewPoints.count(); i++) {",
        "            QPointF p \u003d item-\u003emapFromScene(newPoints[i].scenePos());",
        "            if (!item-\u003econtains(p))",
        "                return false;",
        "        }",
        "    }",
        "",
        "    // Check if our children want the event (or parts of it)",
        "    // This is the only point where touch event delivery recurses!",
        "    QList\u003cQQuickItem *\u003e children \u003d itemPrivate-\u003epaintOrderChildItems();",
        "    for (int ii \u003d children.count() - 1; ii \u003e\u003d 0; --ii) {",
        "        QQuickItem *child \u003d children.at(ii);",
        "        if (!child-\u003eisEnabled() || !child-\u003eisVisible() || QQuickItemPrivate::get(child)-\u003eculled)",
        "            continue;",
        "        if (deliverTouchPoints(child, event, newPoints, acceptedNewPoints, updatedPoints))",
        "            return true;",
        "    }",
        "",
        "    // None of the children accepted the event, so check the given item itself.",
        "    // First, construct matchingPoints as a list of TouchPoints which the",
        "    // given item might be interested in.  Any newly-pressed point which is",
        "    // inside the item\u0027s bounds will be interesting, and also any updated point",
        "    // which was already accepted by that item when it was first pressed.",
        "    // (A point which was already accepted is effectively \"grabbed\" by the item.)",
        "",
        "    // set of IDs of \"interesting\" new points",
        "    QSet\u003cint\u003e matchingNewPoints;",
        "    // set of points which this item has previously accepted, for starters",
        "    QList\u003cQTouchEvent::TouchPoint\u003e matchingPoints \u003d (*updatedPoints)[item];",
        "    // now add the new points which are inside this item\u0027s bounds",
        "    if (newPoints.count() \u003e 0 \u0026\u0026 acceptedNewPoints-\u003ecount() \u003c newPoints.count()) {",
        "        for (int i \u003d 0; i \u003c newPoints.count(); i++) {",
        "            if (acceptedNewPoints-\u003econtains(newPoints[i].id()))",
        "                continue;",
        "            QPointF p \u003d item-\u003emapFromScene(newPoints[i].scenePos());",
        "            if (item-\u003econtains(p)) {",
        "                matchingNewPoints.insert(newPoints[i].id());",
        "                matchingPoints \u003c\u003c newPoints[i];",
        "            }",
        "        }",
        "    }",
        "    // If there are no matching new points, and the existing points are all stationary,",
        "    // there\u0027s no need to send an event to this item.  This is required by a test in",
        "    // tst_qquickwindow::touchEvent_basic:",
        "    // a single stationary press on an item shouldn\u0027t cause an event",
        "    if (matchingNewPoints.isEmpty()) {",
        "        bool stationaryOnly \u003d true;",
        "",
        "        foreach (const QTouchEvent::TouchPoint \u0026tp, matchingPoints) {",
        "            if (tp.state() !\u003d Qt::TouchPointStationary) {",
        "                stationaryOnly \u003d false;",
        "                break;",
        "            }",
        "        }",
        "",
        "        if (stationaryOnly)",
        "            matchingPoints.clear();",
        "    }",
        "",
        "    if (!matchingPoints.isEmpty()) {",
        "        // Now we know this item might be interested in the event. Copy and send it, but",
        "        // with only the subset of TouchPoints which are relevant to that item: that\u0027s matchingPoints.",
        "        QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "        transformTouchPoints(matchingPoints, itemPrivate-\u003ewindowToItemTransform());",
        "        deliverMatchingPointsToItem(item, event, acceptedNewPoints, matchingNewPoints, matchingPoints);",
        "    }",
        "",
        "    // record the fact that this item has been visited already",
        "    updatedPoints-\u003eremove(item);",
        "",
        "    // recursion is done only if ALL touch points have been delivered",
        "    return (acceptedNewPoints-\u003ecount() \u003d\u003d newPoints.count() \u0026\u0026 updatedPoints-\u003eisEmpty());",
        "}",
        "",
        "// touchEventForItemBounds has no means to generate a touch event that contains",
        "// only the points that are relevant for this item.  Thus the need for",
        "// matchingPoints to already be that set of interesting points.",
        "// They are all pre-transformed, too.",
        "bool QQuickWindowPrivate::deliverMatchingPointsToItem(QQuickItem *item, QTouchEvent *event, QSet\u003cint\u003e *acceptedNewPoints, const QSet\u003cint\u003e \u0026matchingNewPoints, const QList\u003cQTouchEvent::TouchPoint\u003e \u0026matchingPoints)",
        "{",
        "    QScopedPointer\u003cQTouchEvent\u003e touchEvent(touchEventWithPoints(*event, matchingPoints));",
        "    touchEvent.data()-\u003esetTarget(item);",
        "    bool touchEventAccepted \u003d false;",
        "",
        "    // First check whether the parent wants to be a filter,",
        "    // and if the parent accepts the event we are done.",
        "    if (sendFilteredTouchEvent(item-\u003eparentItem(), item, event)) {",
        "        // If the touch was accepted (regardless by whom or in what form),",
        "        // update acceptedNewPoints",
        "        foreach (int id, matchingNewPoints)",
        "            acceptedNewPoints-\u003einsert(id);",
        "        return true;",
        "    }",
        "",
        "    // Since it can change in sendEvent, update itemForTouchPointId now",
        "    foreach (int id, matchingNewPoints)",
        "        itemForTouchPointId[id] \u003d item;",
        "",
        "    // Deliver the touch event to the given item",
        "    QCoreApplication::sendEvent(item, touchEvent.data());",
        "    touchEventAccepted \u003d touchEvent-\u003eisAccepted();",
        "",
        "    // If the touch event wasn\u0027t accepted, synthesize a mouse event and see if the item wants it.",
        "    QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "    if (!touchEventAccepted \u0026\u0026 (itemPrivate-\u003eacceptedMouseButtons() \u0026 Qt::LeftButton)) {",
        "        //  send mouse event",
        "        event-\u003esetAccepted(translateTouchToMouse(item, event));",
        "        if (event-\u003eisAccepted()) {",
        "            touchEventAccepted \u003d true;",
        "        }",
        "    }",
        "",
        "    if (touchEventAccepted) {",
        "        // If the touch was accepted (regardless by whom or in what form),",
        "        // update acceptedNewPoints.",
        "        foreach (int id, matchingNewPoints)",
        "            acceptedNewPoints-\u003einsert(id);",
        "    } else {",
        "        // But if the event was not accepted then we know this item",
        "        // will not be interested in further updates for those touchpoint IDs either.",
        "        foreach (int id, matchingNewPoints)",
        "            if (itemForTouchPointId[id] \u003d\u003d item)",
        "                itemForTouchPointId.remove(id);",
        "    }",
        "",
        "    return touchEventAccepted;",
        "}",
        "",
        "QTouchEvent *QQuickWindowPrivate::touchEventForItemBounds(QQuickItem *target, const QTouchEvent \u0026originalEvent)",
        "{",
        "    const QList\u003cQTouchEvent::TouchPoint\u003e \u0026touchPoints \u003d originalEvent.touchPoints();",
        "    QList\u003cQTouchEvent::TouchPoint\u003e pointsInBounds;",
        "    // if all points are stationary, the list of points should be empty to signal a no-op",
        "    if (originalEvent.touchPointStates() !\u003d Qt::TouchPointStationary) {",
        "        for (int i \u003d 0; i \u003c touchPoints.count(); ++i) {",
        "            const QTouchEvent::TouchPoint \u0026tp \u003d touchPoints.at(i);",
        "            if (tp.state() \u003d\u003d Qt::TouchPointPressed) {",
        "                QPointF p \u003d target-\u003emapFromScene(tp.scenePos());",
        "                if (target-\u003econtains(p))",
        "                    pointsInBounds.append(tp);",
        "            } else {",
        "                pointsInBounds.append(tp);",
        "            }",
        "        }",
        "        transformTouchPoints(pointsInBounds, QQuickItemPrivate::get(target)-\u003ewindowToItemTransform());",
        "    }",
        "",
        "    QTouchEvent* touchEvent \u003d touchEventWithPoints(originalEvent, pointsInBounds);",
        "    touchEvent-\u003esetTarget(target);",
        "    return touchEvent;",
        "}",
        "",
        "QTouchEvent *QQuickWindowPrivate::touchEventWithPoints(const QTouchEvent \u0026event, const QList\u003cQTouchEvent::TouchPoint\u003e \u0026newPoints)",
        "{",
        "    Qt::TouchPointStates eventStates;",
        "    for (int i\u003d0; i\u003cnewPoints.count(); i++)",
        "        eventStates |\u003d newPoints[i].state();",
        "    // if all points have the same state, set the event type accordingly",
        "    QEvent::Type eventType \u003d event.type();",
        "    switch (eventStates) {",
        "        case Qt::TouchPointPressed:",
        "            eventType \u003d QEvent::TouchBegin;",
        "            break;",
        "        case Qt::TouchPointReleased:",
        "            eventType \u003d QEvent::TouchEnd;",
        "            break;",
        "        default:",
        "            eventType \u003d QEvent::TouchUpdate;",
        "            break;",
        "    }",
        "",
        "    QTouchEvent *touchEvent \u003d new QTouchEvent(eventType);",
        "    touchEvent-\u003esetWindow(event.window());",
        "    touchEvent-\u003esetTarget(event.target());",
        "    touchEvent-\u003esetDevice(event.device());",
        "    touchEvent-\u003esetModifiers(event.modifiers());",
        "    touchEvent-\u003esetTouchPoints(newPoints);",
        "    touchEvent-\u003esetTouchPointStates(eventStates);",
        "    touchEvent-\u003esetTimestamp(event.timestamp());",
        "    touchEvent-\u003eaccept();",
        "    return touchEvent;",
        "}",
        "",
        "#ifndef QT_NO_DRAGANDDROP",
        "void QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QEvent *event)",
        "{",
        "    Q_Q(QQuickWindow);",
        "    grabber-\u003eresetTarget();",
        "    QQuickDragGrabber::iterator grabItem \u003d grabber-\u003ebegin();",
        "    if (grabItem !\u003d grabber-\u003eend()) {",
        "        Q_ASSERT(event-\u003etype() !\u003d QEvent::DragEnter);",
        "        if (event-\u003etype() \u003d\u003d QEvent::Drop) {",
        "            QDropEvent *e \u003d static_cast\u003cQDropEvent *\u003e(event);",
        "            for (e-\u003esetAccepted(false); !e-\u003eisAccepted() \u0026\u0026 grabItem !\u003d grabber-\u003eend(); grabItem \u003d grabber-\u003erelease(grabItem)) {",
        "                QPointF p \u003d (**grabItem)-\u003emapFromScene(e-\u003epos());",
        "                QDropEvent translatedEvent(",
        "                        p.toPoint(),",
        "                        e-\u003epossibleActions(),",
        "                        e-\u003emimeData(),",
        "                        e-\u003emouseButtons(),",
        "                        e-\u003ekeyboardModifiers());",
        "                QQuickDropEventEx::copyActions(\u0026translatedEvent, *e);",
        "                q-\u003esendEvent(**grabItem, \u0026translatedEvent);",
        "                e-\u003esetAccepted(translatedEvent.isAccepted());",
        "                e-\u003esetDropAction(translatedEvent.dropAction());",
        "                grabber-\u003esetTarget(**grabItem);",
        "            }",
        "        }",
        "        if (event-\u003etype() !\u003d QEvent::DragMove) {    // Either an accepted drop or a leave.",
        "            QDragLeaveEvent leaveEvent;",
        "            for (; grabItem !\u003d grabber-\u003eend(); grabItem \u003d grabber-\u003erelease(grabItem))",
        "                q-\u003esendEvent(**grabItem, \u0026leaveEvent);",
        "            return;",
        "        } else for (; grabItem !\u003d grabber-\u003eend(); grabItem \u003d grabber-\u003erelease(grabItem)) {",
        "            QDragMoveEvent *moveEvent \u003d static_cast\u003cQDragMoveEvent *\u003e(event);",
        "            if (deliverDragEvent(grabber, **grabItem, moveEvent)) {",
        "                moveEvent-\u003esetAccepted(true);",
        "                for (++grabItem; grabItem !\u003d grabber-\u003eend();) {",
        "                    QPointF p \u003d (**grabItem)-\u003emapFromScene(moveEvent-\u003epos());",
        "                    if ((**grabItem)-\u003econtains(p)) {",
        "                        QDragMoveEvent translatedEvent(",
        "                                p.toPoint(),",
        "                                moveEvent-\u003epossibleActions(),",
        "                                moveEvent-\u003emimeData(),",
        "                                moveEvent-\u003emouseButtons(),",
        "                                moveEvent-\u003ekeyboardModifiers());",
        "                        QQuickDropEventEx::copyActions(\u0026translatedEvent, *moveEvent);",
        "                        q-\u003esendEvent(**grabItem, \u0026translatedEvent);",
        "                        ++grabItem;",
        "                    } else {",
        "                        QDragLeaveEvent leaveEvent;",
        "                        q-\u003esendEvent(**grabItem, \u0026leaveEvent);",
        "                        grabItem \u003d grabber-\u003erelease(grabItem);",
        "                    }",
        "                }",
        "                return;",
        "            } else {",
        "                QDragLeaveEvent leaveEvent;",
        "                q-\u003esendEvent(**grabItem, \u0026leaveEvent);",
        "            }",
        "        }",
        "    }",
        "    if (event-\u003etype() \u003d\u003d QEvent::DragEnter || event-\u003etype() \u003d\u003d QEvent::DragMove) {",
        "        QDragMoveEvent *e \u003d static_cast\u003cQDragMoveEvent *\u003e(event);",
        "        QDragEnterEvent enterEvent(",
        "                e-\u003epos(),",
        "                e-\u003epossibleActions(),",
        "                e-\u003emimeData(),",
        "                e-\u003emouseButtons(),",
        "                e-\u003ekeyboardModifiers());",
        "        QQuickDropEventEx::copyActions(\u0026enterEvent, *e);",
        "        event-\u003esetAccepted(deliverDragEvent(grabber, contentItem, \u0026enterEvent));",
        "    }",
        "}",
        "",
        "bool QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QQuickItem *item, QDragMoveEvent *event)",
        "{",
        "    Q_Q(QQuickWindow);",
        "    bool accepted \u003d false;",
        "    QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "    if (!item-\u003eisVisible() || !item-\u003eisEnabled() || QQuickItemPrivate::get(item)-\u003eculled)",
        "        return false;",
        "",
        "    QPointF p \u003d item-\u003emapFromScene(event-\u003epos());",
        "    if (item-\u003econtains(p)) {",
        "        if (event-\u003etype() \u003d\u003d QEvent::DragMove || itemPrivate-\u003eflags \u0026 QQuickItem::ItemAcceptsDrops) {",
        "            QDragMoveEvent translatedEvent(",
        "                    p.toPoint(),",
        "                    event-\u003epossibleActions(),",
        "                    event-\u003emimeData(),",
        "                    event-\u003emouseButtons(),",
        "                    event-\u003ekeyboardModifiers(),",
        "                    event-\u003etype());",
        "            QQuickDropEventEx::copyActions(\u0026translatedEvent, *event);",
        "            q-\u003esendEvent(item, \u0026translatedEvent);",
        "            if (event-\u003etype() \u003d\u003d QEvent::DragEnter) {",
        "                if (translatedEvent.isAccepted()) {",
        "                    grabber-\u003egrab(item);",
        "                    accepted \u003d true;",
        "                }",
        "            } else {",
        "                accepted \u003d true;",
        "            }",
        "        }",
        "    } else if (itemPrivate-\u003eflags \u0026 QQuickItem::ItemClipsChildrenToShape) {",
        "        return false;",
        "    }",
        "",
        "    QDragEnterEvent enterEvent(",
        "            event-\u003epos(),",
        "            event-\u003epossibleActions(),",
        "            event-\u003emimeData(),",
        "            event-\u003emouseButtons(),",
        "            event-\u003ekeyboardModifiers());",
        "    QQuickDropEventEx::copyActions(\u0026enterEvent, *event);",
        "    QList\u003cQQuickItem *\u003e children \u003d itemPrivate-\u003epaintOrderChildItems();",
        "    for (int ii \u003d children.count() - 1; ii \u003e\u003d 0; --ii) {",
        "        if (deliverDragEvent(grabber, children.at(ii), \u0026enterEvent))",
        "            return true;",
        "    }",
        "",
        "    return accepted;",
        "}",
        "#endif // QT_NO_DRAGANDDROP",
        "",
        "#ifndef QT_NO_CURSOR",
        "void QQuickWindowPrivate::updateCursor(const QPointF \u0026scenePos)",
        "{",
        "    Q_Q(QQuickWindow);",
        "",
        "    QQuickItem *oldCursorItem \u003d cursorItem;",
        "    cursorItem \u003d findCursorItem(contentItem, scenePos);",
        "",
        "    if (cursorItem !\u003d oldCursorItem) {",
        "        if (cursorItem)",
        "            q-\u003esetCursor(cursorItem-\u003ecursor());",
        "        else",
        "            q-\u003eunsetCursor();",
        "    }",
        "}",
        "",
        "QQuickItem *QQuickWindowPrivate::findCursorItem(QQuickItem *item, const QPointF \u0026scenePos)",
        "{",
        "    QQuickItemPrivate *itemPrivate \u003d QQuickItemPrivate::get(item);",
        "    if (itemPrivate-\u003eflags \u0026 QQuickItem::ItemClipsChildrenToShape) {",
        "        QPointF p \u003d item-\u003emapFromScene(scenePos);",
        "        if (!item-\u003econtains(p))",
        "            return 0;",
        "    }",
        "",
        "    const int numCursorsInHierarchy \u003d itemPrivate-\u003eextra.isAllocated() ? itemPrivate-\u003eextra.value().numItemsWithCursor : 0;",
        "    const int numChildrenWithCursor \u003d itemPrivate-\u003ehasCursor ? numCursorsInHierarchy-1 : numCursorsInHierarchy;",
        "",
        "    if (numChildrenWithCursor \u003e 0) {",
        "        QList\u003cQQuickItem *\u003e children \u003d itemPrivate-\u003epaintOrderChildItems();",
        "        for (int ii \u003d children.count() - 1; ii \u003e\u003d 0; --ii) {",
        "            QQuickItem *child \u003d children.at(ii);",
        "            if (!child-\u003eisVisible() || !child-\u003eisEnabled() || QQuickItemPrivate::get(child)-\u003eculled)",
        "                continue;",
        "            if (QQuickItem *cursorItem \u003d findCursorItem(child, scenePos))",
        "                return cursorItem;",
        "        }",
        "    }",
        "",
        "    if (itemPrivate-\u003ehasCursor) {",
        "        QPointF p \u003d item-\u003emapFromScene(scenePos);",
        "        if (item-\u003econtains(p))",
        "            return item;",
        "    }",
        "    return 0;",
        "}",
        "#endif",
        "",
        "bool QQuickWindowPrivate::sendFilteredTouchEvent(QQuickItem *target, QQuickItem *item, QTouchEvent *event)",
        "{",
        "    if (!target)",
        "        return false;",
        "",
        "    QQuickItemPrivate *targetPrivate \u003d QQuickItemPrivate::get(target);",
        "    if (targetPrivate-\u003efiltersChildMouseEvents) {",
        "        QScopedPointer\u003cQTouchEvent\u003e targetEvent(touchEventForItemBounds(target, *event));",
        "        if (!targetEvent-\u003etouchPoints().isEmpty()) {",
        "            QVector\u003cint\u003e touchIds;",
        "            for (int i \u003d 0; i \u003c event-\u003etouchPoints().size(); ++i)",
        "                touchIds.append(event-\u003etouchPoints().at(i).id());",
        "            if (target-\u003echildMouseEventFilter(item, targetEvent.data())) {",
        "                target-\u003egrabTouchPoints(touchIds);",
        "                if (mouseGrabberItem) {",
        "                    mouseGrabberItem-\u003eungrabMouse();",
        "                    touchMouseId \u003d -1;",
        "                }",
        "                return true;",
        "            }",
        "",
        "            // Only offer a mouse event to the filter if we have one point",
        "            if (targetEvent-\u003etouchPoints().count() \u003d\u003d 1) {",
        "                QEvent::Type t;",
        "                const QTouchEvent::TouchPoint \u0026tp \u003d targetEvent-\u003etouchPoints().first();",
        "                switch (tp.state()) {",
        "                case Qt::TouchPointPressed:",
        "                    t \u003d QEvent::MouseButtonPress;",
        "                    break;",
        "                case Qt::TouchPointReleased:",
        "                    t \u003d QEvent::MouseButtonRelease;",
        "                    break;",
        "                default:",
        "                    // move or stationary",
        "                    t \u003d QEvent::MouseMove;",
        "                    break;",
        "                }",
        "",
        "                // targetEvent is already transformed wrt local position, velocity, etc.",
        "                QScopedPointer\u003cQMouseEvent\u003e mouseEvent(touchToMouseEvent(t, targetEvent-\u003etouchPoints().first(), event, item, false));",
        "                if (target-\u003echildMouseEventFilter(item, mouseEvent.data())) {",
        "                    itemForTouchPointId[tp.id()] \u003d target;",
        "                    touchMouseId \u003d tp.id();",
        "                    target-\u003egrabMouse();",
        "                    return true;",
        "                }",
        "            }",
        "        }",
        "    }",
        "",
        "    return sendFilteredTouchEvent(target-\u003eparentItem(), item, event);",
        "}",
        "",
        "bool QQuickWindowPrivate::sendFilteredMouseEvent(QQuickItem *target, QQuickItem *item, QEvent *event)",
        "{",
        "    if (!target)",
        "        return false;",
        "",
        "    QQuickItemPrivate *targetPrivate \u003d QQuickItemPrivate::get(target);",
        "    if (targetPrivate-\u003efiltersChildMouseEvents)",
        "        if (target-\u003echildMouseEventFilter(item, event))",
        "            return true;",
        "",
        "    if (sendFilteredMouseEvent(target-\u003eparentItem(), item, event))",
        "        return true;",
        "",
        "    return false;",
        "}",
        "",
        "bool QQuickWindowPrivate::dragOverThreshold(qreal d, Qt::Axis axis, QMouseEvent *event, int startDragThreshold)",
        "{",
        "    QStyleHints *styleHints \u003d qApp-\u003estyleHints();",
        "    int caps \u003d QGuiApplicationPrivate::mouseEventCaps(event);",
        "    bool dragVelocityLimitAvailable \u003d (caps \u0026 QTouchDevice::Velocity)",
        "        \u0026\u0026 styleHints-\u003estartDragVelocity();",
        "    bool overThreshold \u003d qAbs(d) \u003e (startDragThreshold \u003e\u003d 0 ? startDragThreshold : styleHints-\u003estartDragDistance());",
        "    if (dragVelocityLimitAvailable) {",
        "        QVector2D velocityVec \u003d QGuiApplicationPrivate::mouseEventVelocity(event);",
        "        qreal velocity \u003d axis \u003d\u003d Qt::XAxis ? velocityVec.x() : velocityVec.y();",
        "        overThreshold |\u003d qAbs(velocity) \u003e styleHints-\u003estartDragVelocity();",
        "    }",
        "    return overThreshold;",
        "}",
        "",
        "/*!",
        "    \\qmlproperty list\u003cObject\u003e Window::data",
        "    \\default",
        "",
        "    The data property allows you to freely mix visual children, resources",
        "    and other Windows in a Window.",
        "",
        "    If you assign another Window to the data list, the nested window will",
        "    become \"transient for\" the outer Window.",
        "",
        "    If you assign an \\l Item to the data list, it becomes a child of the",
        "    Window\u0027s \\l contentItem, so that it appears inside the window. The item\u0027s",
        "    parent will be the window\u0027s contentItem, which is the root of the Item",
        "    ownership tree within that Window.",
        "",
        "    If you assign any other object type, it is added as a resource.",
        "",
        "    It should not generally be necessary to refer to the \\c data property,",
        "    as it is the default property for Window and thus all child items are",
        "    automatically assigned to this property.",
        "",
        "    \\sa QWindow::transientParent()",
        " */",
        "",
        "void QQuickWindowPrivate::data_append(QQmlListProperty\u003cQObject\u003e *property, QObject *o)",
        "{",
        "    if (!o)",
        "        return;",
        "    QQuickWindow *that \u003d static_cast\u003cQQuickWindow *\u003e(property-\u003eobject);",
        "    if (QQuickWindow *window \u003d qmlobject_cast\u003cQQuickWindow *\u003e(o))",
        "        window-\u003esetTransientParent(that);",
        "    QQmlListProperty\u003cQObject\u003e itemProperty \u003d QQuickItemPrivate::get(that-\u003econtentItem())-\u003edata();",
        "    itemProperty.append(\u0026itemProperty, o);",
        "}",
        "",
        "int QQuickWindowPrivate::data_count(QQmlListProperty\u003cQObject\u003e *property)",
        "{",
        "    QQuickWindow *win \u003d static_cast\u003cQQuickWindow*\u003e(property-\u003eobject);",
        "    if (!win || !win-\u003econtentItem() || !QQuickItemPrivate::get(win-\u003econtentItem())-\u003edata().count)",
        "        return 0;",
        "    QQmlListProperty\u003cQObject\u003e itemProperty \u003d QQuickItemPrivate::get(win-\u003econtentItem())-\u003edata();",
        "    return itemProperty.count(\u0026itemProperty);",
        "}",
        "",
        "QObject *QQuickWindowPrivate::data_at(QQmlListProperty\u003cQObject\u003e *property, int i)",
        "{",
        "    QQuickWindow *win \u003d static_cast\u003cQQuickWindow*\u003e(property-\u003eobject);",
        "    QQmlListProperty\u003cQObject\u003e itemProperty \u003d QQuickItemPrivate::get(win-\u003econtentItem())-\u003edata();",
        "    return itemProperty.at(\u0026itemProperty, i);",
        "}",
        "",
        "void QQuickWindowPrivate::data_clear(QQmlListProperty\u003cQObject\u003e *property)",
        "{",
        "    QQuickWindow *win \u003d static_cast\u003cQQuickWindow*\u003e(property-\u003eobject);",
        "    QQmlListProperty\u003cQObject\u003e itemProperty \u003d QQuickItemPrivate::get(win-\u003econtentItem())-\u003edata();",
        "    itemProperty.clear(\u0026itemProperty);",
        "}",
        "",
        "bool QQuickWindowPrivate::isRenderable() const",
        "{",
        "    Q_Q(const QQuickWindow);",
        "    return (forceRendering || (q-\u003eisExposed() \u0026\u0026 q-\u003eisVisible())) \u0026\u0026 q-\u003egeometry().isValid();",
        "}",
        ""
      ]
    },
    {
      "b": [
        "void QQuickWindowPrivate::contextCreationFailureMessage(const QSurfaceFormat \u0026format,",
        "                                                        QString *translatedMessage,",
        "                                                        QString *untranslatedMessage,",
        "                                                        bool isEs)",
        "{",
        "    const QString contextType \u003d QLatin1String(isEs ? \"EGL\" : \"OpenGL\");",
        "    QString formatStr;",
        "    QDebug(\u0026formatStr) \u003c\u003c format;",
        "#if defined(Q_OS_WIN32)",
        "    const bool isDebug \u003d QLibraryInfo::isDebugBuild();",
        "    const QString eglLibName \u003d QLatin1String(isDebug ? \"libEGLd.dll\" : \"libEGL.dll\");",
        "    const QString glesLibName \u003d QLatin1String(isDebug ? \"libGLESv2d.dll\" : \"libGLESv2.dll\");",
        "     //: %1 Context type (Open GL, EGL), ANGLE %2, %3 library names",
        "    const char msg[] \u003d QT_TRANSLATE_NOOP(\"QQuickWindow\",",
        "        \"Failed to create %1 context for format %2.\"",
        "        \"This is most likely caused by not having the necessary graphics drivers installed.\\n\\n\"",
        "        \"Install a driver providing OpenGL 2.0 or higher, or, if this is not possible, \"",
        "        \"make sure the ANGLE Open GL ES 2.0 emulation libraries (%3, %4 and d3dcompiler_*.dll) \"",
        "        \"are available in the application executable\u0027s directory or in a location listed in PATH.\");",
        "    *translatedMessage \u003d QQuickWindow::tr(msg).arg(contextType, formatStr, eglLibName, glesLibName);",
        "    *untranslatedMessage \u003d QString::fromLatin1(msg).arg(contextType, formatStr, eglLibName, glesLibName);",
        "#else // Q_OS_WIN32",
        "    //: %1 Context type (Open GL, EGL), %2 format specification",
        "    const char msg[] \u003d QT_TRANSLATE_NOOP(\"QQuickWindow\",",
        "                                         \"Failed to create %1 context for format %2\");",
        "    *translatedMessage \u003d QQuickWindow::tr(msg).arg(contextType, formatStr);",
        "    *untranslatedMessage \u003d QString::fromLatin1(msg).arg(contextType, formatStr);",
        "#endif // !Q_OS_WIN32",
        "}",
        ""
      ]
    },
    {
      "ab": [
        "/*!",
        "    Propagates an event \\a e to a QQuickItem \\a item on the window.",
        "",
        "    The return value is currently not used.",
        "*/",
        "bool QQuickWindow::sendEvent(QQuickItem *item, QEvent *e)",
        "{",
        "    Q_D(QQuickWindow);",
        "",
        "    if (!item) {",
        "        qWarning(\"QQuickWindow::sendEvent: Cannot send event to a null item\");",
        "        return false;",
        "    }",
        "",
        "    Q_ASSERT(e);",
        "",
        "    switch (e-\u003etype()) {",
        "    case QEvent::KeyPress:",
        "    case QEvent::KeyRelease:",
        "        e-\u003eaccept();",
        "        QCoreApplication::sendEvent(item, e);",
        "        while (!e-\u003eisAccepted() \u0026\u0026 (item \u003d item-\u003eparentItem())) {",
        "            e-\u003eaccept();",
        "            QCoreApplication::sendEvent(item, e);",
        "        }",
        "        break;",
        "    case QEvent::MouseButtonPress:",
        "    case QEvent::MouseButtonRelease:",
        "    case QEvent::MouseButtonDblClick:",
        "    case QEvent::MouseMove:",
        "        // XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?",
        "        if (!d-\u003esendFilteredMouseEvent(item-\u003eparentItem(), item, e)) {",
        "            // accept because qml items by default accept and have to explicitly opt out of accepting",
        "            e-\u003eaccept();",
        "            QCoreApplication::sendEvent(item, e);",
        "        }",
        "        break;",
        "    case QEvent::UngrabMouse:",
        "        if (!d-\u003esendFilteredMouseEvent(item-\u003eparentItem(), item, e)) {",
        "            e-\u003eaccept();",
        "            item-\u003emouseUngrabEvent();",
        "        }",
        "        break;",
        "#ifndef QT_NO_WHEELEVENT",
        "    case QEvent::Wheel:",
        "#endif",
        "#ifndef QT_NO_DRAGANDDROP",
        "    case QEvent::DragEnter:",
        "    case QEvent::DragMove:",
        "    case QEvent::DragLeave:",
        "    case QEvent::Drop:",
        "#endif",
        "    case QEvent::FocusIn:",
        "    case QEvent::FocusOut:",
        "    case QEvent::HoverEnter:",
        "    case QEvent::HoverLeave:",
        "    case QEvent::HoverMove:",
        "    case QEvent::TouchCancel:",
        "        QCoreApplication::sendEvent(item, e);",
        "        break;",
        "    case QEvent::TouchBegin:",
        "    case QEvent::TouchUpdate:",
        "    case QEvent::TouchEnd:",
        "        d-\u003esendFilteredTouchEvent(item-\u003eparentItem(), item, static_cast\u003cQTouchEvent *\u003e(e));",
        "        break;",
        "    default:",
        "        break;",
        "    }",
        "",
        "    return false;",
        "}",
        "",
        "void QQuickWindowPrivate::cleanupNodes()",
        "{",
        "    for (int ii \u003d 0; ii \u003c cleanupNodeList.count(); ++ii)",
        "        delete cleanupNodeList.at(ii);",
        "    cleanupNodeList.clear();",
        "}",
        "",
        "void QQuickWindowPrivate::cleanupNodesOnShutdown(QQuickItem *item)",
        "{",
        "    QQuickItemPrivate *p \u003d QQuickItemPrivate::get(item);",
        "    if (p-\u003eitemNodeInstance) {",
        "        delete p-\u003eitemNodeInstance;",
        "        p-\u003eitemNodeInstance \u003d 0;",
        "",
        "        if (p-\u003eextra.isAllocated()) {",
        "            p-\u003eextra-\u003eopacityNode \u003d 0;",
        "            p-\u003eextra-\u003eclipNode \u003d 0;",
        "            p-\u003eextra-\u003erootNode \u003d 0;",
        "        }",
        "",
        "        p-\u003egroupNode \u003d 0;",
        "        p-\u003epaintNode \u003d 0;",
        "",
        "        p-\u003edirty(QQuickItemPrivate::Window);",
        "    }",
        "",
        "    for (int ii \u003d 0; ii \u003c p-\u003echildItems.count(); ++ii)",
        "        cleanupNodesOnShutdown(p-\u003echildItems.at(ii));",
        "}",
        "",
        "// This must be called from the render thread, with the main thread frozen",
        "void QQuickWindowPrivate::cleanupNodesOnShutdown()",
        "{",
        "    Q_Q(QQuickWindow);",
        "    cleanupNodes();",
        "    cleanupNodesOnShutdown(contentItem);",
        "    QSet\u003cQQuickItem *\u003e::const_iterator it \u003d parentlessItems.begin();",
        "    for (; it !\u003d parentlessItems.end(); ++it)",
        "        cleanupNodesOnShutdown(*it);",
        "    q-\u003ecleanupSceneGraph();",
        "}",
        "",
        "void QQuickWindowPrivate::updateDirtyNodes()",
        "{",
        "#ifdef DIRTY_DEBUG",
        "    qWarning() \u003c\u003c \"QQuickWindowPrivate::updateDirtyNodes():\";",
        "#endif",
        "",
        "    cleanupNodes();",
        "",
        "    QQuickItem *updateList \u003d dirtyItemList;",
        "    dirtyItemList \u003d 0;",
        "    if (updateList) QQuickItemPrivate::get(updateList)-\u003eprevDirtyItem \u003d \u0026updateList;",
        "",
        "    while (updateList) {",
        "        QQuickItem *item \u003d updateList;",
        "        QQuickItemPrivate *itemPriv \u003d QQuickItemPrivate::get(item);",
        "        itemPriv-\u003eremoveFromDirtyList();",
        "",
        "#ifdef DIRTY_DEBUG",
        "        qWarning() \u003c\u003c \"   QSGNode:\" \u003c\u003c item \u003c\u003c qPrintable(itemPriv-\u003edirtyToString());",
        "#endif",
        "        updateDirtyNode(item);",
        "    }",
        "}",
        "",
        "void QQuickWindowPrivate::updateDirtyNode(QQuickItem *item)",
        "{",
        "    QQuickItemPrivate *itemPriv \u003d QQuickItemPrivate::get(item);",
        "    quint32 dirty \u003d itemPriv-\u003edirtyAttributes;",
        "    itemPriv-\u003edirtyAttributes \u003d 0;",
        "",
        "    if ((dirty \u0026 QQuickItemPrivate::TransformUpdateMask) ||",
        "        (dirty \u0026 QQuickItemPrivate::Size \u0026\u0026 itemPriv-\u003eorigin() !\u003d QQuickItem::TopLeft \u0026\u0026",
        "         (itemPriv-\u003escale() !\u003d 1. || itemPriv-\u003erotation() !\u003d 0.))) {",
        "",
        "        QMatrix4x4 matrix;",
        "",
        "        if (itemPriv-\u003ex !\u003d 0. || itemPriv-\u003ey !\u003d 0.)",
        "            matrix.translate(itemPriv-\u003ex, itemPriv-\u003ey);",
        "",
        "        for (int ii \u003d itemPriv-\u003etransforms.count() - 1; ii \u003e\u003d 0; --ii)",
        "            itemPriv-\u003etransforms.at(ii)-\u003eapplyTo(\u0026matrix);",
        "",
        "        if (itemPriv-\u003escale() !\u003d 1. || itemPriv-\u003erotation() !\u003d 0.) {",
        "            QPointF origin \u003d item-\u003etransformOriginPoint();",
        "            matrix.translate(origin.x(), origin.y());",
        "            if (itemPriv-\u003escale() !\u003d 1.)",
        "                matrix.scale(itemPriv-\u003escale(), itemPriv-\u003escale());",
        "            if (itemPriv-\u003erotation() !\u003d 0.)",
        "                matrix.rotate(itemPriv-\u003erotation(), 0, 0, 1);",
        "            matrix.translate(-origin.x(), -origin.y());",
        "        }",
        "",
        "        itemPriv-\u003eitemNode()-\u003esetMatrix(matrix);",
        "    }",
        "",
        "    bool clipEffectivelyChanged \u003d (dirty \u0026 (QQuickItemPrivate::Clip | QQuickItemPrivate::Window)) \u0026\u0026",
        "                                  ((item-\u003eclip() \u003d\u003d false) !\u003d (itemPriv-\u003eclipNode() \u003d\u003d 0));",
        "    int effectRefCount \u003d itemPriv-\u003eextra.isAllocated()?itemPriv-\u003eextra-\u003eeffectRefCount:0;",
        "    bool effectRefEffectivelyChanged \u003d (dirty \u0026 (QQuickItemPrivate::EffectReference | QQuickItemPrivate::Window)) \u0026\u0026",
        "                                  ((effectRefCount \u003d\u003d 0) !\u003d (itemPriv-\u003erootNode() \u003d\u003d 0));",
        "",
        "    if (clipEffectivelyChanged) {",
        "        QSGNode *parent \u003d itemPriv-\u003eopacityNode() ? (QSGNode *) itemPriv-\u003eopacityNode() :",
        "                                                    (QSGNode *)itemPriv-\u003eitemNode();",
        "        QSGNode *child \u003d itemPriv-\u003erootNode() ? (QSGNode *)itemPriv-\u003erootNode() :",
        "                                                (QSGNode *)itemPriv-\u003egroupNode;",
        "",
        "        if (item-\u003eclip()) {",
        "            Q_ASSERT(itemPriv-\u003eclipNode() \u003d\u003d 0);",
        "            itemPriv-\u003eextra.value().clipNode \u003d new QQuickDefaultClipNode(item-\u003eclipRect());",
        "            itemPriv-\u003eclipNode()-\u003eupdate();",
        "",
        "            if (child)",
        "                parent-\u003eremoveChildNode(child);",
        "            parent-\u003eappendChildNode(itemPriv-\u003eclipNode());",
        "            if (child)",
        "                itemPriv-\u003eclipNode()-\u003eappendChildNode(child);",
        "",
        "        } else {",
        "            Q_ASSERT(itemPriv-\u003eclipNode() !\u003d 0);",
        "            parent-\u003eremoveChildNode(itemPriv-\u003eclipNode());",
        "            if (child)",
        "                itemPriv-\u003eclipNode()-\u003eremoveChildNode(child);",
        "            delete itemPriv-\u003eclipNode();",
        "            itemPriv-\u003eextra-\u003eclipNode \u003d 0;",
        "            if (child)",
        "                parent-\u003eappendChildNode(child);",
        "        }",
        "    }",
        "",
        "    if (dirty \u0026 QQuickItemPrivate::ChildrenUpdateMask)",
        "        itemPriv-\u003echildContainerNode()-\u003eremoveAllChildNodes();",
        "",
        "    if (effectRefEffectivelyChanged) {",
        "        QSGNode *parent \u003d itemPriv-\u003eclipNode();",
        "        if (!parent)",
        "            parent \u003d itemPriv-\u003eopacityNode();",
        "        if (!parent)",
        "            parent \u003d itemPriv-\u003eitemNode();",
        "        QSGNode *child \u003d itemPriv-\u003egroupNode;",
        "",
        "        if (itemPriv-\u003eextra.isAllocated() \u0026\u0026 itemPriv-\u003eextra-\u003eeffectRefCount) {",
        "            Q_ASSERT(itemPriv-\u003erootNode() \u003d\u003d 0);",
        "            itemPriv-\u003eextra-\u003erootNode \u003d new QSGRootNode;",
        "",
        "            if (child)",
        "                parent-\u003eremoveChildNode(child);",
        "            parent-\u003eappendChildNode(itemPriv-\u003erootNode());",
        "            if (child)",
        "                itemPriv-\u003erootNode()-\u003eappendChildNode(child);",
        "        } else {",
        "            Q_ASSERT(itemPriv-\u003erootNode() !\u003d 0);",
        "            parent-\u003eremoveChildNode(itemPriv-\u003erootNode());",
        "            if (child)",
        "                itemPriv-\u003erootNode()-\u003eremoveChildNode(child);",
        "            delete itemPriv-\u003erootNode();",
        "            itemPriv-\u003eextra-\u003erootNode \u003d 0;",
        "            if (child)",
        "                parent-\u003eappendChildNode(child);",
        "        }",
        "    }",
        "",
        "    if (dirty \u0026 QQuickItemPrivate::ChildrenUpdateMask) {",
        "        QSGNode *groupNode \u003d itemPriv-\u003egroupNode;",
        "        if (groupNode)",
        "            groupNode-\u003eremoveAllChildNodes();",
        "",
        "        QList\u003cQQuickItem *\u003e orderedChildren \u003d itemPriv-\u003epaintOrderChildItems();",
        "        int ii \u003d 0;",
        "",
        "        for (; ii \u003c orderedChildren.count() \u0026\u0026 orderedChildren.at(ii)-\u003ez() \u003c 0; ++ii) {",
        "            QQuickItemPrivate *childPrivate \u003d QQuickItemPrivate::get(orderedChildren.at(ii));",
        "            if (!childPrivate-\u003eexplicitVisible \u0026\u0026",
        "                (!childPrivate-\u003eextra.isAllocated() || !childPrivate-\u003eextra-\u003eeffectRefCount))",
        "                continue;",
        "            if (childPrivate-\u003eitemNode()-\u003eparent())",
        "                childPrivate-\u003eitemNode()-\u003eparent()-\u003eremoveChildNode(childPrivate-\u003eitemNode());",
        "",
        "            itemPriv-\u003echildContainerNode()-\u003eappendChildNode(childPrivate-\u003eitemNode());",
        "        }",
        "",
        "        QSGNode *beforePaintNode \u003d itemPriv-\u003egroupNode ? itemPriv-\u003egroupNode-\u003elastChild() : 0;",
        "        if (beforePaintNode || itemPriv-\u003eextra.isAllocated())",
        "            itemPriv-\u003eextra.value().beforePaintNode \u003d beforePaintNode;",
        "",
        "        if (itemPriv-\u003epaintNode)",
        "            itemPriv-\u003echildContainerNode()-\u003eappendChildNode(itemPriv-\u003epaintNode);",
        "",
        "        for (; ii \u003c orderedChildren.count(); ++ii) {",
        "            QQuickItemPrivate *childPrivate \u003d QQuickItemPrivate::get(orderedChildren.at(ii));",
        "            if (!childPrivate-\u003eexplicitVisible \u0026\u0026",
        "                (!childPrivate-\u003eextra.isAllocated() || !childPrivate-\u003eextra-\u003eeffectRefCount))",
        "                continue;",
        "            if (childPrivate-\u003eitemNode()-\u003eparent())",
        "                childPrivate-\u003eitemNode()-\u003eparent()-\u003eremoveChildNode(childPrivate-\u003eitemNode());",
        "",
        "            itemPriv-\u003echildContainerNode()-\u003eappendChildNode(childPrivate-\u003eitemNode());",
        "        }",
        "    }",
        "",
        "    if ((dirty \u0026 QQuickItemPrivate::Size) \u0026\u0026 itemPriv-\u003eclipNode()) {",
        "        itemPriv-\u003eclipNode()-\u003esetRect(item-\u003eclipRect());",
        "        itemPriv-\u003eclipNode()-\u003eupdate();",
        "    }",
        "",
        "    if (dirty \u0026 (QQuickItemPrivate::OpacityValue | QQuickItemPrivate::Visible",
        "                 | QQuickItemPrivate::HideReference | QQuickItemPrivate::Window))",
        "    {",
        "        qreal opacity \u003d itemPriv-\u003eexplicitVisible \u0026\u0026 (!itemPriv-\u003eextra.isAllocated() || itemPriv-\u003eextra-\u003ehideRefCount \u003d\u003d 0)",
        "                      ? itemPriv-\u003eopacity() : qreal(0);",
        "",
        "        if (opacity !\u003d 1 \u0026\u0026 !itemPriv-\u003eopacityNode()) {",
        "            itemPriv-\u003eextra.value().opacityNode \u003d new QSGOpacityNode;",
        "",
        "            QSGNode *parent \u003d itemPriv-\u003eitemNode();",
        "            QSGNode *child \u003d itemPriv-\u003eclipNode();",
        "            if (!child)",
        "                child \u003d itemPriv-\u003erootNode();",
        "            if (!child)",
        "                child \u003d itemPriv-\u003egroupNode;",
        "",
        "            if (child)",
        "                parent-\u003eremoveChildNode(child);",
        "            parent-\u003eappendChildNode(itemPriv-\u003eopacityNode());",
        "            if (child)",
        "                itemPriv-\u003eopacityNode()-\u003eappendChildNode(child);",
        "        }",
        "        if (itemPriv-\u003eopacityNode())",
        "            itemPriv-\u003eopacityNode()-\u003esetOpacity(opacity);",
        "    }",
        "",
        "    if (dirty \u0026 QQuickItemPrivate::ContentUpdateMask) {",
        "",
        "        if (itemPriv-\u003eflags \u0026 QQuickItem::ItemHasContents) {",
        "            updatePaintNodeData.transformNode \u003d itemPriv-\u003eitemNode();",
        "            itemPriv-\u003epaintNode \u003d item-\u003eupdatePaintNode(itemPriv-\u003epaintNode, \u0026updatePaintNodeData);",
        "",
        "            Q_ASSERT(itemPriv-\u003epaintNode \u003d\u003d 0 ||",
        "                     itemPriv-\u003epaintNode-\u003eparent() \u003d\u003d 0 ||",
        "                     itemPriv-\u003epaintNode-\u003eparent() \u003d\u003d itemPriv-\u003echildContainerNode());",
        "",
        "            if (itemPriv-\u003epaintNode \u0026\u0026 itemPriv-\u003epaintNode-\u003eparent() \u003d\u003d 0) {",
        "                if (itemPriv-\u003eextra.isAllocated() \u0026\u0026 itemPriv-\u003eextra-\u003ebeforePaintNode)",
        "                    itemPriv-\u003echildContainerNode()-\u003einsertChildNodeAfter(itemPriv-\u003epaintNode, itemPriv-\u003eextra-\u003ebeforePaintNode);",
        "                else",
        "                    itemPriv-\u003echildContainerNode()-\u003eprependChildNode(itemPriv-\u003epaintNode);",
        "            }",
        "        } else if (itemPriv-\u003epaintNode) {",
        "            delete itemPriv-\u003epaintNode;",
        "            itemPriv-\u003epaintNode \u003d 0;",
        "        }",
        "    }",
        "",
        "#ifndef QT_NO_DEBUG",
        "    // Check consistency.",
        "    const QSGNode *nodeChain[] \u003d {",
        "        itemPriv-\u003eitemNodeInstance,",
        "        itemPriv-\u003eopacityNode(),",
        "        itemPriv-\u003eclipNode(),",
        "        itemPriv-\u003erootNode(),",
        "        itemPriv-\u003egroupNode,",
        "        itemPriv-\u003epaintNode,",
        "    };",
        "",
        "    int ip \u003d 0;",
        "    for (;;) {",
        "        while (ip \u003c 5 \u0026\u0026 nodeChain[ip] \u003d\u003d 0)",
        "            ++ip;",
        "        if (ip \u003d\u003d 5)",
        "            break;",
        "        int ic \u003d ip + 1;",
        "        while (ic \u003c 5 \u0026\u0026 nodeChain[ic] \u003d\u003d 0)",
        "            ++ic;",
        "        const QSGNode *parent \u003d nodeChain[ip];",
        "        const QSGNode *child \u003d nodeChain[ic];",
        "        if (child \u003d\u003d 0) {",
        "            Q_ASSERT(parent \u003d\u003d itemPriv-\u003egroupNode || parent-\u003echildCount() \u003d\u003d 0);",
        "        } else {",
        "            Q_ASSERT(parent \u003d\u003d itemPriv-\u003egroupNode || parent-\u003echildCount() \u003d\u003d 1);",
        "            Q_ASSERT(child-\u003eparent() \u003d\u003d parent);",
        "            bool containsChild \u003d false;",
        "            for (QSGNode *n \u003d parent-\u003efirstChild(); n; n \u003d n-\u003enextSibling())",
        "                containsChild |\u003d (n \u003d\u003d child);",
        "            Q_ASSERT(containsChild);",
        "        }",
        "        ip \u003d ic;",
        "    }",
        "#endif",
        "",
        "}",
        "",
        "bool QQuickWindowPrivate::emitError(QQuickWindow::SceneGraphError error, const QString \u0026msg)",
        "{",
        "    Q_Q(QQuickWindow);",
        "    static const QMetaMethod errorSignal \u003d QMetaMethod::fromSignal(\u0026QQuickWindow::sceneGraphError);",
        "    if (q-\u003eisSignalConnected(errorSignal)) {",
        "        emit q-\u003esceneGraphError(error, msg);",
        "        return true;",
        "    }",
        "    return false;",
        "}",
        "",
        "void QQuickWindow::maybeUpdate()",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (d-\u003erenderControl)",
        "        d-\u003erenderControl-\u003emaybeUpdate();",
        "    else",
        "        d-\u003ewindowManager-\u003emaybeUpdate(this);",
        "}",
        "",
        "void QQuickWindow::cleanupSceneGraph()",
        "{",
        "    Q_D(QQuickWindow);",
        "",
        "    if (!d-\u003erenderer)",
        "        return;",
        "",
        "    delete d-\u003erenderer-\u003erootNode();",
        "    delete d-\u003erenderer;",
        "",
        "    d-\u003erenderer \u003d 0;",
        "}",
        "",
        "void QQuickWindow::setTransientParent_helper(QQuickWindow *window)",
        "{",
        "    setTransientParent(window);",
        "    disconnect(sender(), SIGNAL(windowChanged(QQuickWindow*)),",
        "               this, SLOT(setTransientParent_helper(QQuickWindow*)));",
        "}",
        "",
        "/*!",
        "    Returns the opengl context used for rendering.",
        "",
        "    If the scene graph is not ready, this function will return 0.",
        "",
        "    \\sa sceneGraphInitialized(), sceneGraphInvalidated()",
        " */",
        "",
        "QOpenGLContext *QQuickWindow::openglContext() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "    return d-\u003econtext-\u003eopenglContext();",
        "}",
        "",
        "/*!",
        "    \\fn void QQuickWindow::frameSwapped()",
        "",
        "    This signal is emitted when the frame buffers have been swapped.",
        "",
        "    This signal will be emitted from the scene graph rendering thread.",
        "*/",
        "",
        "",
        "/*!",
        "    \\fn void QQuickWindow::sceneGraphInitialized()",
        "",
        "    This signal is emitted when the scene graph has been initialized.",
        "",
        "    This signal will be emitted from the scene graph rendering thread.",
        "",
        " */",
        "",
        "",
        "/*!",
        "    \\fn void QQuickWindow::sceneGraphInvalidated()",
        "",
        "    This signal is emitted when the scene graph has been invalidated.",
        "",
        "    This signal implies that the opengl rendering context used",
        "    has been invalidated and all user resources tied to that context",
        "    should be released.",
        "",
        "    This signal will be emitted from the scene graph rendering thread.",
        " */",
        "",
        "/*!",
        "    \\fn void QQuickWindow::sceneGraphError(SceneGraphError error, const QString \u0026message)",
        "",
        "    This signal is emitted when an error occurred during scene graph initialization.",
        "",
        "    Applications should connect to this signal if they wish to handle errors,",
        "    like OpenGL context creation failures, in a custom way. When no slot is",
        "    connected to the signal, the behavior will be different: Quick will print",
        "    the message, or show a message box, and terminate the application.",
        "",
        "    This signal will be emitted from the gui thread.",
        "",
        "    \\since 5.3",
        " */",
        "",
        "/*!",
        "    \\class QQuickCloseEvent",
        "    \\internal",
        "    \\since 5.1",
        "",
        "    \\inmodule QtQuick.Window",
        "",
        "    \\brief Notification that a \\l QQuickWindow is about to be closed",
        "*/",
        "/*!",
        "    \\qmltype CloseEvent",
        "    \\instantiates QQuickCloseEvent",
        "    \\inqmlmodule QtQuick.Window",
        "    \\ingroup qtquick-visual",
        "    \\brief Notification that a \\l Window is about to be closed",
        "    \\since 5.1",
        "",
        "    Notification that a window is about to be closed by the windowing system",
        "    (e.g. the user clicked the titlebar close button). The CloseEvent contains",
        "    an accepted property which can be set to false to abort closing the window.",
        "",
        "    \\sa Window.closing()",
        "*/",
        "",
        "/*!",
        "    \\qmlproperty bool CloseEvent::accepted",
        "",
        "    This property indicates whether the application will allow the user to",
        "    close the window.  It is true by default.",
        "*/",
        "",
        "/*!",
        "    \\fn void QQuickWindow::closing()",
        "    \\since 5.1",
        "",
        "    This signal is emitted when the window receives a QCloseEvent from the",
        "    windowing system.",
        "*/",
        "",
        "/*!",
        "    \\qmlsignal closing(CloseEvent close)",
        "    \\since 5.1",
        "",
        "    This signal is emitted when the user tries to close the window.",
        "",
        "    This signal includes a closeEvent parameter. The \\a close \\l accepted",
        "    property is true by default so that the window is allowed to close; but you",
        "    can implement an onClosing() handler and set close.accepted \u003d false if",
        "    you need to do something else before the window can be closed.",
        " */",
        "",
        "",
        "/*!",
        "    Sets the render target for this window to be \\a fbo.",
        "",
        "    The specified fbo must be created in the context of the window",
        "    or one that shares with it.",
        "",
        "    \\warning",
        "    This function can only be called from the thread doing",
        "    the rendering.",
        " */",
        "",
        "void QQuickWindow::setRenderTarget(QOpenGLFramebufferObject *fbo)",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (d-\u003econtext \u0026\u0026 QThread::currentThread() !\u003d d-\u003econtext-\u003ethread()) {",
        "        qWarning(\"QQuickWindow::setRenderThread: Cannot set render target from outside the rendering thread\");",
        "        return;",
        "    }",
        "",
        "    d-\u003erenderTarget \u003d fbo;",
        "    if (fbo) {",
        "        d-\u003erenderTargetId \u003d fbo-\u003ehandle();",
        "        d-\u003erenderTargetSize \u003d fbo-\u003esize();",
        "    } else {",
        "        d-\u003erenderTargetId \u003d 0;",
        "        d-\u003erenderTargetSize \u003d QSize();",
        "    }",
        "}",
        "",
        "/*!",
        "    \\overload",
        "",
        "    Sets the render target for this window to be an FBO with",
        "    \\a fboId and \\a size.",
        "",
        "    The specified FBO must be created in the context of the window",
        "    or one that shares with it.",
        "",
        "    \\warning",
        "    This function can only be called from the thread doing",
        "    the rendering.",
        "*/",
        "",
        "void QQuickWindow::setRenderTarget(uint fboId, const QSize \u0026size)",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (d-\u003econtext \u0026\u0026 QThread::currentThread() !\u003d d-\u003econtext-\u003ethread()) {",
        "        qWarning(\"QQuickWindow::setRenderThread: Cannot set render target from outside the rendering thread\");",
        "        return;",
        "    }",
        "",
        "    d-\u003erenderTargetId \u003d fboId;",
        "    d-\u003erenderTargetSize \u003d size;",
        "",
        "    // Unset any previously set instance...",
        "    d-\u003erenderTarget \u003d 0;",
        "}",
        "",
        "",
        "/*!",
        "    Returns the FBO id of the render target when set; otherwise returns 0.",
        " */",
        "uint QQuickWindow::renderTargetId() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "    return d-\u003erenderTargetId;",
        "}",
        "",
        "/*!",
        "    Returns the size of the currently set render target; otherwise returns an empty size.",
        " */",
        "QSize QQuickWindow::renderTargetSize() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "    return d-\u003erenderTargetSize;",
        "}",
        "",
        "",
        "",
        "",
        "/*!",
        "    Returns the render target for this window.",
        "",
        "    The default is to render to the surface of the window, in which",
        "    case the render target is 0.",
        " */",
        "QOpenGLFramebufferObject *QQuickWindow::renderTarget() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "    return d-\u003erenderTarget;",
        "}",
        "",
        "",
        "/*!",
        "    Grabs the contents of the window and returns it as an image.",
        "",
        "    It is possible to call the grabWindow() function when the window is not",
        "    visible. This requires that the window is \\l{QWindow::create()} {created}",
        "    and has a valid size and that no other QQuickWindow instances are rendering",
        "    in the same process.",
        "",
        "    \\warning Calling this function will cause performance problems.",
        "",
        "    \\warning This function can only be called from the GUI thread.",
        " */",
        "QImage QQuickWindow::grabWindow()",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (!isVisible()) {",
        "",
        "        if (d-\u003econtext-\u003eopenglContext()) {",
        "            qWarning(\"QQuickWindow::grabWindow: scene graph already in use\");",
        "            return QImage();",
        "        }",
        "",
        "        if (!handle() || !size().isValid()) {",
        "            qWarning(\"QQuickWindow::grabWindow: window must be created and have a valid size\");",
        "            return QImage();",
        "        }",
        "",
        "        QOpenGLContext context;",
        "        context.setFormat(requestedFormat());",
        "        context.setShareContext(QSGContext::sharedOpenGLContext());",
        "        context.create();",
        "        context.makeCurrent(this);",
        "        d-\u003econtext-\u003einitialize(\u0026context);",
        "",
        "        d-\u003epolishItems();",
        "        d-\u003esyncSceneGraph();",
        "        d-\u003erenderSceneGraph(size());",
        "",
        "        QImage image \u003d qt_gl_read_framebuffer(size(), false, false);",
        "        d-\u003ecleanupNodesOnShutdown();",
        "        d-\u003econtext-\u003einvalidate();",
        "        context.doneCurrent();",
        "",
        "        return image;",
        "    }",
        "",
        "    return d-\u003erenderControl ? d-\u003erenderControl-\u003egrab() : d-\u003ewindowManager-\u003egrab(this);",
        "}",
        "",
        "/*!",
        "    Returns an incubation controller that splices incubation between frames",
        "    for this window. QQuickView automatically installs this controller for you,",
        "    otherwise you will need to install it yourself using \\l{QQmlEngine::setIncubationController()}.",
        "",
        "    The controller is owned by the window and will be destroyed when the window",
        "    is deleted.",
        "*/",
        "QQmlIncubationController *QQuickWindow::incubationController() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "",
        "    if (!d-\u003ewindowManager)",
        "        return 0; // TODO: make sure that this is safe",
        "",
        "    if (!d-\u003eincubationController)",
        "        d-\u003eincubationController \u003d new QQuickWindowIncubationController(d-\u003ewindowManager);",
        "    return d-\u003eincubationController;",
        "}",
        "",
        "",
        "",
        "/*!",
        "    \\enum QQuickWindow::CreateTextureOption",
        "",
        "    The CreateTextureOption enums are used to customize a texture is wrapped.",
        "",
        "    \\value TextureHasAlphaChannel The texture has an alpha channel and should",
        "    be drawn using blending.",
        "",
        "    \\value TextureHasMipmaps The texture has mipmaps and can be drawn with",
        "    mipmapping enabled.",
        "",
        "    \\value TextureOwnsGLTexture The texture object owns the texture id and",
        "    will delete the GL texture when the texture object is deleted.",
        "",
        "    \\value TextureCanUseAtlas The image can be uploaded into a texture atlas.",
        " */",
        "",
        "/*!",
        "    \\enum QQuickWindow::SceneGraphError",
        "",
        "    This enum describes the error in a sceneGraphError() signal.",
        "",
        "    \\value ContextNotAvailable OpenGL context creation failed. This typically means that",
        "    no suitable OpenGL implementation was found, for example because no graphics drivers",
        "    are installed and so no OpenGL 2 support is present. On mobile and embedded boards",
        "    that use OpenGL ES such an error is likely to indicate issues in the windowing system",
        "    integration and possibly an incorrect configuration of Qt.",
        "",
        "    \\since 5.3",
        " */",
        "",
        "/*!",
        "    \\fn void QQuickWindow::beforeSynchronizing()",
        "",
        "    This signal is emitted before the scene graph is synchronized with the QML state.",
        "",
        "    This signal can be used to do any preparation required before calls to",
        "    QQuickItem::updatePaintNode().",
        "",
        "    The GL context used for rendering the scene graph will be bound at this point.",
        "",
        "    \\warning This signal is emitted from the scene graph rendering thread. If your",
        "    slot function needs to finish before execution continues, you must make sure that",
        "    the connection is direct (see Qt::ConnectionType).",
        "",
        "    \\warning Make very sure that a signal handler for beforeSynchronizing leaves the GL",
        "    context in the same state as it was when the signal handler was entered. Failing to",
        "    do so can result in the scene not rendering properly.",
        "*/",
        "",
        "/*!",
        "    \\fn void QQuickWindow::afterSynchronizing()",
        "",
        "    This signal is emitted after the scene graph is synchronized with the QML state.",
        "",
        "    This signal can be used to do preparation required after calls to",
        "    QQuickItem::updatePaintNode(), while the GUI thread is still locked.",
        "",
        "    The GL context used for rendering the scene graph will be bound at this point.",
        "",
        "    \\warning This signal is emitted from the scene graph rendering thread. If your",
        "    slot function needs to finish before execution continues, you must make sure that",
        "    the connection is direct (see Qt::ConnectionType).",
        "",
        "    \\warning Make very sure that a signal handler for afterSynchronizing leaves the GL",
        "    context in the same state as it was when the signal handler was entered. Failing to",
        "    do so can result in the scene not rendering properly.",
        "",
        "    \\since 5.3",
        " */",
        "",
        "/*!",
        "    \\fn void QQuickWindow::beforeRendering()",
        "",
        "    This signal is emitted before the scene starts rendering.",
        "",
        "    Combined with the modes for clearing the background, this option",
        "    can be used to paint using raw GL under QML content.",
        "",
        "    The GL context used for rendering the scene graph will be bound",
        "    at this point.",
        "",
        "    \\warning This signal is emitted from the scene graph rendering thread. If your",
        "    slot function needs to finish before execution continues, you must make sure that",
        "    the connection is direct (see Qt::ConnectionType).",
        "",
        "    \\warning Make very sure that a signal handler for beforeRendering leaves the GL",
        "    context in the same state as it was when the signal handler was entered. Failing to",
        "    do so can result in the scene not rendering properly.",
        "*/",
        "",
        "/*!",
        "    \\fn void QQuickWindow::afterRendering()",
        "",
        "    This signal is emitted after the scene has completed rendering, before swapbuffers is called.",
        "",
        "    This signal can be used to paint using raw GL on top of QML content,",
        "    or to do screen scraping of the current frame buffer.",
        "",
        "    The GL context used for rendering the scene graph will be bound at this point.",
        "",
        "    \\warning This signal is emitted from the scene graph rendering thread. If your",
        "    slot function needs to finish before execution continues, you must make sure that",
        "    the connection is direct (see Qt::ConnectionType).",
        "",
        "    \\warning Make very sure that a signal handler for afterRendering() leaves the GL",
        "    context in the same state as it was when the signal handler was entered. Failing to",
        "    do so can result in the scene not rendering properly.",
        " */",
        "",
        "/*!",
        "    \\fn void QQuickWindow::afterAnimating()",
        "",
        "    This signal is emitted on the gui thread before requesting the render thread to",
        "    perform the synchronization of the scene graph.",
        "",
        "    Unlike the other similar signals, this one is emitted on the gui thread instead",
        "    of the render thread. It can be used to synchronize external animation systems",
        "    with the QML content.",
        "",
        "    \\since 5.3",
        " */",
        "",
        "/*!",
        "    \\fn void QQuickWindow::openglContextCreated(QOpenGLContext *context)",
        "",
        "    This signal is emitted on the gui thread when the OpenGL \\a context",
        "    for this window is created, before it is made current.",
        "",
        "    Some implementations will share the same OpenGL context between",
        "    multiple QQuickWindow instances. The openglContextCreated() signal",
        "    will in this case only be emitted for the first window, when the",
        "    OpenGL context is actually created.",
        "",
        "    QQuickWindow::openglContext() will still return 0 for this window",
        "    until after the QQuickWindow::sceneGraphInitialize() has been",
        "    emitted.",
        "",
        "    \\since 5.3",
        " */",
        "",
        "/*!",
        "    \\fn void QQuickWindow::sceneGraphAboutToStop()",
        "",
        "    This signal is emitted on the render thread when the scene graph is",
        "    about to stop rendering. This happens usually because the window",
        "    has been hidden.",
        "",
        "    Applications may use this signal to release resources, but should be",
        "    prepared to reinstantiated them again fast. The scene graph and the",
        "    OpenGL context are not released at this time.",
        "",
        "    \\warning This signal is emitted from the scene graph rendering thread. If your",
        "    slot function needs to finish before execution continues, you must make sure that",
        "    the connection is direct (see Qt::ConnectionType).",
        "",
        "    \\warning Make very sure that a signal handler for afterRendering() leaves the GL",
        "    context in the same state as it was when the signal handler was entered. Failing to",
        "    do so can result in the scene not rendering properly.",
        "",
        "    \\sa scenegraphInvalidated()",
        "",
        "    \\since 5.3",
        " */",
        "",
        "",
        "/*!",
        "    Sets whether the scene graph rendering of QML should clear the color buffer",
        "    before it starts rendering to \\a enabled.",
        "",
        "    By disabling clearing of the color buffer, it is possible to do GL painting",
        "    under the scene graph.",
        "",
        "    The color buffer is cleared by default.",
        "",
        "    \\sa beforeRendering()",
        " */",
        "",
        "void QQuickWindow::setClearBeforeRendering(bool enabled)",
        "{",
        "    Q_D(QQuickWindow);",
        "    d-\u003eclearBeforeRendering \u003d enabled;",
        "}",
        "",
        "",
        "",
        "/*!",
        "    Returns whether clearing of the color buffer is done before rendering or not.",
        " */",
        "",
        "bool QQuickWindow::clearBeforeRendering() const",
        "{",
        "    Q_D(const QQuickWindow);",
        "    return d-\u003eclearBeforeRendering;",
        "}",
        "",
        "/*!",
        "    \\overload",
        " */",
        "",
        "QSGTexture *QQuickWindow::createTextureFromImage(const QImage \u0026image) const",
        "{",
        "    return createTextureFromImage(image, 0);",
        "}",
        "",
        "",
        "/*!",
        "    Creates a new QSGTexture from the supplied \\a image. If the image has an",
        "    alpha channel, the corresponding texture will have an alpha channel.",
        "",
        "    The caller of the function is responsible for deleting the returned texture.",
        "    The actual GL texture will be deleted when the texture object is deleted.",
        "",
        "    When \\a options contains TextureCanUseAtlas the engine may put the image",
        "    into a texture atlas. Textures in an atlas need to rely on",
        "    QSGTexture::normalizedTextureSubRect() for their geometry and will not",
        "    support QSGTexture::Repeat. Other values from CreateTextureOption are",
        "    ignored.",
        "",
        "    \\warning This function will return 0 if the scene graph has not yet been",
        "    initialized.",
        "",
        "    \\warning The returned texture is not memory managed by the scene graph and",
        "    must be explicitly deleted by the caller on the rendering thread.",
        "    This is acheived by deleting the texture from a QSGNode destructor",
        "    or by using deleteLater() in the case where the texture already has affinity",
        "    to the rendering thread.",
        "",
        "    This function can be called from any thread.",
        "",
        "    \\sa sceneGraphInitialized()",
        " */",
        "",
        "QSGTexture *QQuickWindow::createTextureFromImage(const QImage \u0026image, CreateTextureOptions options) const",
        "{",
        "    Q_D(const QQuickWindow);",
        "    if (d-\u003econtext \u0026\u0026 d-\u003econtext-\u003eopenglContext()) {",
        "        if (options \u0026 TextureCanUseAtlas)",
        "            return d-\u003econtext-\u003ecreateTexture(image);",
        "        else",
        "            return d-\u003econtext-\u003ecreateTextureNoAtlas(image);",
        "    }",
        "    else",
        "        return 0;",
        "}",
        "",
        "",
        "",
        "/*!",
        "    Creates a new QSGTexture object from an existing GL texture \\a id and \\a size.",
        "",
        "    The caller of the function is responsible for deleting the returned texture.",
        "",
        "    Use \\a options to customize the texture attributes. The TextureUsesAtlas",
        "    option is ignored.",
        "",
        "    \\warning This function will return 0 if the scenegraph has not yet been",
        "    initialized.",
        "",
        "    \\sa sceneGraphInitialized()",
        " */",
        "QSGTexture *QQuickWindow::createTextureFromId(uint id, const QSize \u0026size, CreateTextureOptions options) const",
        "{",
        "    Q_D(const QQuickWindow);",
        "    if (d-\u003econtext \u0026\u0026 d-\u003econtext-\u003eopenglContext()) {",
        "        QSGPlainTexture *texture \u003d new QSGPlainTexture();",
        "        texture-\u003esetTextureId(id);",
        "        texture-\u003esetHasAlphaChannel(options \u0026 TextureHasAlphaChannel);",
        "        texture-\u003esetOwnsTexture(options \u0026 TextureOwnsGLTexture);",
        "        texture-\u003esetTextureSize(size);",
        "        return texture;",
        "    }",
        "    return 0;",
        "}",
        "",
        "/*!",
        "    \\qmlproperty color Window::color",
        "",
        "    The background color for the window.",
        "",
        "    Setting this property is more efficient than using a separate Rectangle.",
        "*/",
        "",
        "/*!",
        "    \\property QQuickWindow::color",
        "    \\brief The color used to clear the OpenGL context.",
        "",
        "    Setting the clear color has no effect when clearing is disabled.",
        "    By default, the clear color is white.",
        "",
        "    \\sa setClearBeforeRendering(), setDefaultAlphaBuffer()",
        " */",
        "",
        "void QQuickWindow::setColor(const QColor \u0026color)",
        "{",
        "    Q_D(QQuickWindow);",
        "    if (color \u003d\u003d d-\u003eclearColor)",
        "        return;",
        "",
        "    if (color.alpha() !\u003d d-\u003eclearColor.alpha()) {",
        "        QSurfaceFormat fmt \u003d requestedFormat();",
        "        if (color.alpha() \u003c 255)",
        "            fmt.setAlphaBufferSize(8);",
        "        else",
        "            fmt.setAlphaBufferSize(-1);",
        "        setFormat(fmt);",
        "    }",
        "    d-\u003eclearColor \u003d color;",
        "    emit colorChanged(color);",
        "    d-\u003edirtyItem(contentItem());",
        "}",
        "",
        "QColor QQuickWindow::color() const",
        "{",
        "    return d_func()-\u003eclearColor;",
        "}",
        "",
        "/*!",
        "    \\brief Returns whether to use alpha transparency on newly created windows.",
        "",
        "    \\since 5.1",
        "    \\sa setDefaultAlphaBuffer()",
        " */",
        "bool QQuickWindow::hasDefaultAlphaBuffer()",
        "{",
        "    return QQuickWindowPrivate::defaultAlphaBuffer;",
        "}",
        "",
        "/*!",
        "    \\brief \\a useAlpha specifies whether to use alpha transparency on newly created windows.",
        "    \\since 5.1",
        "",
        "    In any application which expects to create translucent windows, it\u0027s",
        "    necessary to set this to true before creating the first QQuickWindow,",
        "    because all windows will share the same \\l QOpenGLContext. The default",
        "    value is false.",
        " */",
        "void QQuickWindow::setDefaultAlphaBuffer(bool useAlpha)",
        "{",
        "    QQuickWindowPrivate::defaultAlphaBuffer \u003d useAlpha;",
        "}",
        "",
        "/*!",
        "    \\since 5.2",
        "",
        "    Call this function to reset the OpenGL context its default state.",
        "",
        "    The scene graph uses the OpenGL context and will both rely on and",
        "    clobber its state. When mixing raw OpenGL commands with scene",
        "    graph rendering, this function provides a convenient way of",
        "    resetting the OpenGL context state back to its default values.",
        "",
        "    This function does not touch state in the fixed-function pipeline.",
        "",
        "    This function does not clear the color, depth and stencil buffers. Use",
        "    QQuickWindow::setClearBeforeRendering to control clearing of the color",
        "    buffer. The depth and stencil buffer might be clobbered by the scene",
        "    graph renderer. Clear these manually on demand.",
        "",
        "    \\sa QQuickWindow::beforeRendering()",
        " */",
        "void QQuickWindow::resetOpenGLState()",
        "{",
        "    if (!openglContext())",
        "        return;",
        "",
        "    QOpenGLFunctions *gl \u003d openglContext()-\u003efunctions();",
        "",
        "    gl-\u003eglBindBuffer(GL_ARRAY_BUFFER, 0);",
        "    gl-\u003eglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);",
        "",
        "    int maxAttribs;",
        "    glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, \u0026maxAttribs);",
        "    for (int i\u003d0; i\u003cmaxAttribs; ++i) {",
        "        gl-\u003eglVertexAttribPointer(i, 4, GL_FLOAT, GL_FALSE, 0, 0);",
        "        gl-\u003eglDisableVertexAttribArray(i);",
        "    }",
        "",
        "    gl-\u003eglActiveTexture(GL_TEXTURE0);",
        "    glBindTexture(GL_TEXTURE_2D, 0);",
        "",
        "    glDisable(GL_DEPTH_TEST);",
        "    glDisable(GL_STENCIL_TEST);",
        "    glDisable(GL_SCISSOR_TEST);",
        "",
        "    glColorMask(true, true, true, true);",
        "    glClearColor(0, 0, 0, 0);",
        "",
        "    glDepthMask(true);",
        "    glDepthFunc(GL_LESS);",
        "    gl-\u003eglClearDepthf(1);",
        "",
        "    glStencilMask(0xff);",
        "    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);",
        "    glStencilFunc(GL_ALWAYS, 0, 0xff);",
        "",
        "    glDisable(GL_BLEND);",
        "    glBlendFunc(GL_ONE, GL_ZERO);",
        "",
        "    gl-\u003eglUseProgram(0);",
        "",
        "    QOpenGLFramebufferObject::bindDefault();",
        "}",
        "",
        "/*!",
        "    \\qmlproperty string Window::title",
        "",
        "    The window\u0027s title in the windowing system.",
        "",
        "    The window title might appear in the title area of the window decorations,",
        "    depending on the windowing system and the window flags. It might also",
        "    be used by the windowing system to identify the window in other contexts,",
        "    such as in the task switcher.",
        " */",
        "",
        "/*!",
        "    \\qmlproperty Qt::WindowModality Window::modality",
        "",
        "    The modality of the window.",
        "",
        "    A modal window prevents other windows from receiving input events.",
        "    Possible values are Qt.NonModal (the default), Qt.WindowModal,",
        "    and Qt.ApplicationModal.",
        " */",
        "",
        "/*!",
        "    \\qmlproperty Qt::WindowFlags Window::flags",
        "",
        "    The window flags of the window.",
        "",
        "    The window flags control the window\u0027s appearance in the windowing system,",
        "    whether it\u0027s a dialog, popup, or a regular window, and whether it should",
        "    have a title bar, etc.",
        "",
        "    The flags which you read from this property might differ from the ones",
        "    that you set if the requested flags could not be fulfilled.",
        " */",
        "",
        "/*!",
        "    \\qmlproperty int Window::x",
        "    \\qmlproperty int Window::y",
        "    \\qmlproperty int Window::width",
        "    \\qmlproperty int Window::height",
        "",
        "    Defines the window\u0027s position and size.",
        "",
        "    The (x,y) position is relative to the \\l Screen if there is only one,",
        "    or to the virtual desktop (arrangement of multiple screens).",
        "",
        "    \\qml",
        "    Window { x: 100; y: 100; width: 100; height: 100 }",
        "    \\endqml",
        "",
        "    \\image screen-and-window-dimensions.jpg",
        " */",
        "",
        "/*!",
        "    \\qmlproperty int Window::minimumWidth",
        "    \\qmlproperty int Window::minimumHeight",
        "    \\since 5.1",
        "",
        "    Defines the window\u0027s minimum size.",
        "",
        "    This is a hint to the window manager to prevent resizing below the specified",
        "    width and height.",
        " */",
        "",
        "/*!",
        "    \\qmlproperty int Window::maximumWidth",
        "    \\qmlproperty int Window::maximumHeight",
        "    \\since 5.1",
        "",
        "    Defines the window\u0027s maximum size.",
        "",
        "    This is a hint to the window manager to prevent resizing above the specified",
        "    width and height.",
        " */",
        "",
        "/*!",
        "    \\qmlproperty bool Window::visible",
        "",
        "    Whether the window is visible on the screen.",
        "",
        "    Setting visible to false is the same as setting \\l visibility to Hidden.",
        "",
        "    \\sa visibility",
        " */",
        "",
        "/*!",
        "    \\qmlproperty QWindow::Visibility Window::visibility",
        "",
        "    The screen-occupation state of the window.",
        "",
        "    Visibility is whether the window should appear in the windowing system as",
        "    normal, minimized, maximized, fullscreen or hidden.",
        "",
        "    To set the visibility to AutomaticVisibility means to give the window a",
        "    default visible state, which might be fullscreen or windowed depending on",
        "    the platform. However when reading the visibility property you will always",
        "    get the actual state, never AutomaticVisibility.",
        "",
        "    When a window is not visible its visibility is Hidden, and setting",
        "    visibility to Hidden is the same as setting \\l visible to false.",
        "",
        "    \\sa visible",
        "    \\since 5.1",
        " */",
        "",
        "/*!",
        "    \\qmlproperty Qt::ScreenOrientation Window::contentOrientation",
        "",
        "    This is a hint to the window manager in case it needs to display",
        "    additional content like popups, dialogs, status bars, or similar",
        "    in relation to the window.",
        "",
        "    The recommended orientation is \\l {Screen::orientation}{Screen.orientation}, but",
        "    an application doesn\u0027t have to support all possible orientations,",
        "    and thus can opt to ignore the current screen orientation.",
        "",
        "    The difference between the window and the content orientation",
        "    determines how much to rotate the content by.",
        "",
        "    The default value is Qt::PrimaryOrientation.",
        "",
        "    \\sa Screen",
        "",
        "    \\since 5.1",
        " */",
        "",
        "/*!",
        "    \\qmlproperty real Window::opacity",
        "",
        "    The opacity of the window.",
        "",
        "    If the windowing system supports window opacity, this can be used to fade the",
        "    window in and out, or to make it semitransparent.",
        "",
        "    A value of 1.0 or above is treated as fully opaque, whereas a value of 0.0 or below",
        "    is treated as fully transparent. Values inbetween represent varying levels of",
        "    translucency between the two extremes.",
        "",
        "    The default value is 1.0.",
        "",
        "    \\since 5.1",
        " */",
        "",
        "/*!",
        "    \\qmlproperty Item Window::activeFocusItem",
        "    \\since 5.1",
        "",
        "    The item which currently has active focus or \\c null if there is",
        "    no item with active focus.",
        " */",
        "",
        "/*!",
        "    \\qmlproperty Window::active",
        "    \\since 5.1",
        "",
        "    The active status of the window.",
        "",
        "    \\sa requestActivate()",
        " */",
        "",
        "/*!",
        "    \\qmlmethod QtQuick::Window::requestActivate()",
        "    \\since 5.1",
        "",
        "    Requests the window to be activated, i.e. receive keyboard focus.",
        " */",
        "",
        "/*!",
        "    \\qmlmethod QtQuick::Window::alert(int msec)",
        "    \\since 5.1",
        "",
        "    Causes an alert to be shown for \\a msec miliseconds. If \\a msec is \\c 0 (the",
        "    default), then the alert is shown indefinitely until the window becomes",
        "    active again.",
        "",
        "    In alert state, the window indicates that it demands attention, for example by",
        "    flashing or bouncing the taskbar entry.",
        "*/",
        "",
        "#include \"moc_qquickwindow.cpp\"",
        "",
        "QT_END_NAMESPACE",
        ""
      ]
    }
  ]
}
