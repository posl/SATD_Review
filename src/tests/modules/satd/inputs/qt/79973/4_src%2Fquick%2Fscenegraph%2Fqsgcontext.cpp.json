{
  "meta_a": {
    "name": "src/quick/scenegraph/qsgcontext.cpp",
    "content_type": "text/x-c++src",
    "lines": 655,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003dba4419df92bad6953c81be03a4ccf5cc137cb2d3;f\u003dsrc%2Fquick%2Fscenegraph%2Fqsgcontext.cpp"
      }
    ]
  },
  "meta_b": {
    "name": "src/quick/scenegraph/qsgcontext.cpp",
    "content_type": "text/x-c++src",
    "lines": 688,
    "web_links": [
      {
        "name": "gitweb",
        "url": "/gitweb?p\u003dqt%2Fqtdeclarative.git;hb\u003drefs%2Fchanges%2F73%2F79973%2F4;f\u003dsrc%2Fquick%2Fscenegraph%2Fqsgcontext.cpp"
      }
    ]
  },
  "change_type": "MODIFIED",
  "diff_header": [
    "diff --git a/src/quick/scenegraph/qsgcontext.cpp b/src/quick/scenegraph/qsgcontext.cpp",
    "index 9f7818a..05ab12e 100644",
    "--- a/src/quick/scenegraph/qsgcontext.cpp",
    "+++ b/src/quick/scenegraph/qsgcontext.cpp"
  ],
  "content": [
    {
      "ab": [
        "/****************************************************************************",
        "**",
        "** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).",
        "** Contact: http://www.qt-project.org/legal",
        "**",
        "** This file is part of the QtQuick module of the Qt Toolkit.",
        "**",
        "** $QT_BEGIN_LICENSE:LGPL$",
        "** Commercial License Usage",
        "** Licensees holding valid commercial Qt licenses may use this file in",
        "** accordance with the commercial license agreement provided with the",
        "** Software or, alternatively, in accordance with the terms contained in",
        "** a written agreement between you and Digia.  For licensing terms and",
        "** conditions see http://qt.digia.com/licensing.  For further information",
        "** use the contact form at http://qt.digia.com/contact-us.",
        "**",
        "** GNU Lesser General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU Lesser",
        "** General Public License version 2.1 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.LGPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU Lesser General Public License version 2.1 requirements",
        "** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.",
        "**",
        "** In addition, as a special exception, Digia gives you certain additional",
        "** rights.  These rights are described in the Digia Qt LGPL Exception",
        "** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.",
        "**",
        "** GNU General Public License Usage",
        "** Alternatively, this file may be used under the terms of the GNU",
        "** General Public License version 3.0 as published by the Free Software",
        "** Foundation and appearing in the file LICENSE.GPL included in the",
        "** packaging of this file.  Please review the following information to",
        "** ensure the GNU General Public License version 3.0 requirements will be",
        "** met: http://www.gnu.org/copyleft/gpl.html.",
        "**",
        "**",
        "** $QT_END_LICENSE$",
        "**",
        "****************************************************************************/",
        "",
        "#include \u003cQtQuick/private/qsgcontext_p.h\u003e",
        "#include \u003cQtQuick/private/qsgbatchrenderer_p.h\u003e",
        "#include \u003cQtQuick/private/qsgdistancefieldutil_p.h\u003e",
        "#include \u003cQtQuick/private/qsgdefaultdistancefieldglyphcache_p.h\u003e",
        "#include \u003cQtQuick/private/qsgdefaultrectanglenode_p.h\u003e",
        "#include \u003cQtQuick/private/qsgdefaultimagenode_p.h\u003e",
        "#include \u003cQtQuick/private/qsgdefaultglyphnode_p.h\u003e",
        "#include \u003cQtQuick/private/qsgdistancefieldglyphnode_p.h\u003e",
        "#include \u003cQtQuick/private/qsgdistancefieldglyphnode_p_p.h\u003e",
        "#include \u003cQtQuick/private/qsgshareddistancefieldglyphcache_p.h\u003e",
        "#include \u003cQtQuick/private/qsgatlastexture_p.h\u003e",
        "",
        "#include \u003cQtQuick/private/qsgtexture_p.h\u003e",
        "#include \u003cQtQuick/private/qquickpixmapcache_p.h\u003e",
        "",
        "#include \u003cQGuiApplication\u003e",
        "#include \u003cQOpenGLContext\u003e",
        "#include \u003cQQuickWindow\u003e",
        "#include \u003cQtGui/qopenglframebufferobject.h\u003e",
        ""
      ]
    },
    {
      "b": [
        "#include \u003cQtCore/QLibraryInfo\u003e",
        ""
      ]
    },
    {
      "ab": [
        "#include \u003cprivate/qqmlglobal_p.h\u003e",
        "",
        "#include \u003cQtQuick/private/qsgtexture_p.h\u003e",
        "#include \u003cQtGui/private/qguiapplication_p.h\u003e",
        "#include \u003cqpa/qplatformintegration.h\u003e",
        "",
        "#include \u003cqpa/qplatformsharedgraphicscache.h\u003e",
        "",
        "#include \u003cprivate/qobject_p.h\u003e",
        "#include \u003cqmutex.h\u003e",
        "",
        "#include \u003cprivate/qqmlprofilerservice_p.h\u003e",
        "",
        "DEFINE_BOOL_CONFIG_OPTION(qmlDisableDistanceField, QML_DISABLE_DISTANCEFIELD)",
        "",
        "/*",
        "    Comments about this class from Gunnar:",
        "",
        "    The QSGContext class is right now two things.. The first is the",
        "    adaptation layer and central storage ground for all the things",
        "    in the scene graph, like textures and materials. This part really",
        "    belongs inside the scene graph coreapi.",
        "",
        "    The other part is the QML adaptation classes, like how to implement",
        "    rectangle nodes. This is not part of the scene graph core API, but",
        "    more part of the QML adaptation of scene graph.",
        "",
        "    If we ever move the scene graph core API into its own thing, this class",
        "    needs to be split in two. Right now its one because we\u0027re lazy when it comes",
        "    to defining plugin interfaces..",
        "*/",
        "",
        "QT_BEGIN_NAMESPACE",
        "",
        "class QSGContextPrivate : public QObjectPrivate",
        "{",
        "public:",
        "    QSGContextPrivate()",
        "        : antialiasingMethod(QSGContext::UndecidedAntialiasing)",
        "        , distanceFieldDisabled(qmlDisableDistanceField())",
        "        , distanceFieldAntialiasing(",
        "#if !defined(QT_OPENGL_ES) || defined(QT_OPENGL_ES_2_ANGLE)",
        "              QSGGlyphNode::HighQualitySubPixelAntialiasing",
        "#else",
        "              QSGGlyphNode::GrayAntialiasing",
        "#endif",
        "              )",
        "    {",
        "    }",
        "",
        "    ~QSGContextPrivate()",
        "    {",
        "    }",
        "",
        "    QMutex mutex;",
        "    QSGContext::AntialiasingMethod antialiasingMethod;",
        "    bool distanceFieldDisabled;",
        "    QSGDistanceFieldGlyphNode::AntialiasingMode distanceFieldAntialiasing;",
        "",
        "    static QOpenGLContext *sharedOpenGLContext;",
        "};",
        "",
        "QOpenGLContext *QSGContextPrivate::sharedOpenGLContext \u003d 0;",
        "",
        "class QSGTextureCleanupEvent : public QEvent",
        "{",
        "public:",
        "    QSGTextureCleanupEvent(QSGTexture *t) : QEvent(QEvent::User), texture(t) { }",
        "    ~QSGTextureCleanupEvent() { delete texture; }",
        "    QSGTexture *texture;",
        "};",
        "",
        "namespace QSGMultisampleAntialiasing {",
        "    class ImageNode : public QSGDefaultImageNode {",
        "    public:",
        "        void setAntialiasing(bool) { }",
        "    };",
        "",
        "",
        "    class RectangleNode : public QSGDefaultRectangleNode {",
        "    public:",
        "        void setAntialiasing(bool) { }",
        "    };",
        "}",
        "",
        "",
        "/*!",
        "    \\class QSGContext",
        "",
        "    \\brief The QSGContext holds the scene graph entry points for one QML engine.",
        "",
        "    The context is not ready for use until it has a QOpenGLContext. Once that happens,",
        "    the scene graph population can start.",
        "",
        "    \\internal",
        " */",
        "",
        "QSGContext::QSGContext(QObject *parent) :",
        "    QObject(*(new QSGContextPrivate), parent)",
        "{",
        "    Q_D(QSGContext);",
        "    QByteArray mode \u003d qgetenv(\"QSG_DISTANCEFIELD_ANTIALIASING\");",
        "    if (mode \u003d\u003d \"subpixel\")",
        "        d-\u003edistanceFieldAntialiasing \u003d QSGGlyphNode::HighQualitySubPixelAntialiasing;",
        "    else if (mode \u003d\u003d \"subpixel-lowq\")",
        "        d-\u003edistanceFieldAntialiasing \u003d QSGGlyphNode::LowQualitySubPixelAntialiasing;",
        "    else if (mode \u003d\u003d \"gray\")",
        "        d-\u003edistanceFieldAntialiasing \u003d QSGGlyphNode::GrayAntialiasing;",
        "}",
        "",
        "",
        "QSGContext::~QSGContext()",
        "{",
        "}",
        "",
        "QSGRenderContext *QSGContext::createRenderContext()",
        "{",
        "    return new QSGRenderContext(this);",
        "}",
        "",
        "/*!",
        " * This function is used by the Qt WebEngine to set up context sharing",
        " * across multiple windows. Do not use it for any other purpose.",
        " */",
        "void QSGContext::setSharedOpenGLContext(QOpenGLContext *context)",
        "{",
        "    QSGContextPrivate::sharedOpenGLContext \u003d context;",
        "}",
        "",
        "QOpenGLContext *QSGContext::sharedOpenGLContext()",
        "{",
        "    return QSGContextPrivate::sharedOpenGLContext;",
        "}",
        "",
        "void QSGContext::renderContextInitialized(QSGRenderContext *renderContext)",
        "{",
        "    Q_D(QSGContext);",
        "",
        "    d-\u003emutex.lock();",
        "    if (d-\u003eantialiasingMethod \u003d\u003d UndecidedAntialiasing) {",
        "        QByteArray aaType \u003d qgetenv(\"QSG_ANTIALIASING_METHOD\");",
        "        if (aaType \u003d\u003d \"msaa\") {",
        "            d-\u003eantialiasingMethod \u003d MsaaAntialiasing;",
        "        } else if (aaType \u003d\u003d \"vertex\") {",
        "            d-\u003eantialiasingMethod \u003d VertexAntialiasing;",
        "        } else {",
        "            if (renderContext-\u003eopenglContext()-\u003eformat().samples() \u003e 0)",
        "                d-\u003eantialiasingMethod \u003d MsaaAntialiasing;",
        "            else",
        "                d-\u003eantialiasingMethod \u003d VertexAntialiasing;",
        "        }",
        "    }",
        "",
        "    static bool dumped \u003d false;",
        "    if (!dumped \u0026\u0026 qEnvironmentVariableIsSet(\"QSG_INFO\")) {",
        "        dumped \u003d true;",
        "        QSurfaceFormat format \u003d renderContext-\u003eopenglContext()-\u003eformat();",
        "        qDebug() \u003c\u003c \"R/G/B/A Buffers:   \" \u003c\u003c format.redBufferSize() \u003c\u003c format.greenBufferSize() \u003c\u003c format.blueBufferSize() \u003c\u003c format.alphaBufferSize();",
        "        qDebug() \u003c\u003c \"Depth Buffer:      \" \u003c\u003c format.depthBufferSize();",
        "        qDebug() \u003c\u003c \"Stencil Buffer:    \" \u003c\u003c format.stencilBufferSize();",
        "        qDebug() \u003c\u003c \"Samples:           \" \u003c\u003c format.samples();",
        "        qDebug() \u003c\u003c \"GL_VENDOR:         \" \u003c\u003c (const char *) glGetString(GL_VENDOR);",
        "        qDebug() \u003c\u003c \"GL_RENDERER:       \" \u003c\u003c (const char *) glGetString(GL_RENDERER);",
        "        qDebug() \u003c\u003c \"GL_VERSION:        \" \u003c\u003c (const char *) glGetString(GL_VERSION);",
        "        QSet\u003cQByteArray\u003e exts \u003d renderContext-\u003eopenglContext()-\u003eextensions();",
        "        QByteArray all; foreach (const QByteArray \u0026e, exts) all +\u003d \u0027 \u0027 + e;",
        "        qDebug() \u003c\u003c \"GL_EXTENSIONS:    \" \u003c\u003c all.constData();",
        "    }",
        "",
        "    d-\u003emutex.unlock();",
        "}",
        "",
        "void QSGContext::renderContextInvalidated(QSGRenderContext *)",
        "{",
        "}",
        "",
        "/*!",
        "    Factory function for scene graph backends of the Rectangle element.",
        " */",
        "QSGRectangleNode *QSGContext::createRectangleNode()",
        "{",
        "    Q_D(QSGContext);",
        "    return d-\u003eantialiasingMethod \u003d\u003d MsaaAntialiasing",
        "            ? new QSGMultisampleAntialiasing::RectangleNode",
        "            : new QSGDefaultRectangleNode;",
        "}",
        "",
        "/*!",
        "    Factory function for scene graph backends of the Image element.",
        " */",
        "QSGImageNode *QSGContext::createImageNode()",
        "{",
        "    Q_D(QSGContext);",
        "    return d-\u003eantialiasingMethod \u003d\u003d MsaaAntialiasing",
        "            ? new QSGMultisampleAntialiasing::ImageNode",
        "            : new QSGDefaultImageNode;",
        "}",
        "",
        "/*!",
        "    Factory function for scene graph backends of the Text elements;",
        " */",
        "QSGGlyphNode *QSGContext::createGlyphNode(QSGRenderContext *rc, bool preferNativeGlyphNode)",
        "{",
        "    Q_D(QSGContext);",
        "",
        "    if (d-\u003edistanceFieldDisabled || preferNativeGlyphNode) {",
        "        return new QSGDefaultGlyphNode;",
        "    } else {",
        "        QSGDistanceFieldGlyphNode *node \u003d new QSGDistanceFieldGlyphNode(rc);",
        "        node-\u003esetPreferredAntialiasingMode(d-\u003edistanceFieldAntialiasing);",
        "        return node;",
        "    }",
        "}",
        "",
        "QSurfaceFormat QSGContext::defaultSurfaceFormat() const",
        "{",
        "    QSurfaceFormat format;",
        "    static bool useDepth \u003d qEnvironmentVariableIsEmpty(\"QSG_NO_DEPTH_BUFFER\");",
        "    static bool useStencil \u003d qEnvironmentVariableIsEmpty(\"QSG_NO_STENCIL_BUFFER\");",
        "    format.setDepthBufferSize(useDepth ? 24 : 0);",
        "    format.setStencilBufferSize(useStencil ? 8 : 0);",
        "    if (QQuickWindow::hasDefaultAlphaBuffer())",
        "        format.setAlphaBufferSize(8);",
        "    format.setSwapBehavior(QSurfaceFormat::DoubleBuffer);",
        "    return format;",
        "}",
        "",
        "/*!",
        "    Returns the minimum supported framebuffer object size.",
        " */",
        "",
        "QSize QSGContext::minimumFBOSize() const",
        "{",
        "#ifdef Q_OS_MAC",
        "    return QSize(33, 33);",
        "#else",
        "    return QSize(1, 1);",
        "#endif",
        "}",
        "",
        "",
        "",
        "/*!",
        "    Sets whether or not the scene graph should use the distance field technique to render text",
        "  */",
        "void QSGContext::setDistanceFieldEnabled(bool enabled)",
        "{",
        "    d_func()-\u003edistanceFieldDisabled \u003d !enabled;",
        "}",
        "",
        "",
        "/*!",
        "    Returns true if the scene graph uses the distance field technique to render text",
        " */",
        "bool QSGContext::isDistanceFieldEnabled() const",
        "{",
        "    return !d_func()-\u003edistanceFieldDisabled;",
        "}",
        "",
        "",
        "",
        "/*!",
        "    Creates a new animation driver.",
        " */",
        "",
        "QAnimationDriver *QSGContext::createAnimationDriver(QObject *parent)",
        "{",
        "    return new QAnimationDriver(parent);",
        "}",
        "",
        "QSGRenderContext::QSGRenderContext(QSGContext *context)",
        "    : m_gl(0)",
        "    , m_sg(context)",
        "    , m_atlasManager(0)",
        "    , m_depthStencilManager(0)",
        "    , m_distanceFieldCacheManager(0)",
        "    , m_brokenIBOs(false)",
        "    , m_serializedRender(false)",
        "{",
        "}",
        "",
        "QSGRenderContext::~QSGRenderContext()",
        "{",
        "    invalidate();",
        "}",
        "",
        "void QSGRenderContext::endSync()",
        "{",
        "    qDeleteAll(m_texturesToDelete);",
        "    m_texturesToDelete.clear();",
        "}",
        "",
        "static QBasicMutex qsg_framerender_mutex;",
        "",
        "void QSGRenderContext::renderNextFrame(QSGRenderer *renderer, GLuint fboId)",
        "{",
        "    if (m_serializedRender)",
        "        qsg_framerender_mutex.lock();",
        "",
        "    if (fboId) {",
        "        QSGBindableFboId bindable(fboId);",
        "        renderer-\u003erenderScene(bindable);",
        "    } else {",
        "        renderer-\u003erenderScene();",
        "    }",
        "",
        "    if (m_serializedRender)",
        "        qsg_framerender_mutex.unlock();",
        "",
        "}",
        "",
        "/*!",
        "    Factory function for scene graph backends of the distance-field glyph cache.",
        " */",
        "QSGDistanceFieldGlyphCache *QSGRenderContext::distanceFieldGlyphCache(const QRawFont \u0026font)",
        "{",
        "    if (!m_distanceFieldCacheManager)",
        "        m_distanceFieldCacheManager \u003d new QSGDistanceFieldGlyphCacheManager;",
        "",
        "    QSGDistanceFieldGlyphCache *cache \u003d m_distanceFieldCacheManager-\u003ecache(font);",
        "    if (!cache) {",
        "        QPlatformIntegration *platformIntegration \u003d QGuiApplicationPrivate::platformIntegration();",
        "        if (platformIntegration !\u003d 0",
        "            \u0026\u0026 platformIntegration-\u003ehasCapability(QPlatformIntegration::SharedGraphicsCache)) {",
        "            QFontEngine *fe \u003d QRawFontPrivate::get(font)-\u003efontEngine;",
        "            if (!fe-\u003efaceId().filename.isEmpty()) {",
        "                QByteArray keyName \u003d fe-\u003efaceId().filename;",
        "                if (font.style() !\u003d QFont::StyleNormal)",
        "                    keyName +\u003d QByteArray(\" I\");",
        "                if (font.weight() !\u003d QFont::Normal)",
        "                    keyName +\u003d \u0027 \u0027 + QByteArray::number(font.weight());",
        "                keyName +\u003d QByteArray(\" DF\");",
        "                QPlatformSharedGraphicsCache *sharedGraphicsCache \u003d",
        "                        platformIntegration-\u003ecreatePlatformSharedGraphicsCache(keyName);",
        "",
        "                if (sharedGraphicsCache !\u003d 0) {",
        "                    sharedGraphicsCache-\u003eensureCacheInitialized(keyName,",
        "                                                                QPlatformSharedGraphicsCache::OpenGLTexture,",
        "                                                                QPlatformSharedGraphicsCache::Alpha8);",
        "",
        "                    cache \u003d new QSGSharedDistanceFieldGlyphCache(keyName,",
        "                                                                 sharedGraphicsCache,",
        "                                                                 m_distanceFieldCacheManager,",
        "                                                                 openglContext(),",
        "                                                                 font);",
        "                }",
        "            }",
        "        }",
        "        if (!cache)",
        "            cache \u003d new QSGDefaultDistanceFieldGlyphCache(m_distanceFieldCacheManager, openglContext(), font);",
        "        m_distanceFieldCacheManager-\u003einsertCache(font, cache);",
        "    }",
        "",
        "    return cache;",
        "}",
        "",
        "#define QSG_RENDERCONTEXT_PROPERTY \"_q_sgrendercontext\"",
        "",
        "QSGRenderContext *QSGRenderContext::from(QOpenGLContext *context)",
        "{",
        "    return qobject_cast\u003cQSGRenderContext *\u003e(context-\u003eproperty(QSG_RENDERCONTEXT_PROPERTY).value\u003cQObject *\u003e());",
        "}",
        "",
        "void QSGRenderContext::registerFontengineForCleanup(QFontEngine *engine)",
        "{",
        "    m_fontEnginesToClean \u003c\u003c engine;",
        "}",
        "",
        "/*!",
        "    Initializes the scene graph render context with the GL context \\a context. This also",
        "    emits the ready() signal so that the QML graph can start building scene graph nodes.",
        " */",
        "void QSGRenderContext::initialize(QOpenGLContext *context)",
        "{",
        "    // Sanity check the surface format, in case it was overridden by the application",
        "    QSurfaceFormat requested \u003d m_sg-\u003edefaultSurfaceFormat();",
        "    QSurfaceFormat actual \u003d context-\u003eformat();",
        "    if (requested.depthBufferSize() \u003e 0 \u0026\u0026 actual.depthBufferSize() \u003c\u003d 0)",
        "        qWarning(\"QSGContext::initialize: depth buffer support missing, expect rendering errors\");",
        "    if (requested.stencilBufferSize() \u003e 0 \u0026\u0026 actual.stencilBufferSize() \u003c\u003d 0)",
        "        qWarning(\"QSGContext::initialize: stencil buffer support missing, expect rendering errors\");",
        "",
        "    if (!m_atlasManager)",
        "        m_atlasManager \u003d new QSGAtlasTexture::Manager();",
        "",
        "    Q_ASSERT_X(!m_gl, \"QSGRenderContext::initialize\", \"already initialized!\");",
        "    m_gl \u003d context;",
        "    m_gl-\u003esetProperty(QSG_RENDERCONTEXT_PROPERTY, QVariant::fromValue(this));",
        "    m_sg-\u003erenderContextInitialized(this);",
        "",
        "#ifdef Q_OS_LINUX",
        "    const char *vendor \u003d (const char *) glGetString(GL_VENDOR);",
        "    if (strstr(vendor, \"nouveau\"))",
        "        m_brokenIBOs \u003d true;",
        "    const char *renderer \u003d (const char *) glGetString(GL_RENDERER);",
        "    if (strstr(renderer, \"llvmpipe\"))",
        "        m_serializedRender \u003d true;",
        "    if (strstr(vendor, \"Hisilicon Technologies\") \u0026\u0026 strstr(renderer, \"Immersion.16\"))",
        "        m_brokenIBOs \u003d true;",
        "#endif",
        "",
        "    emit initialized();",
        "}",
        "",
        "void QSGRenderContext::invalidate()",
        "{",
        "    if (!m_gl)",
        "        return;",
        "",
        "    qDeleteAll(m_texturesToDelete);",
        "    m_texturesToDelete.clear();",
        "",
        "    qDeleteAll(m_textures.values());",
        "    m_textures.clear();",
        "",
        "    /* The cleanup of the atlas textures is a bit intriguing.",
        "       As part of the cleanup in the threaded render loop, we",
        "       do:",
        "       1. call this function",
        "       2. call QCoreApp::sendPostedEvents() to immediately process",
        "          any pending deferred deletes.",
        "       3. delete the GL context.",
        "",
        "       As textures need the atlas manager while cleaning up, the",
        "       manager needs to be cleaned up after the textures, so",
        "       we post a deleteLater here at the very bottom so it gets",
        "       deferred deleted last.",
        "",
        "       Another alternative would be to use a QPointer in",
        "       QSGAtlasTexture::Texture, but this seemed simpler.",
        "     */",
        "    m_atlasManager-\u003einvalidate();",
        "    m_atlasManager-\u003edeleteLater();",
        "    m_atlasManager \u003d 0;",
        "",
        "    // The following piece of code will read/write to the font engine\u0027s caches,",
        "    // potentially from different threads. However, this is safe because this",
        "    // code is only called from QQuickWindow\u0027s shutdown which is called",
        "    // only when the GUI is blocked, and multiple threads will call it in",
        "    // sequence. (see qsgdefaultglyphnode_p.cpp\u0027s init())",
        "    for (QSet\u003cQFontEngine *\u003e::const_iterator it \u003d m_fontEnginesToClean.constBegin(),",
        "         end \u003d m_fontEnginesToClean.constEnd(); it !\u003d end; ++it) {",
        "        (*it)-\u003eclearGlyphCache(m_gl);",
        "    }",
        "    m_fontEnginesToClean.clear();",
        "",
        "    delete m_depthStencilManager;",
        "    m_depthStencilManager \u003d 0;",
        "",
        "    delete m_distanceFieldCacheManager;",
        "    m_distanceFieldCacheManager \u003d 0;",
        "",
        "    m_gl-\u003esetProperty(QSG_RENDERCONTEXT_PROPERTY, QVariant());",
        "    m_gl \u003d 0;",
        "",
        "    m_sg-\u003erenderContextInvalidated(this);",
        "    emit invalidated();",
        "}",
        "",
        "/*!",
        "    Returns a shared pointer to a depth stencil buffer that can be used with \\a fbo.",
        "  */",
        "QSharedPointer\u003cQSGDepthStencilBuffer\u003e QSGRenderContext::depthStencilBufferForFbo(QOpenGLFramebufferObject *fbo)",
        "{",
        "    if (!m_gl)",
        "        return QSharedPointer\u003cQSGDepthStencilBuffer\u003e();",
        "    QSGDepthStencilBufferManager *manager \u003d depthStencilBufferManager();",
        "    QSGDepthStencilBuffer::Format format;",
        "    format.size \u003d fbo-\u003esize();",
        "    format.samples \u003d fbo-\u003eformat().samples();",
        "    format.attachments \u003d QSGDepthStencilBuffer::DepthAttachment | QSGDepthStencilBuffer::StencilAttachment;",
        "    QSharedPointer\u003cQSGDepthStencilBuffer\u003e buffer \u003d manager-\u003ebufferForFormat(format);",
        "    if (buffer.isNull()) {",
        "        buffer \u003d QSharedPointer\u003cQSGDepthStencilBuffer\u003e(new QSGDefaultDepthStencilBuffer(m_gl, format));",
        "        manager-\u003einsertBuffer(buffer);",
        "    }",
        "    return buffer;",
        "}",
        "",
        "/*!",
        "    Returns a pointer to the context\u0027s depth/stencil buffer manager. This is useful for custom",
        "    implementations of \\l depthStencilBufferForFbo().",
        "  */",
        "QSGDepthStencilBufferManager *QSGRenderContext::depthStencilBufferManager()",
        "{",
        "    if (!m_gl)",
        "        return 0;",
        "    if (!m_depthStencilManager)",
        "        m_depthStencilManager \u003d new QSGDepthStencilBufferManager(m_gl);",
        "    return m_depthStencilManager;",
        "}",
        "",
        "",
        "/*!",
        "    Factory function for texture objects.",
        "",
        "    If \\a image is a valid image, the QSGTexture::setImage function",
        "    will be called with \\a image as argument.",
        " */",
        "",
        "QSGTexture *QSGRenderContext::createTexture(const QImage \u0026image) const",
        "{",
        "    QSGTexture *t \u003d m_atlasManager-\u003ecreate(image);",
        "    if (t)",
        "        return t;",
        "    return createTextureNoAtlas(image);",
        "}",
        "",
        "QSGTexture *QSGRenderContext::createTextureNoAtlas(const QImage \u0026image) const",
        "{",
        "    QSGPlainTexture *t \u003d new QSGPlainTexture();",
        "    if (!image.isNull())",
        "        t-\u003esetImage(image);",
        "    return t;",
        "}",
        "",
        "/*!",
        "    Factory function for the scene graph renderers.",
        "",
        "    The renderers are used for the toplevel renderer and once for every",
        "    QQuickShaderEffectSource used in the QML scene.",
        " */",
        "QSGRenderer *QSGRenderContext::createRenderer()",
        "{",
        "    return new QSGBatchRenderer::Renderer(this);",
        "}",
        "",
        "QSGTexture *QSGRenderContext::textureForFactory(QQuickTextureFactory *factory, QQuickWindow *window)",
        "{",
        "    if (!factory)",
        "        return 0;",
        "",
        "    m_mutex.lock();",
        "    QSGTexture *texture \u003d m_textures.value(factory);",
        "    m_mutex.unlock();",
        "",
        "    if (!texture) {",
        "        if (QQuickDefaultTextureFactory *dtf \u003d qobject_cast\u003cQQuickDefaultTextureFactory *\u003e(factory))",
        "            texture \u003d createTexture(dtf-\u003eimage());",
        "        else",
        "            texture \u003d factory-\u003ecreateTexture(window);",
        "",
        "        m_mutex.lock();",
        "        m_textures.insert(factory, texture);",
        "        m_mutex.unlock();",
        "",
        "        connect(factory, SIGNAL(destroyed(QObject*)), this, SLOT(textureFactoryDestroyed(QObject*)), Qt::DirectConnection);",
        "    }",
        "    return texture;",
        "}",
        "",
        "void QSGRenderContext::textureFactoryDestroyed(QObject *o)",
        "{",
        "    m_mutex.lock();",
        "    m_texturesToDelete \u003c\u003c m_textures.take(static_cast\u003cQQuickTextureFactory *\u003e(o));",
        "    m_mutex.unlock();",
        "}",
        "",
        "/*!",
        "    Compile \\a shader, optionally using \\a vertexCode and \\a fragmentCode as",
        "    replacement for the source code supplied by \\a shader.",
        "",
        "    If \\a vertexCode or \\a fragmentCode is supplied, the caller is responsible",
        "    for setting up attribute bindings.",
        "",
        "    \\a material is supplied in case the implementation needs to take the",
        "    material flags into account.",
        " */",
        "",
        "void QSGRenderContext::compile(QSGMaterialShader *shader, QSGMaterial *material, const char *vertexCode, const char *fragmentCode)",
        "{",
        "    Q_UNUSED(material);",
        "    if (vertexCode || fragmentCode) {",
        "        Q_ASSERT_X((material-\u003eflags() \u0026 QSGMaterial::CustomCompileStep) \u003d\u003d 0,",
        "                   \"QSGRenderContext::compile()\",",
        "                   \"materials with custom compile step cannot have custom vertex/fragment code\");",
        "        QOpenGLShaderProgram *p \u003d shader-\u003eprogram();",
        "        p-\u003eaddShaderFromSourceCode(QOpenGLShader::Vertex, vertexCode ? vertexCode : shader-\u003evertexShader());",
        "        p-\u003eaddShaderFromSourceCode(QOpenGLShader::Fragment, fragmentCode ? fragmentCode : shader-\u003efragmentShader());",
        "        p-\u003elink();",
        "        if (!p-\u003eisLinked())",
        "            qWarning() \u003c\u003c \"shader compilation failed:\" \u003c\u003c endl \u003c\u003c p-\u003elog();",
        "    } else {",
        "        shader-\u003ecompile();",
        "    }",
        "}",
        "",
        "void QSGRenderContext::initialize(QSGMaterialShader *shader)",
        "{",
        "    shader-\u003einitialize();",
        "}",
        ""
      ]
    },
    {
      "b": [
        "void QSGRenderContext::contextCreationFailureMessage(const QSurfaceFormat \u0026format,",
        "                                                     QString *translatedMessage,",
        "                                                     QString *untranslatedMessage,",
        "                                                     bool isEs)",
        "{",
        "    const QString contextType \u003d QLatin1String(isEs ? \"EGL\" : \"OpenGL\");",
        "    QString formatStr;",
        "    QDebug(\u0026formatStr) \u003c\u003c format;",
        "#if defined(Q_OS_WIN32)",
        "    const bool isDebug \u003d QLibraryInfo::isDebugBuild();",
        "    const QString eglLibName \u003d QLatin1String(isDebug ? \"libEGLd.dll\" : \"libEGL.dll\");",
        "    const QString glesLibName \u003d QLatin1String(isDebug ? \"libGLESv2d.dll\" : \"libGLESv2.dll\");",
        "     //: %1 Context type (Open GL, EGL), ANGLE %2, %3 library names",
        "    const char msg[] \u003d QT_TRANSLATE_NOOP(",
        "        \"QSGRenderContext\",",
        "        \"Failed to create %1 context for format %2.\"",
        "        \"This is most likely caused by not having the necessary graphics drivers installed.\\n\\n\"",
        "        \"Install a driver providing OpenGL 2.0 or higher, or, if this is not possible, \"",
        "        \"make sure the ANGLE Open GL ES 2.0 emulation libraries (%3, %4 and d3dcompiler_*.dll) \"",
        "        \"are available in the application executable\u0027s directory or in a location listed in PATH.\");",
        "    *translatedMessage \u003d tr(msg).arg(contextType, formatStr, eglLibName, glesLibName);",
        "    *untranslatedMessage \u003d QString::fromLatin1(msg).arg(contextType, formatStr, eglLibName, glesLibName);",
        "#else // Q_OS_WIN32",
        "    //: %1 Context type (Open GL, EGL), %2 format specification",
        "    const char msg[] \u003d QT_TRANSLATE_NOOP(\"QSGRenderContext\",",
        "                                         \"Failed to create %1 context for format %2\");",
        "    *translatedMessage \u003d tr(msg).arg(contextType, formatStr);",
        "    *untranslatedMessage \u003d QString::fromLatin1(msg).arg(contextType, formatStr);",
        "#endif // !Q_OS_WIN32",
        "}",
        ""
      ]
    },
    {
      "ab": [
        "QT_END_NAMESPACE",
        ""
      ]
    }
  ]
}
